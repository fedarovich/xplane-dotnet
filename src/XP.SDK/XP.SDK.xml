<?xml version="1.0"?>
<doc>
    <assembly>
        <name>XP.SDK</name>
    </assembly>
    <members>
        <member name="M:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Creates an instance of an <see cref="T:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1"/>, in which data can be written to,
            with the default initial capacity.
            </summary>
            <param name="pool">The <see cref="T:System.Buffers.ArrayPool`1"/> to get arrays from.</param>
        </member>
        <member name="M:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.#ctor(System.Buffers.ArrayPool{`0},System.Int32)">
            <summary>
            Creates an instance of an <see cref="T:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1"/>, in which data can be written to,
            with an initial capacity specified.
            </summary>
            <param name="initialCapacity">The minimum capacity with which to initialize the underlying buffer.</param>
            <param name="pool">The <see cref="T:System.Buffers.ArrayPool`1"/> to get arrays from.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="initialCapacity"/> is not positive (i.e. less than or equal to 0).
            </exception>
        </member>
        <member name="P:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.WrittenMemory">
            <summary>
            Returns the data written to the underlying buffer so far, as a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.WrittenSpan">
            <summary>
            Returns the data written to the underlying buffer so far, as a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.WrittenCount">
            <summary>
            Returns the amount of data written to the underlying buffer so far.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.Capacity">
            <summary>
            Returns the total amount of space within the underlying buffer.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.FreeCapacity">
            <summary>
            Returns the amount of space available that can still be written into without forcing the underlying buffer to grow.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.Clear">
            <summary>
            Clears the data written to the underlying buffer.
            </summary>
            <remarks>
            You must clear the <see cref="T:System.Buffers.ArrayBufferWriter`1"/> before trying to re-use it.
            </remarks>
        </member>
        <member name="M:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.Advance(System.Int32)">
            <summary>
            Notifies <see cref="T:System.Buffers.IBufferWriter`1"/> that <paramref name="count"/> amount of data was written to the output <see cref="T:System.Span`1"/>/<see cref="T:System.Memory`1"/>
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when attempting to advance past the end of the underlying buffer.
            </exception>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="M:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.GetMemory(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> to write to that is at least the requested length (specified by <paramref name="sizeHint"/>).
            If no <paramref name="sizeHint"/> is provided (or it's equal to <code>0</code>), some non-empty buffer is returned.
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="sizeHint"/> is negative.
            </exception>
            <remarks>
            This will never return an empty <see cref="T:System.Memory`1"/>.
            </remarks>
            <remarks>
            There is no guarantee that successive calls will return the same buffer or the same-sized buffer.
            </remarks>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="M:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.GetSpan(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Span`1"/> to write to that is at least the requested length (specified by <paramref name="sizeHint"/>).
            If no <paramref name="sizeHint"/> is provided (or it's equal to <code>0</code>), some non-empty buffer is returned.
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="sizeHint"/> is negative.
            </exception>
            <remarks>
            This will never return an empty <see cref="T:System.Span`1"/>.
            </remarks>
            <remarks>
            There is no guarantee that successive calls will return the same buffer or the same-sized buffer.
            </remarks>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="P:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.IsCompleted">
            <summary>
            Checks whether the writer is completed.
            </summary>
            <seealso cref="M:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.Complete"/>
        </member>
        <member name="M:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.Complete">
            <summary>
            Completes the writer, so that no more write operations can be done.
            </summary>
            <seealso cref="P:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.IsCompleted"/>
        </member>
        <member name="M:XP.SDK.Text.Buffers.ArrayPoolBufferWriter`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Text.Buffers.CompletableArrayBufferWriter`1.Advance(System.Int32)">
            <summary>
            Notifies <see cref="T:System.Buffers.IBufferWriter`1"/> that <paramref name="count"/> amount of data was written to the output <see cref="T:System.Span`1"/>/<see cref="T:System.Memory`1"/>
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when attempting to advance past the end of the underlying buffer.
            </exception>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="M:XP.SDK.Text.Buffers.CompletableArrayBufferWriter`1.GetMemory(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> to write to that is at least the requested length (specified by <paramref name="sizeHint"/>).
            If no <paramref name="sizeHint"/> is provided (or it's equal to <code>0</code>), some non-empty buffer is returned.
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="sizeHint"/> is negative.
            </exception>
            <remarks>
            This will never return an empty <see cref="T:System.Memory`1"/>.
            </remarks>
            <remarks>
            There is no guarantee that successive calls will return the same buffer or the same-sized buffer.
            </remarks>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="M:XP.SDK.Text.Buffers.CompletableArrayBufferWriter`1.GetSpan(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Span`1"/> to write to that is at least the requested length (specified by <paramref name="sizeHint"/>).
            If no <paramref name="sizeHint"/> is provided (or it's equal to <code>0</code>), some non-empty buffer is returned.
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="sizeHint"/> is negative.
            </exception>
            <remarks>
            This will never return an empty <see cref="T:System.Span`1"/>.
            </remarks>
            <remarks>
            There is no guarantee that successive calls will return the same buffer or the same-sized buffer.
            </remarks>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="P:XP.SDK.Text.Buffers.CompletableArrayBufferWriter`1.WrittenMemory">
            <summary>
            Returns the data written to the underlying buffer so far, as a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.CompletableArrayBufferWriter`1.WrittenSpan">
            <summary>
            Returns the data written to the underlying buffer so far, as a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.CompletableArrayBufferWriter`1.WrittenCount">
            <summary>
            Returns the amount of data written to the underlying buffer so far.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.CompletableArrayBufferWriter`1.IsCompleted">
            <summary>
            Checks whether the writer is completed.
            </summary>
            <seealso cref="M:XP.SDK.Text.Buffers.CompletableArrayBufferWriter`1.Complete"/>
        </member>
        <member name="M:XP.SDK.Text.Buffers.CompletableArrayBufferWriter`1.Complete">
            <summary>
            Completes the writer, so that no more write operations can be done.
            </summary>
            <seealso cref="P:XP.SDK.Text.Buffers.CompletableArrayBufferWriter`1.IsCompleted"/>
        </member>
        <member name="P:XP.SDK.Text.Buffers.IBufferAccessor`1.WrittenMemory">
            <summary>
            Returns the data written to the underlying buffer so far, as a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.IBufferAccessor`1.WrittenSpan">
            <summary>
            Returns the data written to the underlying buffer so far, as a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.IBufferAccessor`1.WrittenCount">
            <summary>
            Returns the amount of data written to the underlying buffer so far.
            </summary>
        </member>
        <member name="T:XP.SDK.Text.Buffers.ICompletableBufferWriter`1">
            <summary>
            Buffer writer which can be completed.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.ICompletableBufferWriter`1.IsCompleted">
            <summary>
            Checks whether the writer is completed.
            </summary>
            <seealso cref="M:XP.SDK.Text.Buffers.ICompletableBufferWriter`1.Complete"/>
        </member>
        <member name="M:XP.SDK.Text.Buffers.ICompletableBufferWriter`1.Complete">
            <summary>
            Completes the writer, so that no more write operations can be done.
            </summary>
            <seealso cref="P:XP.SDK.Text.Buffers.ICompletableBufferWriter`1.IsCompleted"/>
        </member>
        <member name="M:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.#ctor(System.Buffers.MemoryPool{`0},System.Boolean)">
            <summary>
            Creates an instance of an <see cref="T:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1"/>, in which data can be written to,
            with the default initial capacity.
            </summary>
            <param name="pool">The <see cref="T:System.Buffers.MemoryPool`1"/> to get arrays from.</param>
            <param name="disposePool">The value indicating whether the <paramref name="pool"/> must be disposed while disposing this instance.</param>
        </member>
        <member name="M:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.#ctor(System.Buffers.MemoryPool{`0},System.Boolean,System.Int32)">
            <summary>
            Creates an instance of an <see cref="T:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1"/>, in which data can be written to,
            with an initial capacity specified.
            </summary>
            <param name="initialCapacity">The minimum capacity with which to initialize the underlying buffer.</param>
            <param name="pool">The <see cref="T:System.Buffers.MemoryPool`1"/> to get arrays from.</param>
            <param name="disposePool">The value indicating whether the <paramref name="pool"/> must be disposed while disposing this instance.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="initialCapacity"/> is not positive (i.e. less than or equal to 0).
            </exception>
        </member>
        <member name="P:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.WrittenMemory">
            <summary>
            Returns the data written to the underlying buffer so far, as a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.WrittenSpan">
            <summary>
            Returns the data written to the underlying buffer so far, as a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.WrittenCount">
            <summary>
            Returns the amount of data written to the underlying buffer so far.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.Capacity">
            <summary>
            Returns the total amount of space within the underlying buffer.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.FreeCapacity">
            <summary>
            Returns the amount of space available that can still be written into without forcing the underlying buffer to grow.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.Clear">
            <summary>
            Clears the data written to the underlying buffer.
            </summary>
            <remarks>
            You must clear the <see cref="T:System.Buffers.ArrayBufferWriter`1"/> before trying to re-use it.
            </remarks>
        </member>
        <member name="M:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.Advance(System.Int32)">
            <summary>
            Notifies <see cref="T:System.Buffers.IBufferWriter`1"/> that <paramref name="count"/> amount of data was written to the output <see cref="T:System.Span`1"/>/<see cref="T:System.Memory`1"/>
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when attempting to advance past the end of the underlying buffer.
            </exception>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="M:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.GetMemory(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> to write to that is at least the requested length (specified by <paramref name="sizeHint"/>).
            If no <paramref name="sizeHint"/> is provided (or it's equal to <code>0</code>), some non-empty buffer is returned.
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="sizeHint"/> is negative.
            </exception>
            <remarks>
            This will never return an empty <see cref="T:System.Memory`1"/>.
            </remarks>
            <remarks>
            There is no guarantee that successive calls will return the same buffer or the same-sized buffer.
            </remarks>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="M:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.GetSpan(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Span`1"/> to write to that is at least the requested length (specified by <paramref name="sizeHint"/>).
            If no <paramref name="sizeHint"/> is provided (or it's equal to <code>0</code>), some non-empty buffer is returned.
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="sizeHint"/> is negative.
            </exception>
            <remarks>
            This will never return an empty <see cref="T:System.Span`1"/>.
            </remarks>
            <remarks>
            There is no guarantee that successive calls will return the same buffer or the same-sized buffer.
            </remarks>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="P:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.IsCompleted">
            <summary>
            Checks whether the writer is completed.
            </summary>
            <seealso cref="M:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.Complete"/>
        </member>
        <member name="M:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.Complete">
            <summary>
            Completes the writer, so that no more write operations can be done.
            </summary>
            <seealso cref="P:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.IsCompleted"/>
        </member>
        <member name="M:XP.SDK.Text.Buffers.MemoryPoolBufferWriter`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Text.Formatters.EnumFormatter`1.GetSymbolOrDefault(System.Buffers.StandardFormat@,System.Char)">
            <summary>
            Returns the symbol contained within the standard format. If the standard format
            has not been initialized, returns the provided fallback symbol.
            </summary>
        </member>
        <member name="T:XP.SDK.Text.NewLineSequence">
            <summary>
            The new-line character sequence to use.
            </summary>
        </member>
        <member name="F:XP.SDK.Text.NewLineSequence.Auto">
            <summary>
            <c>\r\n</c> on Windows; <c>\n</c> on other platforms.
            </summary>
        </member>
        <member name="F:XP.SDK.Text.NewLineSequence.Windows">
            <summary>
            <c>\r\n</c>
            </summary>
        </member>
        <member name="F:XP.SDK.Text.NewLineSequence.Unix">
            <summary>
            <c>\n</c>
            </summary>
        </member>
        <member name="T:XP.SDK.Text.SupportedFormatAttribute">
            <summary>
            Identifies one of the format symbols supported by <see cref="T:XP.SDK.Text.IUtf8Formattable"/> implementation.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.SupportedFormatAttribute.#ctor(System.Char)">
            <summary>
            Initialized a new instance of <see cref="T:XP.SDK.Text.SupportedFormatAttribute"/>.
            </summary>
            <param name="format">The supported format symbol.</param>
        </member>
        <member name="P:XP.SDK.Text.SupportedFormatAttribute.Format">
            <summary>
            Gets the supported format symbol.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.SupportedFormatAttribute.Description">
            <summary>
            Gets or sets the optional description.
            </summary>
        </member>
        <member name="T:XP.SDK.Text.Utf8StringBuilder">
            <summary>
            Provides a way to build a <see cref="T:XP.SDK.Utf8String"/>.
            </summary>
            <remarks>
            <para>
            You must always call <see cref="M:XP.SDK.Text.Utf8StringBuilder.Dispose"/> on the builder if it uses the memory from <see cref="T:System.Buffers.ArrayPool`1"/> or <see cref="T:System.Buffers.MemoryPool`1"/>.
            The easiest way to do is to use <c>using</c> block in C# (see the example below).
            </para>
            <para>
            You must never use the UTF-8 string created by the builder after the builder has been disposed.
            </para>
            </remarks>
            <example>
            The following example shows how you can use <see cref="T:XP.SDK.Text.Utf8StringBuilderFactory"/>
            to create a <see cref="T:XP.SDK.Text.Utf8StringBuilder"/> and build a <see cref="T:XP.SDK.Utf8String"/> with it.
            <code>
            <![CDATA[
            void SayHello(Utf8StringBuilderFactory factory)
            {
                using Utf8StringBuilder builder = factory.CreateBuilder();
                builder.Append("Hello, world!");
                builder.AppendLine();
                Utf8String str = builder.Build();
                XPlane.Trace.Write(str);
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="P:XP.SDK.Text.Utf8StringBuilder.RequiresScope">
            <summary>
            Gets the value indicating whether the underlying buffer is scoped, and so the constructed string must be created using <see cref="M:XP.SDK.Text.Utf8StringBuilder.BuildScoped"/> method.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.AppendLine">
            <summary>
            Appends a platform-dependent new line to the string.
            </summary>
            <remarks>
            This method will append <c>\r\n</c> on Windows and <c>\n</c> on all other platforms.
            </remarks>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.AppendLine(XP.SDK.Text.NewLineSequence)">
            <summary>
            Appends a new line to the string.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.String)">
            <summary>
            Appends the string.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.String,System.Int32)">
            <summary>
            Appends the substring of the string.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.String,System.Int32,System.Int32)">
            <summary>
            Appends the substring of the string.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.String,System.Range)">
            <summary>
            Appends the substring of the string.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Appends the UTF-16 string.
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(XP.SDK.Utf8String@)">
            <summary>
            Appends the UTF-8 string.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(XP.SDK.Utf8String@,System.Int32)">
            <summary>
            Appends the UTF-8 substring.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(XP.SDK.Utf8String@,System.Int32,System.Int32)">
            <summary>
            Appends the UTF-8 substring.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(XP.SDK.Utf8String@,System.Range)">
            <summary>
            Appends the UTF-8 substring.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Appends the UTF-8 substring.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.Boolean,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.Byte,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.Byte"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.Char,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.Char"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.DateTime,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.DateTime"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.DateTimeOffset,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.DateTimeOffset"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.Decimal,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.Decimal"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.Double,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.Double"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.Guid,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.Guid"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.Int16,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.Int16"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.Int32,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.Int32"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.Int64,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.Int64"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.IntPtr,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.IntPtr"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.SByte,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.SByte"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.Single,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.Single"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.TimeSpan,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.TimeSpan"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.UInt16,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.UInt16"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.UInt32,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.UInt64,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append(System.UIntPtr,System.Buffers.StandardFormat)">
            <summary>
            Appends the <see cref="T:System.UIntPtr"/> value.
            </summary>
            <param name="value">The value to append.</param>
            <param name="format">The format. See <seealso cref="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)"/> for the available formats.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append``1(``0,System.Buffers.StandardFormat)">
            <summary>
            Appends the value of type implementing <see cref="T:XP.SDK.Text.IUtf8Formattable"/> interface.
            </summary>
            <typeparam name="T">The formattable type.</typeparam>
            <param name="value">The formattable value.</param>
            <param name="format">The format.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Append``1(``0@,System.Buffers.StandardFormat)">
            <summary>
            Appends the value of type implementing <see cref="T:XP.SDK.Text.IUtf8Formattable"/> interface.
            </summary>
            <typeparam name="T">The formattable type.</typeparam>
            <param name="value">The formattable value.</param>
            <param name="format">The format.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Build">
            <summary>
            Completes building of the UTF-8 string and returns the built string.
            </summary>
            <returns>The built UTF-8 string.</returns>
            <remarks>
            It is not possible to modify the string and the builder after this method is called.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The underlying buffer is disposable. <see cref="M:XP.SDK.Text.Utf8StringBuilder.BuildScoped"/> method must be used instead.</exception>
            <seealso cref="M:XP.SDK.Text.Utf8StringBuilder.BuildScoped"/>
            <seealso cref="P:XP.SDK.Text.Utf8StringBuilder.RequiresScope"/>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.BuildScoped">
            <summary>
            Completes building of the UTF-8 string and returns the disposable scope containing the built string.
            </summary>
            <returns>The the disposable scope containing the built UTF-8 string.</returns>
            <remarks>
            It is not possible to modify the string and the builder after this method is called.
            </remarks>
            <seealso cref="M:XP.SDK.Text.Utf8StringBuilder.Build"/>
            <seealso cref="P:XP.SDK.Text.Utf8StringBuilder.RequiresScope"/>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.ToString">
            <summary>
            Gets the current representation of the string stored in the builder.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilder.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilderExtensions.Append``1(XP.SDK.Text.Utf8StringBuilder@,``0,System.Buffers.StandardFormat)">
            <summary>
            Append the value of enum type <typeparamref name="TEnum"/>.
            </summary>
            <typeparam name="TEnum">The enum type.</typeparam>
            <param name="builder">An instance of <see cref="T:XP.SDK.Text.Utf8StringBuilder"/>.</param>
            <param name="value">The value.</param>
            <param name="format">The format.</param>
        </member>
        <member name="T:XP.SDK.Text.Utf8StringBuilderFactory">
            <summary>
            Provides the means to create <see cref="T:XP.SDK.Text.Utf8StringBuilder"/>.
            </summary>
            <example>
            The following example shows how you can use <see cref="T:XP.SDK.Text.Utf8StringBuilderFactory"/>
            to create a <see cref="T:XP.SDK.Text.Utf8StringBuilder"/> and build a <see cref="T:XP.SDK.Utf8String"/> with it.
            <code>
            <![CDATA[
            void SayHello(Utf8StringBuilderFactory factory)
            {
                using Utf8StringBuilder builder = factory.CreateBuilder();
                builder.Append("Hello, world!");
                builder.AppendLine();
                Utf8String str = builder.Build();
                XPlane.Trace.Write(str);
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilderFactory.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:XP.SDK.Text.Utf8StringBuilderFactory"/> that will use a new managed array for each builder.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilderFactory.#ctor(System.Buffers.ArrayPool{System.Byte})">
            <summary>
            Initializes a new instance of <see cref="T:XP.SDK.Text.Utf8StringBuilderFactory"/> that will use managed arrays taken from the <paramref name="arrayPool"/> for each builder.
            </summary>
            <param name="arrayPool">The array pool to get arrays for the builder from.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilderFactory.#ctor(System.Buffers.ArrayPool{System.Byte},System.Boolean)">
            <summary>
            Initializes a new instance of <see cref="T:XP.SDK.Text.Utf8StringBuilderFactory"/> that will use managed arrays taken from the <paramref name="arrayPool"/> for each builder.
            </summary>
            <param name="arrayPool">The array pool to get arrays for the builder from.</param>
            <param name="disposePool">
            The value indicating whether the <paramref name="arrayPool"/> must be disposed while disposing this factory.
            If the array pool does not implement <see cref="T:System.IDisposable"/>, this parameter is ignored.
            </param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilderFactory.#ctor(System.Buffers.MemoryPool{System.Byte},System.Boolean)">
            <summary>
            Initializes a new instance of <see cref="T:XP.SDK.Text.Utf8StringBuilderFactory"/> that will use memory taken from the <paramref name="memoryPool"/> for each builder.
            </summary>
            <param name="memoryPool">The memory pool to get memory for the builder from.</param>
            <param name="disposePool">
            The value indicating whether the <paramref name="memoryPool"/> must be disposed while disposing this factory.
            </param>
        </member>
        <member name="P:XP.SDK.Text.Utf8StringBuilderFactory.Shared">
            <summary>
            Gets the shared instance of <see cref="T:XP.SDK.Text.Utf8StringBuilderFactory"/> that will use a new managed array for each builder.
            </summary>
        </member>
        <member name="P:XP.SDK.Text.Utf8StringBuilderFactory.SharedPooled">
            <summary>
            Gets the shared instance of <see cref="T:XP.SDK.Text.Utf8StringBuilderFactory"/> that will use managed arrays taken from the <see cref="P:System.Buffers.ArrayPool`1.Shared"/> for each builder.
            </summary>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilderFactory.CreateBuilder(System.Int32)">
            <summary>
            Creates a new <see cref="T:XP.SDK.Text.Utf8StringBuilder"/> with the specified initial capacity.
            </summary>
            <param name="initialCapacity">The initial buffer capacity of the string builder.</param>
        </member>
        <member name="M:XP.SDK.Text.Utf8StringBuilderFactory.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <remarks>
            If the factory was created using the default constructor or with a pool that is not disposable or must not be disposed together with this factory, you can skip calling this method.
            </remarks>
        </member>
        <member name="T:XP.SDK.Utf8String">
            <summary>
            Represents null-terminated C-style string in UTF-8 encoding.
            </summary>
        </member>
        <member name="P:XP.SDK.Utf8String.Empty">
            <summary>
            Gets the empty UTF-8 string.
            </summary>
        </member>
        <member name="P:XP.SDK.Utf8String.Span">
            <summary>
            Gets the underlying span.
            </summary>
        </member>
        <member name="P:XP.SDK.Utf8String.Length">
            <summary>
            Gets the string length.
            </summary>
            <seealso cref="M:XP.SDK.Utf8String.GetStringLength" />
        </member>
        <member name="P:XP.SDK.Utf8String.IsNull">
            <summary>
            Gets the value indicating whether the string is null.
            </summary>
            <seealso cref="P:XP.SDK.Utf8String.IsEmpty"/>
            <seealso cref="P:XP.SDK.Utf8String.IsNullOrEmpty" />
        </member>
        <member name="P:XP.SDK.Utf8String.IsEmpty">
            <summary>
            Gets the value indicating whether the string is empty.
            </summary>
            <seealso cref="P:XP.SDK.Utf8String.IsNull"/>
            <seealso cref="P:XP.SDK.Utf8String.IsNullOrEmpty" />
        </member>
        <member name="P:XP.SDK.Utf8String.IsNullOrEmpty">
            <summary>
            Gets the value indicating whether the string is null or empty.
            </summary>
            <seealso cref="P:XP.SDK.Utf8String.IsNull"/>
            <seealso cref="P:XP.SDK.Utf8String.IsEmpty"/>
        </member>
        <member name="M:XP.SDK.Utf8String.#ctor(System.ReadOnlySpan{System.Byte}@,System.Int32)">
            <summary>
            Initializes the string from read-only span.
            </summary>
            <param name="data">The read-only span containing the UTF-8 encoded string data.</param>
            <param name="length">The length of the string.</param>
            <remarks>
            <para>
            The <paramref name="data"/> must be of at least <c>length + 1</c> bytes long and must contain value <c>0</c> at position <paramref name="length"/>.
            This <c>0</c> value must be the first one in the string.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The <paramref name="data"/> is empty.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="data"/> does not contain <c>0</c> at position <paramref name="length"/>.</exception>
            <exception cref="T:System.IndexOutOfRangeException">The <paramref name="length"/> is less than 0 or greater than or equal to <c>data.Length</c></exception>
        </member>
        <member name="M:XP.SDK.Utf8String.#ctor(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Initializes the string from read-only span.
            </summary>
            <param name="data">The read-only span containing the data.</param>
            <remarks>
            <para>
            If the <paramref name="data"/> is empty, <see cref="P:XP.SDK.Utf8String.IsNull"/> property of the resulting string will be null.
            </para>
            <para>
            The <paramref name="data"/> must contain at least one byte with the value <c>0</c>.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The <paramref name="data"/> does not contain zero byte.</exception>
        </member>
        <member name="M:XP.SDK.Utf8String.#ctor(System.Byte*)">
            <summary>
            Initializes the string from pointer.
            </summary>
            <param name="data">The pointer to the NULL-terminated string data..</param>
            <remarks>
            <para>
            If the <paramref name="data"/> is <see langword="null"/>, <see cref="P:XP.SDK.Utf8String.IsNull"/> property of the resulting string will be null.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The length of the string exceeds 2147483646.</exception>
        </member>
        <member name="M:XP.SDK.Utf8String.FromString(System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:XP.SDK.Utf8String"/> from the string.
            </summary>
            <param name="str">The string.</param>
            <param name="pinned">If <see langword="true"/>, the underlying memory buffer will be allocated in the Pinned Object Heap, instead of normal heap.</param>
            <remarks>The actual string data is stored in a managed array.</remarks>
        </member>
        <member name="M:XP.SDK.Utf8String.FromUtf16(System.ReadOnlySpan{System.Char}@,System.Boolean)">
            <summary>
            Creates a new <see cref="T:XP.SDK.Utf8String"/> from the span containing UTF-16 chars.
            </summary>
            <param name="chars">The span with char data.</param>
            <param name="pinned">If <see langword="true"/>, the underlying memory buffer will be allocated in the Pinned Object Heap, instead of normal heap.</param>
            <remarks>The actual string data is stored in a managed array.</remarks>
        </member>
        <member name="M:XP.SDK.Utf8String.TryCreate(System.ReadOnlySpan{System.Char}@,System.Span{System.Byte}@,XP.SDK.Utf8String@)">
            <summary>
            Tries to create <see cref="T:XP.SDK.Utf8String"/> from the UTF-16 string with data placed in <paramref name="destinationBuffer"/>.
            </summary>
            <param name="utf16String">The source UTF-16 string.</param>
            <param name="destinationBuffer">The destination buffer for UTF-8 string.</param>
            <param name="result">The resulting <see cref="T:XP.SDK.Utf8String"/> if the operation succeeded.</param>
            <returns><see langword="true"/> if the operation succeeded; <see langword="false"/> otherwise.</returns>
            <remarks>
            <para>
            If <paramref name="utf16String"/> is empty, this method will return <see langword="true"/> with the <paramref name="result"/> set to <see cref="P:XP.SDK.Utf8String.Empty"/>.
            </para>
            <para>
            If <paramref name="destinationBuffer"/> is empty or has not enough place to store the UTF-8 data with trailing null character, this method will return <see langword="false"/>.
            </para>
            </remarks>
        </member>
        <member name="M:XP.SDK.Utf8String.ToString">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Utf8String.Equals(XP.SDK.Utf8String@)">
            <summary>
            Compares whether two UTF8 strings are equal.
            </summary>
            <param name="other">The string to compare with.</param>
        </member>
        <member name="M:XP.SDK.Utf8String.GetPinnableReference">
            <summary>
            Returns a reference to the 0th element of the UTF-8 string. If the string is null (i.e. the underlying span is empty), returns null reference.
            It can be used for pinning and is required to support the use of span within a fixed statement.
            </summary>
        </member>
        <member name="M:XP.SDK.Utf8String.op_Explicit(XP.SDK.Utf8String@)~System.String">
            <summary>
            Converts the <see cref="T:XP.SDK.Utf8String"/> to <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:XP.SDK.Utf8String.Contains(XP.SDK.Utf8String@)">
            <summary>
            Returns a value indicating whether a specified substring occurs within this string.
            </summary>
            <param name="substring">The substring to seek.</param>
            <returns><see langword="true"/> if the value parameter occurs within this string, or if value is the empty string; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:XP.SDK.Utf8String.IndexOf(XP.SDK.Utf8String@)">
            <summary>
            Reports the zero-based index of the first occurrence of the specified substring in this instance.
            </summary>
            <param name="substring">The substring to seek.</param>
            <returns>The zero-based index position of value if that substring is found, or <c>-1</c> if it is not. If value is Null or Empty, the return value is <c>0</c>.</returns>
        </member>
        <member name="M:XP.SDK.Utf8String.LastIndexOf(XP.SDK.Utf8String@)">
            <summary>
            Reports the zero-based index of the last occurrence of the specified substring in this instance.
            </summary>
            <param name="substring">The substring to seek.</param>
            <returns>The zero-based index position of value if that substring is found, or <c>-1</c> if it is not. If value is Null or Empty, the return value is <c>-1</c>.</returns>
        </member>
        <member name="M:XP.SDK.Utf8String.StartsWith(XP.SDK.Utf8String@)">
            <summary>
            Determines whether the beginning of this string instance matches the specified string.
            </summary>
            <param name="substring">The string to compare.</param>
            <returns><see langword="true"/> if substring matches the beginning of this string; otherwise, <see langword="false"/></returns>
        </member>
        <member name="M:XP.SDK.Utf8String.EndsWith(XP.SDK.Utf8String@)">
            <summary>
            Determines whether the end of this string instance matches the specified string.
            </summary>
            <param name="substring">The string to compare.</param>
            <returns><see langword="true"/> if substring matches the end of this string; otherwise, <see langword="false"/></returns>
        </member>
        <member name="M:XP.SDK.Utf8String.CopyTo(System.Byte*)">
            <summary>
            Copies the data to the destination.
            </summary>
            <param name="destination">The destination to copy the data to. The destination buffer must be at least <c>Length + 1</c> bytes long.</param>
        </member>
        <member name="M:XP.SDK.Utf8String.GetStringLength">
            <summary>
            Returns the length of the C string.
            </summary>
            <returns>
            <para>The length of the C string is this object contains a valid C-string; <c>-1</c> otherwise.</para>
            <para>If <see cref="P:XP.SDK.Utf8String.IsNull"/>, returns <c>0</c>.</para>
            </returns>
            <remarks>
            The length of a C string is determined by the terminating null-character:
            A C string is as long as the number of characters between the beginning of the string and the terminating null character
            (without including the terminating null character itself).
            </remarks>
            <seealso cref="P:XP.SDK.Utf8String.Length"/>
        </member>
        <member name="T:XP.SDK.Utf8StringFormatAttribute">
            <summary>
            Mark partial method returning <see cref="T:XP.SDK.Utf8String"/> or <see cref="T:XP.SDK.Utf8StringScope"/> with this attribute
            in order to automatically generate the return value from the specified format string and method parameters.
            </summary>
        </member>
        <member name="T:XP.SDK.Utf8StringLiteralAttribute">
            <summary>
            Mark partial method returning <see cref="T:XP.SDK.Utf8String"/> with this attribute
            in order to automatically generate the return value from the specified literal.
            </summary>
        </member>
        <member name="M:XP.SDK.Utils.CStringLength(System.Byte*)">
            <summary>
            Gets the length on null-terminated string. This function is equivalent to <c>strlen_s</c> C function.
            </summary>
            <param name="str">The pointer to the string start.</param>
            <returns>
            <para>The length of the null-terminated byte string <paramref name="str"/>.</para>
            <para><c>0</c> if <paramref name="str"/> is <see langword="null"/>.</para>
            </returns>
        </member>
        <member name="M:XP.SDK.Utils.CStringLength(System.Byte*,System.UIntPtr)">
            <summary>
            Gets the length on null-terminated string. This function is equivalent to <c>strnlen_s</c> C function.
            </summary>
            <param name="str">The pointer to the string start.</param>
            <param name="maxLength">The maximal length to check.</param>
            <returns>
            <para>The length of the null-terminated byte string <paramref name="str"/>.</para>
            <para><c>0</c> if <paramref name="str"/> is <see langword="null"/>.</para>
            <para><c>maxLength</c> if the string does not contain null character in the first <paramref name="maxLength"/> bytes.</para>
            </returns>
        </member>
        <member name="T:XP.SDK.Widgets.Behavior">
            <summary>
            Provides a standard way to attach additional behavior to the widgets.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Behavior.IsEnabled">
            <summary>
            Gets or sets the value indicating whether this behavior is enabled. If the behavior is disabled, it won't handle any messages from the widget.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behavior.HandleMessageCore(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.WidgetID,System.IntPtr,System.IntPtr)">
            <summary>
            Low-level message handling routine.
            </summary>
            <remarks>
            You should generally prefer overriding <see cref="M:XP.SDK.Widgets.Behavior.HandleMessage(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Widget,System.IntPtr,System.IntPtr)"/> as it provides higher-level abstraction.
            </remarks>
            <param name="message">The message.</param>
            <param name="widgetId">The widget ID.</param>
            <param name="param1">The first message parameter.</param>
            <param name="param2">The second message parameter.</param>
            <returns>1 if the message was handled; 0 otherwise.</returns>
            <seealso cref="M:XP.SDK.Widgets.Behavior.HandleMessage(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Widget,System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:XP.SDK.Widgets.Behavior.HandleMessage(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Widget,System.IntPtr,System.IntPtr)">
            <summary>
            High-level message handling routine.
            </summary>
            <param name="message">The message.</param>
            <param name="widget">The widget.</param>
            <param name="param1">The first message parameter.</param>
            <param name="param2">The second message parameter.</param>
            <returns><see langword="true" /> if the message was handled; <see langword="false" /> otherwise.</returns>
            <seealso cref="M:XP.SDK.Widgets.Behavior.HandleMessageCore(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.WidgetID,System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="T:XP.SDK.Widgets.BehaviorCollection">
            <summary>
            Contains the list of <see cref="T:XP.SDK.Widgets.Behavior"/>s attached to the widget.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.BehaviorCollection.Add(XP.SDK.Widgets.Behavior)">
            <summary>
            Adds a behavior.
            </summary>
            <param name="behavior">The behavior to add.</param>
            <returns>This <see cref="T:XP.SDK.Widgets.BehaviorCollection"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="behavior"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:XP.SDK.Widgets.BehaviorCollection.Add``1">
            <summary>
            Adds a behavior.
            </summary>
            <typeparam name="T">The type of the behavior to add.</typeparam>
            <returns>This <see cref="T:XP.SDK.Widgets.BehaviorCollection"/>.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.BehaviorCollection.GetOrAdd``1">
            <summary>
            Returns a behavior of type <typeparamref name="T"/> if it exists or creates and adds a new instance otherwise.
            </summary>
            <typeparam name="T">The type of the behavior to get or add.</typeparam>
        </member>
        <member name="M:XP.SDK.Widgets.BehaviorCollection.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        </member>
        <member name="M:XP.SDK.Widgets.BehaviorCollection.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc cref="M:System.Collections.IEnumerable.GetEnumerator" />
        </member>
        <member name="T:XP.SDK.Widgets.Behaviors.CommonEventsBehavior">
            <summary>
            Provides .Net events for all common widget messages.
            </summary>
            <seealso cref="T:XP.SDK.Widgets.WidgetExtensions"/>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.CommonEventsBehavior.HandleMessage(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Widget,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.Widgets.Behaviors.DefocusKeyboardBehavior">
            <summary>
            This causes a click in the widget to send keyboard focus back to X-Plane.
            This stops editing of any text fields, etc.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.DefocusKeyboardBehavior.#ctor">
            <summary>
            Initializes a new instance.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.DefocusKeyboardBehavior.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="eatClicks">Specifies whether clicks in the background should be consumed by bringing the window to the foreground.</param>
        </member>
        <member name="P:XP.SDK.Widgets.Behaviors.DefocusKeyboardBehavior.EatClicks">
            <summary>
            Gets or sets the value indicating whether clicks in the background should be consumed by bringing the window to the foreground.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.DefocusKeyboardBehavior.HandleMessageCore(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.WidgetID,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.DefocusKeyboardBehavior.HandleMessage(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Widget,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.Widgets.Behaviors.DragWidgetBehavior">
            <summary>
            Drags the widget in response to mouse clicks.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.DragWidgetBehavior.#ctor">
            <summary>
            Initializes a new instance.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.DragWidgetBehavior.#ctor(XP.SDK.Rect@)">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="dragRegion">The global coordinates of the drag region, which might be a sub-region of your widget (for example, a title bar).</param>
        </member>
        <member name="P:XP.SDK.Widgets.Behaviors.DragWidgetBehavior.DragRegion">
            <summary>
            Gets or sets the global coordinates of the drag region, which might be a sub-region of your widget (for example, a title bar).
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.DragWidgetBehavior.HandleMessageCore(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.WidgetID,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.DragWidgetBehavior.HandleMessage(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Widget,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.Widgets.Behaviors.FixedLayoutBehavior">
            <summary>
            Causes the widget to maintain its children in fixed position relative to itself as it is resized. Use this on the top level 'window' widget for your window.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Behaviors.FixedLayoutBehavior.Shared">
            <summary>
            Gets a shared instance of <see cref="T:XP.SDK.Widgets.Behaviors.FixedLayoutBehavior"/>.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.FixedLayoutBehavior.HandleMessageCore(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.WidgetID,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.FixedLayoutBehavior.HandleMessage(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Widget,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.Widgets.Behaviors.SelectIfNeededBehavior">
            <summary>
            Causes the widget to bring its window to the foreground if it is not already.
            <see cref="P:XP.SDK.Widgets.Behaviors.SelectIfNeededBehavior.EatClicks"/> specifies whether clicks in the background should be consumed by bringing the window to the foreground.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.SelectIfNeededBehavior.#ctor">
            <summary>
            Initializes a new instance.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.SelectIfNeededBehavior.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="eatClicks">Specifies whether clicks in the background should be consumed by bringing the window to the foreground.</param>
        </member>
        <member name="P:XP.SDK.Widgets.Behaviors.SelectIfNeededBehavior.EatClicks">
            <summary>
            Gets or sets the value indicating whether clicks in the background should be consumed by bringing the window to the foreground.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.SelectIfNeededBehavior.HandleMessageCore(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.WidgetID,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Widgets.Behaviors.SelectIfNeededBehavior.HandleMessage(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Widget,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.Widgets.Button">
            <summary>
            Represents a button, check box or radio button.
            </summary>
            <remarks>
            <para>
            The button class provides a number of different button styles and
            behaviors, including push buttons, radio buttons, check boxes, etc. The
            button label appears on or next to the button depending on the button's
            appearance, or type.
            </para>
            <para>
            The button's behavior is a separate property that dictates who it hilights
            and what kinds of messages it sends. Since behavior and type are different,
            you can do strange things like make check boxes that act as push buttons or
            push buttons with radio button behavior.
            </para>
            </remarks>
        </member>
        <member name="F:XP.SDK.Widgets.Button.Class">
            <summary>
            The button class.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Button.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.Button"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="P:XP.SDK.Widgets.Button.Type">
            <summary>
            Gets or sets the button type.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Button.ButtonBehavior">
            <summary>
            Gets or sets the button behavior.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Button.IsChecked">
            <summary>
            Gets or sets the value indicating whether the button is checked.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Button.HandleMessage(XP.SDK.Widgets.WidgetMessage,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Widgets.Button.OnPressed">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.ButtonMessage.PushButtonPressed"/> message.
            </summary>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.Button.OnIsCheckedChanged(System.Boolean)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.ButtonMessage.ButtonStateChanged"/> message.
            </summary>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="E:XP.SDK.Widgets.Button.Pressed">
            <summary>
            Raised when a user completes a click and release in a button with <see cref="F:XP.SDK.Widgets.ButtonBehavior.PushButton"/> button behavior.
            </summary>
        </member>
        <member name="E:XP.SDK.Widgets.Button.IsCheckedChanged">
            <summary>
            Raised when a button that has <see cref="F:XP.SDK.Widgets.ButtonBehavior.CheckBox"/> or <see cref="F:XP.SDK.Widgets.ButtonBehavior.RadioButton"/> behavior
            is click and its value changes.
            </summary>
            <remarks>
            If the value changes by setting <see cref="P:XP.SDK.Widgets.Button.IsChecked"/> property, this event won't be raised.
            </remarks>
        </member>
        <member name="T:XP.SDK.Widgets.ButtonBehavior">
            <summary>
            <para>
            Button Behavior Values
            </para>
            <para>
            These define how the button responds to mouse clicks.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.ButtonMessage">
            <summary>
            <para>
            Button Messages
            </para>
            <para>
            These messages are sent by the button to itself and then up the widget
            chain when the button is clicked. (You may intercept them by providing a
            widget handler for the button itself or by providing a handler in a parent
            widget.)
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.ButtonProperty">
            <summary>
            <para>
            Button Properties
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.ButtonType">
            <summary>
            <para>
            Button Types
            </para>
            <para>
            These define the visual appearance of buttons but not how they respond to
            the mouse.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Caption">
            <summary>
            A caption is a simple widget that shows its descriptor as a string, useful
            for labeling parts of a window. It always shows its descriptor as its
            string and is otherwise transparent.
            </summary>
        </member>
        <member name="F:XP.SDK.Widgets.Caption.Class">
            <summary>
            The caption class.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Caption.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.Caption"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="P:XP.SDK.Widgets.Caption.IsLit">
            <summary>
            Gets or sets the value indicating whether the caption is lit.
            </summary>
            <remarks>Use lit captions against screens.</remarks>
        </member>
        <member name="T:XP.SDK.Widgets.CaptionProperty">
            <summary>
            <para>
            Caption Properties
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.CheckBox">
            <summary>
            Represent a check box.
            </summary>
            <remarks>
            <para>The <see cref="P:XP.SDK.Widgets.CheckBox.Type"/> property is forced to be <see cref="F:XP.SDK.Widgets.ButtonType.RadioButton"/>.</para>
            <para>The <see cref="P:XP.SDK.Widgets.CheckBox.ButtonBehavior"/> property is forced to be <see cref="F:XP.SDK.Widgets.ButtonBehavior.CheckBox"/>.</para>
            </remarks>
        </member>
        <member name="M:XP.SDK.Widgets.CheckBox.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.CheckBox"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="P:XP.SDK.Widgets.CheckBox.Type">
            <inheritdoc />
        </member>
        <member name="P:XP.SDK.Widgets.CheckBox.ButtonBehavior">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.Widgets.CustomWidget">
            <summary>
            A base class for creating custom widgets.
            </summary>
            <remarks>
            <para>
            The inheritors must override <see cref="M:XP.SDK.Widgets.CustomWidget.HandleMessage(XP.SDK.Widgets.WidgetMessage,System.IntPtr,System.IntPtr)"/> method.
            </para>
            <para>
            You can also create custom widgets by inheriting from <see cref="T:XP.SDK.Widgets.CustomWidgetEx"/>
            which provides higher-level interface but has worse performance.
            </para>
            </remarks>
            <seealso cref="T:XP.SDK.Widgets.CustomWidgetEx"/>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidget.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.CustomWidget"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidget.HandleMessage(XP.SDK.Widgets.WidgetMessage,System.IntPtr,System.IntPtr)">
            <summary>
            Handles widget messages.
            </summary>
            <param name="message">The message.</param>
            <param name="param1">The first message parameter.</param>
            <param name="param2">The second message parameter.</param>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:XP.SDK.Widgets.CustomWidgetEx">
            <summary>
            A base class for creating custom widgets.
            </summary>
            <remarks>
            <para>
            The inheritors should override the virtual methods for the message they actually need.
            </para>
            <para>
            You can also create custom widgets by inheriting from <see cref="T:XP.SDK.Widgets.CustomWidget"/>
            which provides lower-level interface but has better performance.
            </para>
            </remarks>
            <seealso cref="T:XP.SDK.Widgets.CustomWidget"/>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.CustomWidgetEx"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.HandleMessage(XP.SDK.Widgets.WidgetMessage,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnCreated(System.Boolean)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.Create"/> message.
            </summary>
            <remarks>
            <para>
            The create message is sent once per widget that is created with your widget function and once
            for any widget that has your widget function attached.
            </para>
            <para>Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/></para>
            </remarks>
            <param name="isSubclass"><see langword="true"/> if you are being added as a subclass, <see langword="false"/> if the widget is first being created.</param>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnDestroyed(System.Boolean)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.Destroy"/> message.
            </summary>
            <remarks>
            <para>The destroy message is sent once for each message that is destroyed that has your widget function.</para>
            <para>Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.DirectAllCallbacks"/></para>
            </remarks>
            <param name="recursive"><see langword="true"/> if being deleted by a recursive delete to the parent, <see langword="false"/> for explicit deletion.</param>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnPaint">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.Paint"/> message.
            </summary>
            <remarks>
            <para>
            The paint message is sent to your widget to draw itself. The paint message is the bare-bones
            message; in response you must draw yourself, draw your children, set up clipping and culling,
            check for visibility, etc. If you don't want to do all of this, ignore the paint message and
            a draw message (see below) will be sent to you.
            </para>
            <para>Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/></para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnDraw">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.Draw"/> message.
            </summary>
            <remarks>
            <para>
            The draw message is sent to your widget when it is time to draw yourself. OpenGL will be set up
            to draw in 2-d global screen coordinates, but you should use the XPLM to set up OpenGL state.
            </para>
            <para>Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/></para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnKeyPress(XP.SDK.Widgets.Interop.KeyState@)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.KeyPress"/> message.
            </summary>
            <remarks>
            <para>
            The key press message is sent once per key that is pressed. The first parameter is the type of key
            code (integer or char) and the second is the code itself. By handling this event, you consume the
            key stroke.
            </para>
            <para>Handling this message 'consumes' the keystroke; not handling it passes it to your parent widget.</para>
            <para>Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.UpChain"/></para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnTakingFocus(System.Boolean)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.KeyTakeFocus"/> message.
            </summary>
            <remarks>
            <para>
            Keyboard focus is being given to you. By handling this message you accept keyboard focus. 
            </para>
            <para>Handling this message accepts focus; not handling refuses focus.</para>
            <para>Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/></para>
            </remarks>
            <param name="fromChild"><see langword="true"/> if a child of yours gave up focus to you; <see langword="false"/> if someone set focus on you explicitly.</param>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnLostFocus(System.Boolean)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.KeyLoseFocus"/> message.
            </summary>
            <remarks>
            <para>
            Keyboard focus is being taken away from you.
            </para>
            <para>Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/></para>
            </remarks>
            <param name="takenByOtherWidget"><see langword="true"/> if focus is being taken by another widget; <see langword="false"/> if code requested to remove focus.</param>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnMouseDown(XP.SDK.Widgets.Interop.MouseState@)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.MouseDown"/> message.
            </summary>
            <remarks>
            <para>
            You receive one mousedown event per click.
            </para>
            <para>
            By accepting this you eat the click, otherwise your parent gets it. You will not receive drag and
            mouse up messages if you do not accept the down message.
            </para>
            <para>
            Handling this message consumes the mouse click, not handling it passes it to the next widget.
            You can act 'transparent' as a window by never handling mouse clicks to certain areas.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.UpChain"/>. NOTE: Technically this is direct dispatched, but the widgets library will shop
            it to each widget until one consumes the click, making it effectively "up chain".
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnMouseDrag(XP.SDK.Widgets.Interop.MouseState@)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.MouseDrag"/> message.
            </summary>
            <remarks>
            <para>
            You receive a series of mouse drag messages (typically one per frame in the sim) as the mouse is
            moved once you have accepted a <see cref="F:XP.SDK.Widgets.WidgetMessage.MouseDown"/> message.
            You will continue to receive these until the mouse button is released.
            You may receive multiple mouse state messages with the same mouse position. You will receive mouse
            drag events even if the mouse is dragged out of your current or original bounds at the time of the
            mouse down.
            </para>
            <para>Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/>.</para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnMouseUp(XP.SDK.Widgets.Interop.MouseState@)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.MouseUp"/> message.
            </summary>
            <remarks>
            <para>
            The mouseup event is sent once when the mouse button is released after a drag or click. You only
            receive this message if you accept the <see cref="F:XP.SDK.Widgets.WidgetMessage.MouseDown"/> message.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnReshape(XP.SDK.Widgets.Widget,XP.SDK.Widgets.Interop.WidgetGeometryChange@)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.Reshape"/> message.
            </summary>
            <remarks>
            <para>
            Your geometry or a child's geometry is being changed.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.UpChain"/>.
            </para>
            </remarks>
            <param name="originalWidget">The reshaped widget.</param>
            <param name="change">The change.</param>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnExposedChanged">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.ExposedChanged"/> message.
            </summary>
            <remarks>
            <para>
            Your exposed area has changed.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnChildAdded(XP.SDK.Widgets.Widget)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.AcceptChild"/> message.
            </summary>
            <remarks>
            <para>
            A child has been added to you.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnChildRemoved(XP.SDK.Widgets.Widget)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.LoseChild"/> message.
            </summary>
            <remarks>
            <para>
            A child has been removed from to you.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnParentChanged(XP.SDK.Widgets.Widget)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.AcceptParent"/> message.
            </summary>
            <remarks>
            <para>
            You now have a new parent, or have no parent.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnShown(XP.SDK.Widgets.Widget)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.Shown"/> message.
            </summary>
            <remarks>
            <para>
            You or a child has been shown. 
            </para>
            <para>
            Note that this does not include you being shown because your parent
            was shown, you were put in a new parent, your root was shown, etc.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.UpChain"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnHidden(XP.SDK.Widgets.Widget)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.Hidden"/> message.
            </summary>
            <remarks>
            <para>
            You have been hidden.
            </para>
            <para>
            Note that this does not include you being hidden because your parent
            was hidden, you were put in a new parent, your root was hidden, etc.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.UpChain"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnDescriptorChanged">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.DescriptorChanged"/> message.
            </summary>
            <remarks>
            <para>
            Your descriptor has changed.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnPropertyChanged(System.Int32,System.IntPtr)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.PropertyChanged"/> message.
            </summary>
            <remarks>
            <para>
            A property has changed.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.Direct"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnMouseWheel(XP.SDK.Widgets.Interop.MouseState@)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.MouseWheel"/> message.
            </summary>
            <remarks>
            <para>
            The mouse wheel has moved.
            </para>
            <para>
            Return <see langword="true"/> to consume the mouse wheel move, or <see langword="false"/> to pass the message to a parent.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.UpChain"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnCursorAdjust(XP.SDK.Widgets.Interop.MouseState@,XP.SDK.XPLM.CursorStatus@)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.CursorAdjust"/> message.
            </summary>
            <remarks>
            <para>
            The cursor is over your widget. If you consume this message, change the <paramref name="cursorStatus"/>
            value to indicate the desired result.
            </para>
            <para>
            Return <see langword="true"/> to consume this message, or <see langword="false"/> to pass the message to a parent.
            </para>
            <para>
            Dispatching: <see cref="F:XP.SDK.Widgets.DispatchMode.UpChain"/>.
            </para>
            </remarks>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.CustomWidgetEx.OnCustomMessage(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Handles custom messages.
            </summary>
            <param name="message">The message ID.</param>
            <param name="param1">The first message parameter.</param>
            <param name="param2">The second message parameter.</param>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:XP.SDK.Widgets.DispatchMode">
            <summary>
            <para>
            The dispatching modes describe how the widgets library sends out messages.
            Currently there are three modes:
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.ElementStyle">
            <summary>
            <para>
            Elements are individually drawable UI things like push buttons, etc. The
            style defines what kind of element you are drawing. Elements can be
            stretched in one or two dimensions (depending on the element). Some
            elements can be lit.
            </para>
            <para>
            In X-Plane 6 some elements must be drawn over metal. Some are scalable and
            some are not. Any element can be drawn anywhere in X-Plane 7.
            </para>
            <para>
            Scalable Axis Required Background
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetEventHandler`1">
            <summary>
            Generic event handler for widget message with no parameters.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetValueEventHandler`2">
            <summary>
            Generic event handler for widget message with one argument passed by value.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <typeparam name="TArgs">The argument type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="args">The argument.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetInEventHandler`2">
            <summary>
            Generic event handler for widget message with one argument passed by read-only reference.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <typeparam name="TArgs">The argument type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="args">The argument.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetRefEventHandler`2">
            <summary>
            Generic event handler for widget message with one argument passed by reference.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <typeparam name="TArgs">The argument type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="args">The argument.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetCreatedEventHandler`1">
            <summary>
            Event handler for <see cref="F:XP.SDK.Widgets.WidgetMessage.Create"/> message.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="isSubclass"><see langword="true"/> if you are being added as a subclass, <see langword="false"/> if the widget is first being created.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetDestroyedEventHandler`1">
            <summary>
            Event handler for <see cref="F:XP.SDK.Widgets.WidgetMessage.Destroy"/> message.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="isRecursive"><see langword="true"/> if being deleted by a recursive delete to the parent, <see langword="false"/> for explicit deletion.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetTakingFocusEventHandler`1">
            <summary>
            Event handler for <see cref="F:XP.SDK.Widgets.WidgetMessage.KeyTakeFocus"/> message.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="fromChild"><see langword="true"/> if a child of yours gave up focus to you; <see langword="false"/> if someone set focus on you explicitly.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetLostFocusEventHandler`1">
            <summary>
            Event handler for <see cref="F:XP.SDK.Widgets.WidgetMessage.KeyLoseFocus"/> message.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="takenByOtherWidget"><see langword="true"/> if focus is being taken by another widget; <see langword="false"/> if code requested to remove focus.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetReshapeEventHandler`1">
            <summary>
            Event handler for <see cref="F:XP.SDK.Widgets.WidgetMessage.Reshape"/> message.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="originalWidget">The reshaped widget.</param>
            <param name="change">The change.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetPropertyChangeEventHandler`1">
            <summary>
            Event handler for <see cref="F:XP.SDK.Widgets.WidgetMessage.PropertyChanged"/> message.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="propertyId">The property ID.</param>
            <param name="newValue">The new property value.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetCursorAdjustEventHandler`1">
            <summary>
            Event handler for <see cref="F:XP.SDK.Widgets.WidgetMessage.PropertyChanged"/> message.
            </summary>
            <typeparam name="TWidget">The widget type.</typeparam>
            <param name="sender">The sender.</param>
            <param name="mouseState">The mouse state.</param>
            <param name="cursorStatus">The cursor.</param>
            <param name="handled"><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</param>
        </member>
        <member name="T:XP.SDK.Widgets.GeneralGraphics">
            <summary>
            The general graphics widget can show one of many icons available from X-Plane.
            </summary>
        </member>
        <member name="F:XP.SDK.Widgets.GeneralGraphics.Class">
            <summary>
            The general graphics class.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.GeneralGraphics.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.GeneralGraphics"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="P:XP.SDK.Widgets.GeneralGraphics.Type">
            <summary>
            Gets or sets the general graphics type.
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.GeneralGraphicsProperty">
            <summary>
            <para>
            General Graphics Properties
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.GeneralGraphicsType">
            <summary>
            <para>
            General Graphics Types Values
            </para>
            <para>
            These define the icon for the general graphics.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Interop.KeyState">
            <summary>
            <para>
            When a key is pressed, a pointer to this struct is passed to your widget
            function.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Interop.MouseState">
            <summary>
            <para>
            When the mouse is clicked or dragged, a pointer to this structure is passed
            to your widget function.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.UIGraphicsAPI.DrawWindow(System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.Widgets.WindowStyle)">
            <summary>
            <para>
            This routine draws a window of the given dimensions at the given offset on
            the virtual screen in a given style. The window is automatically scaled as
            appropriate using a bitmap scaling technique (scaling or repeating) as
            appropriate to the style.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.UIGraphicsAPI.GetWindowDefaultDimensions(XP.SDK.Widgets.WindowStyle,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the default dimensions for a window. Output is either
            a minimum or fixed value depending on whether the window is scalable.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.UIGraphicsAPI.DrawElement(System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.Widgets.ElementStyle,System.Int32)">
            <summary>
            <para>
            XPDrawElement draws a given element at an offset on the virtual screen in
            set dimensions.
            *Even* if the element is not scalable, it will be scaled if the width and
            height do not match the preferred dimensions; it'll just look ugly. Pass
            inLit to see the lit version of the element; if the element cannot be lit
            this is ignored.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.UIGraphicsAPI.GetElementDefaultDimensions(XP.SDK.Widgets.ElementStyle,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the recommended or minimum dimensions of a given UI
            element. outCanBeLit tells whether the element has both a lit and unlit
            state. Pass `NULL` to not receive any of these parameters.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.UIGraphicsAPI.DrawTrack(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.Widgets.TrackStyle,System.Int32)">
            <summary>
            <para>
            This routine draws a track. You pass in the track dimensions and size; the
            track picks the optimal orientation for these dimensions. Pass in the
            track's minimum current and maximum values; the indicator will be
            positioned appropriately. You can also specify whether the track is lit or
            not.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.UIGraphicsAPI.GetTrackDefaultDimensions(XP.SDK.Widgets.TrackStyle,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns a track's default smaller dimension; all tracks are
            scalable in the larger dimension. It also returns whether a track can be
            lit.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.UIGraphicsAPI.GetTrackMetrics(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.Widgets.TrackStyle,System.Int32*,System.Int32*,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the metrics of a track. If you want to write UI code
            to manipulate a track, this routine helps you know where the mouse
            locations are. For most other elements, the rectangle the element is drawn
            in is enough information. However, the scrollbar drawing routine does some
            automatic placement; this routine lets you know where things ended up. You
            pass almost everything you would pass to the draw routine. You get out the
            orientation, and other useful stuff.
            </para>
            <para>
            Besides orientation, you get five dimensions for the five parts of a
            scrollbar, which are the down button, down area (area before the thumb),
            the thumb, and the up area and button. For horizontal scrollers, the left
            button decreases; for vertical scrollers, the top button decreases.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Interop.WidgetCreate">
            <summary>
            <para>
            This structure contains all of the parameters needed to create a wiget. It
            is used with XPUCreateWidgets to create widgets in bulk from an array. All
            parameters correspond to those of XPCreateWidget except for the container
            index.
            </para>
            <para>
            If the container index is equal to the index of a widget in the array, the
            widget in the array passed to XPUCreateWidgets is used as the parent of
            this widget. Note that if you pass an index greater than your own position
            in the array, the parent you are requesting will not exist yet.
            </para>
            <para>
            If the container index is NO_PARENT, the parent widget is specified as
            NULL. If the container index is PARAM_PARENT, the widget passed into
            XPUCreateWidgets is used.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Interop.WidgetFuncCallback">
            <summary>
            <para>
            This function defines your custom widget's behavior. It will be called by
            the widgets library to send messages to your widget. The message and widget
            ID are passed in, as well as two ptr-width signed parameters whose meaning
            varies with the message. Return 1 to indicate that you have processed the
            message, 0 to indicate that you have not. For any message that is not
            understood, return 0.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Interop.WidgetGeometryChange">
            <summary>
            <para>
            This structure contains the deltas for your widget's geometry when it
            changes.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.CreateWidget(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte*,System.Int32,XP.SDK.Widgets.WidgetID,XP.SDK.Widgets.WidgetClass)">
            <summary>
            <para>
            This function creates a new widget and returns the new widget's ID to you.
            If the widget creation fails for some reason, it returns NULL. Widget
            creation will fail either if you pass a bad class ID or if there is not
            adequate memory.
            </para>
            <para>
            Input Parameters:
            </para>
            <para>
            - Top, left, bottom, and right in global screen coordinates defining the
            widget's location on the screen.
            - inVisible is 1 if the widget should be drawn, 0 to start the widget as
            hidden.
            - inDescriptor is a null terminated string that will become the widget's
            descriptor.
            - inIsRoot is 1 if this is going to be a root widget, 0 if it will not be.
            - inContainer is the ID of this widget's container. It must be 0 for a root
            widget. for a non-root widget, pass the widget ID of the widget to place
            this widget within. If this widget is not going to start inside another
            widget, pass 0; this new widget will then just be floating off in space
            (and will not be drawn until it is placed in a widget.
            - inClass is the class of the widget to draw. Use one of the predefined
            class-IDs to create a standard widget.
            </para>
            <para>
            A note on widget embedding: a widget is only called (and will be drawn,
            etc.) if it is placed within a widget that will be called. Root widgets are
            always called. So it is possible to have whole chains of widgets that are
            simply not called. You can preconstruct widget trees and then place them
            into root widgets later to activate them if you wish.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.CreateWidget(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.Utf8String@,System.Int32,XP.SDK.Widgets.WidgetID,XP.SDK.Widgets.WidgetClass)">
            <summary>
            <para>
            This function creates a new widget and returns the new widget's ID to you.
            If the widget creation fails for some reason, it returns NULL. Widget
            creation will fail either if you pass a bad class ID or if there is not
            adequate memory.
            </para>
            <para>
            Input Parameters:
            </para>
            <para>
            - Top, left, bottom, and right in global screen coordinates defining the
            widget's location on the screen.
            - inVisible is 1 if the widget should be drawn, 0 to start the widget as
            hidden.
            - inDescriptor is a null terminated string that will become the widget's
            descriptor.
            - inIsRoot is 1 if this is going to be a root widget, 0 if it will not be.
            - inContainer is the ID of this widget's container. It must be 0 for a root
            widget. for a non-root widget, pass the widget ID of the widget to place
            this widget within. If this widget is not going to start inside another
            widget, pass 0; this new widget will then just be floating off in space
            (and will not be drawn until it is placed in a widget.
            - inClass is the class of the widget to draw. Use one of the predefined
            class-IDs to create a standard widget.
            </para>
            <para>
            A note on widget embedding: a widget is only called (and will be drawn,
            etc.) if it is placed within a widget that will be called. Root widgets are
            always called. So it is possible to have whole chains of widgets that are
            simply not called. You can preconstruct widget trees and then place them
            into root widgets later to activate them if you wish.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.CreateWidget(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{System.Char}@,System.Int32,XP.SDK.Widgets.WidgetID,XP.SDK.Widgets.WidgetClass)">
            <summary>
            <para>
            This function creates a new widget and returns the new widget's ID to you.
            If the widget creation fails for some reason, it returns NULL. Widget
            creation will fail either if you pass a bad class ID or if there is not
            adequate memory.
            </para>
            <para>
            Input Parameters:
            </para>
            <para>
            - Top, left, bottom, and right in global screen coordinates defining the
            widget's location on the screen.
            - inVisible is 1 if the widget should be drawn, 0 to start the widget as
            hidden.
            - inDescriptor is a null terminated string that will become the widget's
            descriptor.
            - inIsRoot is 1 if this is going to be a root widget, 0 if it will not be.
            - inContainer is the ID of this widget's container. It must be 0 for a root
            widget. for a non-root widget, pass the widget ID of the widget to place
            this widget within. If this widget is not going to start inside another
            widget, pass 0; this new widget will then just be floating off in space
            (and will not be drawn until it is placed in a widget.
            - inClass is the class of the widget to draw. Use one of the predefined
            class-IDs to create a standard widget.
            </para>
            <para>
            A note on widget embedding: a widget is only called (and will be drawn,
            etc.) if it is placed within a widget that will be called. Root widgets are
            always called. So it is possible to have whole chains of widgets that are
            simply not called. You can preconstruct widget trees and then place them
            into root widgets later to activate them if you wish.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.CreateCustomWidget(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte*,System.Int32,XP.SDK.Widgets.WidgetID,)">
            <summary>
            <para>
            This function is the same as XPCreateWidget except that instead of passing
            a class ID, you pass your widget callback function pointer defining the
            widget. Use this function to define a custom widget. All parameters are the
            same as XPCreateWidget, except that the widget class has been replaced with
            the widget function.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.CreateCustomWidget(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.Utf8String@,System.Int32,XP.SDK.Widgets.WidgetID,)">
            <summary>
            <para>
            This function is the same as XPCreateWidget except that instead of passing
            a class ID, you pass your widget callback function pointer defining the
            widget. Use this function to define a custom widget. All parameters are the
            same as XPCreateWidget, except that the widget class has been replaced with
            the widget function.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.CreateCustomWidget(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{System.Char}@,System.Int32,XP.SDK.Widgets.WidgetID,)">
            <summary>
            <para>
            This function is the same as XPCreateWidget except that instead of passing
            a class ID, you pass your widget callback function pointer defining the
            widget. Use this function to define a custom widget. All parameters are the
            same as XPCreateWidget, except that the widget class has been replaced with
            the widget function.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.DestroyWidget(XP.SDK.Widgets.WidgetID,System.Int32)">
            <summary>
            <para>
            This class destroys a widget. Pass in the ID of the widget to kill. If you
            pass 1 for inDestroyChilren, the widget's children will be destroyed first,
            then this widget will be destroyed. (Furthermore, the widget's children
            will be destroyed with the inDestroyChildren flag set to 1, so the
            destruction will recurse down the widget tree.) If you pass 0 for this
            flag, the child widgets will simply end up with their parent set to 0.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.SendMessageToWidget(XP.SDK.Widgets.WidgetID,XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.DispatchMode,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            This sends any message to a widget. You should probably not go around
            simulating the predefined messages that the widgets library defines for
            you. You may however define custom messages for your widgets and send them
            with this method.
            </para>
            <para>
            This method supports several dispatching patterns; see XPDispatchMode for
            more info. The function returns 1 if the message was handled, 0 if it was
            not.
            </para>
            <para>
            For each widget that receives the message (see the dispatching modes), each
            widget function from the most recently installed to the oldest one receives
            the message in order until it is handled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.PlaceWidgetWithin(XP.SDK.Widgets.WidgetID,XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            This function changes which container a widget resides in. You may NOT use
            this function on a root widget! inSubWidget is the widget that will be
            moved. Pass a widget ID in inContainer to make inSubWidget be a child of
            inContainer. It will become the last/closest widget in the container. Pass
            0 to remove the widget from any container. Any call to this other than
            passing the widget ID of the old parent of the affected widget will cause
            the widget to be removed from its old parent. Placing a widget within its
            own parent simply makes it the last widget.
            </para>
            <para>
            NOTE: this routine does not reposition the sub widget in global
            coordinates. If the container has layout management code, it will
            reposition the subwidget for you, otherwise you must do it with
            SetWidgetGeometry.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.CountChildWidgets(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            This routine returns the number of widgets another widget contains.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.GetNthChildWidget(XP.SDK.Widgets.WidgetID,System.Int32)">
            <summary>
            <para>
            This routine returns the widget ID of a child widget by index. Indexes are
            0 based, from 0 to one minus the number of widgets in the parent,
            inclusive. If the index is invalid, 0 is returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.GetParentWidget(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            Returns the parent of a widget, or 0 if the widget has no parent. Root
            widgets never have parents and therefore always return 0.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.ShowWidget(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            This routine makes a widget visible if it is not already. Note that if a
            widget is not in a rooted widget hierarchy or one of its parents is not
            visible, it will still not be visible to the user.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.HideWidget(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            Makes a widget invisible. See XPShowWidget for considerations of when a
            widget might not be visible despite its own visibility state.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.IsWidgetVisible(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            This returns 1 if a widget is visible, 0 if it is not. Note that this
            routine takes into consideration whether a parent is invisible. Use this
            routine to tell if the user can see the widget.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.FindRootWidget(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            Returns the Widget ID of the root widget that contains the passed in widget
            or NULL if the passed in widget is not in a rooted hierarchy.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.BringRootWidgetToFront(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            This routine makes the specified widget be in the front most widget
            hierarchy. If this widget is a root widget, its widget hierarchy comes to
            front, otherwise the widget's root is brought to the front. If this widget
            is not in an active widget hiearchy (e.g. there is no root widget at the
            top of the tree), this routine does nothing.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.IsWidgetInFront(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            This routine returns true if this widget's hierarchy is the front most
            hierarchy. It returns false if the widget's hierarchy is not in front, or
            if the widget is not in a rooted hierarchy.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.GetWidgetGeometry(XP.SDK.Widgets.WidgetID,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the bounding box of a widget in global coordinates.
            Pass NULL for any parameter you are not interested in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.SetWidgetGeometry(XP.SDK.Widgets.WidgetID,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            This function changes the bounding box of a widget.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.GetWidgetForLocation(XP.SDK.Widgets.WidgetID,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Given a widget and a location, this routine returns the widget ID of the
            child of that widget that owns that location. If inRecursive is true then
            this will return a child of a child of a widget as it tries to find the
            deepest widget at that location. If inVisibleOnly is true, then only
            visible widgets are considered, otherwise all widgets are considered. The
            widget ID passed for inContainer will be returned if the location is in
            that widget but not in a child widget. 0 is returned if the location is not
            in the container.
            </para>
            <para>
            NOTE: if a widget's geometry extends outside its parents geometry, it will
            not be returned by this call for mouse locations outside the parent
            geometry. The parent geometry limits the child's eligibility for mouse
            location.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.GetWidgetExposedGeometry(XP.SDK.Widgets.WidgetID,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the bounds of the area of a widget that is completely
            within its parent widgets. Since a widget's bounding box can be outside its
            parent, part of its area will not be elligible for mouse clicks and should
            not draw. Use XPGetWidgetGeometry to find out what area defines your
            widget's shape, but use this routine to find out what area to actually draw
            into. Note that the widget library does not use OpenGL clipping to keep
            frame rates up, although you could use it internally.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.SetWidgetDescriptor(XP.SDK.Widgets.WidgetID,System.Byte*)">
            <summary>
            <para>
            Every widget has a descriptor, which is a text string. What the text string
            is used for varies from widget to widget; for example, a push button's text
            is its descriptor, a caption shows its descriptor, and a text field's
            descriptor is the text being edited. In other words, the usage for the text
            varies from widget to widget, but this API provides a universal and
            convenient way to get at it. While not all UI widgets need their
            descriptor, many do.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.SetWidgetDescriptor(XP.SDK.Widgets.WidgetID,XP.SDK.Utf8String@)">
            <summary>
            <para>
            Every widget has a descriptor, which is a text string. What the text string
            is used for varies from widget to widget; for example, a push button's text
            is its descriptor, a caption shows its descriptor, and a text field's
            descriptor is the text being edited. In other words, the usage for the text
            varies from widget to widget, but this API provides a universal and
            convenient way to get at it. While not all UI widgets need their
            descriptor, many do.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.SetWidgetDescriptor(XP.SDK.Widgets.WidgetID,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Every widget has a descriptor, which is a text string. What the text string
            is used for varies from widget to widget; for example, a push button's text
            is its descriptor, a caption shows its descriptor, and a text field's
            descriptor is the text being edited. In other words, the usage for the text
            varies from widget to widget, but this API provides a universal and
            convenient way to get at it. While not all UI widgets need their
            descriptor, many do.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.GetWidgetDescriptor(XP.SDK.Widgets.WidgetID,System.Byte*,System.Int32)">
            <summary>
            <para>
            This routine returns the widget's descriptor. Pass in the length of the
            buffer you are going to receive the descriptor in. The descriptor will be
            null terminated for you. This routine returns the length of the actual
            descriptor; if you pass NULL for outDescriptor, you can get the
            descriptor's length without getting its text. If the length of the
            descriptor exceeds your buffer length, the buffer will not be null
            terminated (this routine has 'strncpy' semantics).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.GetWidgetUnderlyingWindow(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            Returns the window (from the XPLMDisplay API) that backs your widget
            window. If you have opted in to modern windows, via a call to
            XPLMEnableFeature("XPLM_USE_NATIVE_WIDGET_WINDOWS", 1), you can use the
            returned window ID for display APIs like XPLMSetWindowPositioningMode(),
            allowing you to pop the widget window out into a real OS window, or move it
            into VR.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.SetWidgetProperty(XP.SDK.Widgets.WidgetID,XP.SDK.Widgets.WidgetPropertyID,System.IntPtr)">
            <summary>
            <para>
            This function sets a widget's property. Properties are arbitrary values
            associated by a widget by ID.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.GetWidgetProperty(XP.SDK.Widgets.WidgetID,XP.SDK.Widgets.WidgetPropertyID,System.Int32*)">
            <summary>
            <para>
            This routine returns the value of a widget's property, or 0 if the property
            is not defined. If you need to know whether the property is defined, pass a
            pointer to an int for inExists; the existence of that property will be
            returned in the int. Pass NULL for inExists if you do not need this
            information.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.SetKeyboardFocus(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            Controls which widget will receive keystrokes. Pass the widget ID of the
            widget to get the keys. Note that if the widget does not care about
            keystrokes, they will go to the parent widget, and if no widget cares about
            them, they go to X-Plane.
            </para>
            <para>
            If you set the keyboard focus to widget ID 0, X-Plane gets keyboard focus.
            </para>
            <para>
            This routine returns the widget ID that ended up with keyboard focus, or 0
            for X-Plane.
            </para>
            <para>
            Keyboard focus is not changed if the new widget will not accept it. For
            setting to X-Plane, keyboard focus is always accepted.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.LoseKeyboardFocus(XP.SDK.Widgets.WidgetID)">
            <summary>
            <para>
            This causes the specified widget to lose focus; focus is passed to its
            parent, or the next parent that will accept it. This routine does nothing
            if this widget does not have focus.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.GetWidgetWithFocus">
            <summary>
            <para>
            This routine returns the widget that has keyboard focus, or 0 if X-Plane
            has keyboard focus or some other plugin window that does not have widgets
            has focus.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.AddWidgetCallback(XP.SDK.Widgets.WidgetID,)">
            <summary>
            <para>
            This function adds a new widget callback to a widget. This widget callback
            supercedes any existing ones and will receive messages first; if it does
            not handle messages they will go on to be handled by pre-existing widgets.
            </para>
            <para>
            The widget function will remain on the widget for the life of the widget.
            The creation message will be sent to the new callback immediately with the
            widget ID, and the destruction message will be sent before the other widget
            function receives a destruction message.
            </para>
            <para>
            This provides a way to 'subclass' an existing widget. By providing a second
            hook that only handles certain widget messages, you can customize or extend
            widget behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetsAPI.GetWidgetClassFunc(XP.SDK.Widgets.WidgetClass)">
            <summary>
            <para>
            Given a widget class, this function returns the callbacks that power that
            widget class.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetUtilsAPI.CreateWidgets(XP.SDK.Widgets.Interop.WidgetCreate*,System.Int32,XP.SDK.Widgets.WidgetID,XP.SDK.Widgets.WidgetID*)">
            <summary>
            <para>
            This function creates a series of widgets from a table (see
            XPCreateWidget_t above). Pass in an array of widget creation structures and
            an array of widget IDs that will receive each widget.
            </para>
            <para>
            Widget parents are specified by index into the created widget table,
            allowing you to create nested widget structures. You can create multiple
            widget trees in one table. Generally you should create widget trees from
            the top down.
            </para>
            <para>
            You can also pass in a widget ID that will be used when the widget's parent
            is listed as PARAM_PARENT; this allows you to embed widgets created with
            XPUCreateWidgets in a widget created previously.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetUtilsAPI.MoveWidgetBy(XP.SDK.Widgets.WidgetID,System.Int32,System.Int32)">
            <summary>
            <para>
            Simply moves a widget by an amount, +x = right, +y=up, without resizing the
            widget.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetUtilsAPI.FixedLayout(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.WidgetID,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            This function causes the widget to maintain its children in fixed position
            relative to itself as it is resized. Use this on the top level 'window'
            widget for your window.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetUtilsAPI.SelectIfNeeded(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.WidgetID,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            <para>
            This causes the widget to bring its window to the foreground if it is not
            already. inEatClick specifies whether clicks in the background should be
            consumed by bringin the window to the foreground.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetUtilsAPI.DefocusKeyboard(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.WidgetID,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            <para>
            This causes a click in the widget to send keyboard focus back to X-Plane.
            This stops editing of any text fields, etc.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Interop.WidgetUtilsAPI.DragWidget(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.WidgetID,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            XPUDragWidget drags the widget in response to mouse clicks. Pass in not
            only the event, but the global coordinates of the drag region, which might
            be a sub-region of your widget (for example, a title bar).
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.IWidgetCollection">
            <summary>
            The interface for a collection of child <see cref="T:XP.SDK.Widgets.Widget"/>s.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.IWidgetCollection.Add(XP.SDK.Widgets.Widget)">
            <summary>
            Adds a widget.
            </summary>
            <param name="widget">The widget to add.</param>
        </member>
        <member name="M:XP.SDK.Widgets.IWidgetCollection.Remove(XP.SDK.Widgets.Widget)">
            <summary>
            Removes the widget.
            </summary>
            <param name="widget">The widget to remove.</param>
        </member>
        <member name="T:XP.SDK.Widgets.MainWindow">
            <summary>
            The main window widget class provides a "window" as the user knows it.
            These windows are draggable and can be selected. Use them to create floating
            windows and non-modal dialogs.
            </summary>
        </member>
        <member name="F:XP.SDK.Widgets.MainWindow.Class">
            <summary>
            The main window class.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.MainWindow.#ctor(XP.SDK.Rect@,System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.MainWindow"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
        </member>
        <member name="P:XP.SDK.Widgets.MainWindow.Type">
            <summary>
            Gets or sets the main window type.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.MainWindow.HasCloseBoxes">
            <summary>
            Gets or sets the value indicating whether the main window has close boxes in its corners.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.MainWindow.HandleMessage(XP.SDK.Widgets.WidgetMessage,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Widgets.MainWindow.OnCloseButtonPushed">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.MainWindowMessage.CloseButtonPushed"/> message.
            </summary>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="E:XP.SDK.Widgets.MainWindow.CloseButtonPushed">
            <summary>
            Raised when the close buttons are pressed for your window. 
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.MainWindowMessage">
            <summary>
            <para>
            MainWindow Messages
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.MainWindowProperty">
            <summary>
            <para>
            Main Window Properties
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.MainWindowType">
            <summary>
            <para>
            Main Window Type Values
            </para>
            <para>
            These type values are used to control the appearance of a main window.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.ProgressBar">
            <summary>
            This widget implements a progress indicator as seen when X-Plane starts up.
            </summary>
        </member>
        <member name="F:XP.SDK.Widgets.ProgressBar.Class">
            <summary>
            The progress bar class.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.ProgressBar.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.ProgressBar"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="P:XP.SDK.Widgets.ProgressBar.Value">
            <summary>
            Gets or sets the current value.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.ProgressBar.MinValue">
            <summary>
            Gets or sets the minimal value.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.ProgressBar.MaxValue">
            <summary>
            Gets or sets the maximal value.
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.ProgressBarProperty">
            <summary>
            <para>
            Progress Indicator Properties
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.PushButton">
            <summary>
            Represent a push button.
            </summary>
            <remarks>
            <para>The <see cref="P:XP.SDK.Widgets.PushButton.Type"/> property is forced to be <see cref="F:XP.SDK.Widgets.ButtonType.PushButton"/>.</para>
            <para>The <see cref="P:XP.SDK.Widgets.PushButton.ButtonBehavior"/> property is forced to be <see cref="F:XP.SDK.Widgets.ButtonBehavior.PushButton"/>.</para>
            </remarks>
        </member>
        <member name="M:XP.SDK.Widgets.PushButton.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.PushButton"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="P:XP.SDK.Widgets.PushButton.Type">
            <inheritdoc />
        </member>
        <member name="P:XP.SDK.Widgets.PushButton.ButtonBehavior">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.Widgets.RadioButton">
            <summary>
            Represent a radio button.
            </summary>
            <remarks>
            <para>The <see cref="P:XP.SDK.Widgets.RadioButton.Type"/> property is forced to be <see cref="F:XP.SDK.Widgets.ButtonType.RadioButton"/>.</para>
            <para>The <see cref="P:XP.SDK.Widgets.RadioButton.ButtonBehavior"/> property is forced to be <see cref="F:XP.SDK.Widgets.ButtonBehavior.RadioButton"/>.</para>
            </remarks>
        </member>
        <member name="M:XP.SDK.Widgets.RadioButton.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.RadioButton"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="P:XP.SDK.Widgets.RadioButton.Type">
            <inheritdoc />
        </member>
        <member name="P:XP.SDK.Widgets.RadioButton.ButtonBehavior">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.Widgets.ScrollBar">
            <summary>
            A standard scroll bar or slider control. The scroll bar has a minimum,
            maximum and current value that is updated when the user drags it.The
            scroll bar sends continuous messages as it is dragged.
            </summary>
        </member>
        <member name="F:XP.SDK.Widgets.ScrollBar.Class">
            <summary>
            The scroll bar class.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.ScrollBar.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.ScrollBar"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="P:XP.SDK.Widgets.ScrollBar.Type">
            <summary>
            Gets or sets the type of the scroll bar.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.ScrollBar.Value">
            <summary>
            Gets or sets the current value.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.ScrollBar.MinValue">
            <summary>
            Gets or sets the minimum value.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.ScrollBar.MaxValue">
            <summary>
            Gets or sets the maximum value.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.ScrollBar.PageSize">
            <summary>
            Gets or sets how many units to move the scroll bar when clicking next to the thumb.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.ScrollBar.HandleMessage(XP.SDK.Widgets.WidgetMessage,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Widgets.ScrollBar.OnValueChanged">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.ScrollBarMessage.ScrollBarSliderPositionChanged"/> message.
            </summary>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="E:XP.SDK.Widgets.ScrollBar.ValueChanged">
            <summary>
            Raised when the slider position changes.
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.ScrollBarMessage">
            <summary>
            <para>
            Scroll Bar Messages
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.ScrollBarProperty">
            <summary>
            <para>
            Scroll Bar Properties
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.ScrollBarType">
            <summary>
            <para>
            Scroll Bar Type Values
            </para>
            <para>
            This defines how the scroll bar looks.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.StandardWidget">
            <summary>
            The base class for standard widgets.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.StandardWidget.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean,XP.SDK.Widgets.WidgetClass)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.StandardWidget"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
            <param name="class">The standard widget class.</param>
        </member>
        <member name="M:XP.SDK.Widgets.StandardWidget.HandleMessage(XP.SDK.Widgets.WidgetMessage,System.IntPtr,System.IntPtr)">
            <summary>
            Handles widget messages.
            </summary>
            <param name="message">The message.</param>
            <param name="param1">The first message parameter.</param>
            <param name="param2">The second message parameter.</param>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:XP.SDK.Widgets.SubWindow">
            <summary>
            X-Plane dialogs are divided into separate areas; the sub-window widgets
            allow you to make these areas. Create one main window and place several
            sub-windows inside it.Then place your controls inside the sub- windows.
            </summary>
        </member>
        <member name="F:XP.SDK.Widgets.SubWindow.Class">
            <summary>
            The sub-window c
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.SubWindow.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.SubWindow"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="P:XP.SDK.Widgets.SubWindow.Type">
            <summary>
            Gets or sets the type of the sub-window.
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.SubWindowProperty">
            <summary>
            <para>
            SubWindow Properties
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.SubWindowType">
            <summary>
            <para>
            SubWindow Type Values
            </para>
            <para>
            These values control the appearance of the subwindow.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.TextField">
            <summary>
            The text field widget provides an editable text field including mouse
            selection and keyboard navigation.The contents of the text field are its
            <see cref="P:XP.SDK.Widgets.Widget.Descriptor"/>.
            </summary>
            <remarks>
            <para>The descriptor changes as the user types.</para>
            <para>
            The text field can have a number of types, that effect the visual layout of
            the text field.The text field sends messages to itself so you may control
            its behavior.
            </para>
            <para>
            If you need to filter keystrokes, subscribe to <see cref="E:XP.SDK.Widgets.TextField.KeyPressed"/>.
            Since key presses are passed by reference, you can modify the
            keystroke and pass it through to the text field widget.
            </para>
            </remarks>
        </member>
        <member name="F:XP.SDK.Widgets.TextField.Class">
            <summary>
            The text field class.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.TextField.#ctor(XP.SDK.Rect@,System.String,System.Boolean,XP.SDK.Widgets.Widget,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:XP.SDK.Widgets.TextField"/> class.
            </summary>
            <param name="geometry">The widget geometry.</param>
            <param name="descriptor">The widget descriptor.</param>
            <param name="isVisible">The widget visibility.</param>
            <param name="parent">The parent widget.</param>
            <param name="isRoot">The value indicating whether this widget is a root one.</param>
        </member>
        <member name="P:XP.SDK.Widgets.TextField.Type">
            <summary>
            Gets or sets the text field type.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.TextField.SelectionStart">
            <summary>
            Gets or sets the character position the selection starts at, zero based.
            </summary>
            <remarks>
            If it is the same as the end insertion point, the insertion point is not a selection.
            </remarks>
            <seealso cref="P:XP.SDK.Widgets.TextField.SelectionEnd"/>
        </member>
        <member name="P:XP.SDK.Widgets.TextField.SelectionEnd">
            <summary>
            Gets or sets the character position of the end of the selection.
            </summary>
            <seealso cref="P:XP.SDK.Widgets.TextField.SelectionStart"/>
        </member>
        <member name="P:XP.SDK.Widgets.TextField.SelectionDragStart">
            <summary>
            Gets the character position a drag was started at if the user is dragging to select text, or -1 if a drag is not in progress.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.TextField.IsPasswordMode">
            <summary>
            Gets the value indicating whether this text field is in password mode.
            </summary>
            <remarks>
            In the password mode the characters will be drawn as *s even though the descriptor will contain plain-text.
            </remarks>
        </member>
        <member name="P:XP.SDK.Widgets.TextField.MaxLength">
            <summary>
            Gets or sets the max number of characters you can enter, if limited. Zero means unlimited.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.TextField.ScrollPosition">
            <summary>
            Gets or sets the first visible character on the left. This effectively scrolls the text field.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.TextField.Font">
            <summary>
            Gets or sets the font to draw the field's text with.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.TextField.HandleMessage(XP.SDK.Widgets.WidgetMessage,System.IntPtr,System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.Widgets.TextField.OnTextChanged">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.TextFieldMessage.TextFieldChanged"/> message.
            </summary>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.TextField.OnKeyPressed(XP.SDK.Widgets.Interop.KeyState@)">
            <summary>
            Handles the <see cref="F:XP.SDK.Widgets.WidgetMessage.KeyPress"/> message.
            </summary>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="E:XP.SDK.Widgets.TextField.TextChanged">
            <summary>
            Raised when the text is changed.
            </summary>
        </member>
        <member name="E:XP.SDK.Widgets.TextField.KeyPressed">
            <summary>
            Raised when a key is pressed on the keyboard.
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.TextFieldMessage">
            <summary>
            <para>
            Text Field Messages
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.TextFieldProperty">
            <summary>
            <para>
            Text Field Properties
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.TextFieldType">
            <summary>
            <para>
            Text Field Type Values
            </para>
            <para>
            These control the look of the text field.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.TrackStyle">
            <summary>
            <para>
            A track is a UI element that displays a value vertically or horizontally.
            X-Plane has three kinds of tracks: scroll bars, sliders, and progress bars.
            Tracks can be displayed either horizontally or vertically; tracks will
            choose their own layout based on the larger dimension of their dimensions
            (e.g. they know if they are tall or wide). Sliders may be lit or unlit
            (showing the user manipulating them).
            </para>
            <para>
            - ScrollBar: this is a standard scroll bar with arrows and a thumb to drag.
            - Slider: this is a simple track with a ball in the middle that can be
            slid.
            - Progress: this is a progress indicator showing how a long task is going.
            </para>
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.IsRoot">
            <summary>
            Gets the value indicating whether the widget is the root one.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.Id">
            <summary>
            Gets the widget ID.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.Behaviors">
            <summary>
            Gets the widget behaviors.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.Descriptor">
            <summary>
            Gets or sets the widget descriptor.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.Geometry">
            <summary>
            Gets or sets the widget geometry.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.ExposedGeometry">
            <summary>
            Get the bounds of the area of a widget that is completely within its parent widgets.
            </summary>
            <remarks>
            Since a widget's bounding box can be outside its
            parent, part of its area will not be elligible for mouse clicks and should
            not draw. Use <see cref="P:XP.SDK.Widgets.Widget.Geometry"/> to find out what area defines your
            widget's shape, but use this routine to find out what area to actually draw
            into. Note that the widget library does not use OpenGL clipping to keep
            frame rates up, although you could use it internally.
            </remarks>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.IsInFront">
            <summary>
            Gets the value indicating whether this widget's hierarchy is the front most hierarchy.                 
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.IsVisible">
            <summary>
            Gets or sets the value indicating whether the widget is visible.
            </summary>
            <remarks>
            This property takes into consideration whether a parent is invisible.
            Use it to tell if the user can see the widget.
            </remarks>
            <seealso cref="M:XP.SDK.Widgets.Widget.Show"/>
            <seealso cref="M:XP.SDK.Widgets.Widget.Hide"/>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.Window">
            <summary>
            Gets the the window (<see cref="T:XP.SDK.XPLM.WindowBase"/>) that backs your widget window.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.Children">
            <summary>
            Gets the child widgets.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.Parent">
            <summary>
            Gets or sets the parent widget.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.Root">
            <summary>
            Gets the root widget.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.Tag">
            <summary>
            Gets or sets an arbitrary object that can be associated with the current widget.
            </summary>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.Clip">
            <summary>
            If <see langword="true"/> the widget package will use OpenGL to restrict drawing to the Widget's exposed rectangle.
            </summary>
            <seealso cref="P:XP.SDK.Widgets.Widget.ExposedGeometry"/>
        </member>
        <member name="P:XP.SDK.Widgets.Widget.IsEnabled">
            <summary>
            Gets the value indicating whether the widget is enabled.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.Show">
            <summary>
            This routine makes a widget visible if it is not already. Note that if a
            widget is not in a rooted widget hierarchy or one of its parents is not
            visible, it will still not be visible to the user.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.Hide">
            <summary>
            Makes a widget invisible.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.BringRootToFront">
            <summary>
            This routine makes the specified widget be in the front most widget
            hierarchy. If this widget is a root widget, its widget hierarchy comes to
            front, otherwise the widget's root is brought to the front. If this widget
            is not in an active widget hierarchy (e.g. there is no root widget at the
            top of the tree), this routine does nothing.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.GetWidgetForLocation(System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            <para>
            Given a widget and a location, this routine returns the <see cref="T:XP.SDK.Widgets.Widget"/> of the
            child of that widget that owns that location. If <paramref name="recursive"/> is <see langword="true" /> then
            this will return a child of a child of a widget as it tries to find the
            deepest widget at that location. If <paramref name="onlyVisible"/> is true, then only
            visible widgets are considered, otherwise all widgets are considered. The
            current widget will be returned if the location is in
            that widget but not in a child widget. <see langword="null" /> is returned if the location is not
            in the container.
            </para>
            <para>
            NOTE: if a widget's geometry extends outside its parents geometry, it will
            not be returned by this call for mouse locations outside the parent
            geometry. The parent geometry limits the child's eligibility for mouse
            location.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.Focus">
            <summary>
            Makes the current widget to receive keyboard strokes.
            </summary>
            <remarks>
            <para>
            Note that if the widget does not care about
            keystrokes, they will go to the parent widget, and if no widget cares about
            them, they go to X-Plane.
            </para>
            <para>
            Keyboard focus is not changed if this widget will not accept it.
            </para>
            </remarks>
            <returns>
            The widget that ended up with keyboard focus, or <see langword="null" /> for X-Plane.
            </returns>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.Focus(XP.SDK.Widgets.Widget)">
            <summary>
            Sets the widget than will receive keyboard strokes.
            </summary>
            <param name="widget">The widget to focus, or <see langword="null" /> to make X-Plane receive the focus.</param>
            <remarks>
            <para>
            Note that if the widget does not care about
            keystrokes, they will go to the parent widget, and if no widget cares about
            them, they go to X-Plane.
            </para>
            <para>
            Keyboard focus is not changed if the new widget will not accept it. For
            setting to X-Plane, keyboard focus is always accepted.
            </para>
            </remarks>
            <returns>
            The widget that ended up with keyboard focus, or <see langword="null" /> for X-Plane.
            </returns>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.LoseFocus">
            <summary>
            This causes the specified widget to lose focus; focus is passed to its
            parent, or the next parent that will accept it. This routine does nothing
            if this widget does not have focus.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.SendMessage(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.DispatchMode,System.IntPtr,System.IntPtr)">
            <summary>
            Sends a message to this widget.
            </summary>
            <remarks>
            <para>
            You should probably not go around
            simulating the predefined messages that the widgets library defines for
            you. You may however define custom messages for your widgets and send them
            with this method.
            </para>
            <para>
            For each widget that receives the message (see the dispatching modes), each
            widget function from the most recently installed to the oldest one receives
            the message in order until it is handled.
            </para>
            </remarks>
            <param name="standardMessage">The message to send.</param>
            <param name="dispatchMode">The dispatch mode.</param>
            <param name="param1">The first message parameter.</param>
            <param name="param2">The second message parameter.</param>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.SendMessage(System.Int32,XP.SDK.Widgets.DispatchMode,System.IntPtr,System.IntPtr)">
            <summary>
            Sends a message to this widget.
            </summary>
            <remarks>
            <para>
            You should probably not go around
            simulating the predefined messages that the widgets library defines for
            you. You may however define custom messages for your widgets and send them
            with this method.
            </para>
            <para>
            For each widget that receives the message (see the dispatching modes), each
            widget function from the most recently installed to the oldest one receives
            the message in order until it is handled.
            </para>
            </remarks>
            <param name="customMessage">The message to send.</param>
            <param name="dispatchMode">The dispatch mode.</param>
            <param name="param1">The first message parameter.</param>
            <param name="param2">The second message parameter.</param>
            <returns><see langword="true"/> if the message was handled; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.TryGetProperty(XP.SDK.Widgets.WidgetPropertyID,System.IntPtr@)">
            <summary>
            Tries to get the property value.
            </summary>
            <param name="standardProperty">The property ID.</param>
            <param name="value">The property value.</param>
            <returns><see langword="true"/> if the property exists; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.TryGetProperty(System.Int32,System.IntPtr@)">
            <summary>
            Tries to get the property value.
            </summary>
            <param name="customProperty">The property ID.</param>
            <param name="value">The property value.</param>
            <returns><see langword="true"/> if the property exists; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.GetProperty(XP.SDK.Widgets.WidgetPropertyID)">
            <summary>
            Gets the property value.
            </summary>
            <param name="standardProperty">The property ID.</param>
            <returns>The property value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property with the specified ID does not exist.</exception>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.GetProperty(System.Int32)">
            <summary>
            Gets the property value.
            </summary>
            <param name="customProperty">The property ID.</param>
            <returns>The property value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property with the specified ID does not exist.</exception>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.SetProperty(XP.SDK.Widgets.WidgetPropertyID,System.IntPtr)">
            <summary>
            Sets the property value.
            </summary>
            <param name="standardProperty">The property ID.</param>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.SetProperty(System.Int32,System.IntPtr)">
            <summary>
            Sets the property value.
            </summary>
            <param name="customProperty">The property ID.</param>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.AddHook(XP.SDK.Widgets.Interop.WidgetFuncCallback)">
            <summary>
            Adds a widget proc hook.
            </summary>
            <remarks>
            <para>
            This hook supersedes any existing ones and will receive messages first;
            if it does not handle messages they will go on to be handled by pre-existing widgets.
            </para>
            <para>
            The widget function will remain on the widget for the life of the widget.
            The creation message will be sent to the new callback immediately with the
            widget ID, and the destruction message will be sent before the other widget
            function receives a destruction message.
            </para>
            <para>Consider using <see cref="P:XP.SDK.Widgets.Widget.Behaviors"/> which provide higher-lever abstraction for this functionality.</para>
            </remarks>
            <param name="hook">The hook.</param>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.MoveBy(System.Int32,System.Int32)">
            <summary>
            Simply moves a widget by an amount, +x = right, +y=up, without resizing the  widget.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.GetWidgetClassFunction(XP.SDK.Widgets.WidgetClass)">
            <summary>
            Given a widget class, this function returns the callbacks that power that widget class.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Widget.Destroy(System.Boolean)">
            <summary>
            Destroys the widget.
            </summary>
            <param name="destroyChildren">
            <para>If <see langword="true"/>, the widget's children will be destroyed first,
            then this widget will be destroyed. Furthermore, the widget's children
            will be destroyed with the inDestroyChildren flag set to 1, so the
            destruction will recurse down the widget tree.
            </para>
            <para>
            If <see langword="false"/>, the child widgets will simply end up with their parent set to <see langword="null" />. 
            </para>
            </param>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetClass">
            <summary>
            <para>
            Widget classes define predefined widget types. A widget class basically
            specifies from a library the widget function to be used for the widget.
            Most widgets can be made right from classes.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddCreatedHandler``1(``0,XP.SDK.Widgets.WidgetCreatedEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.Create"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddDestroyedHandler``1(``0,XP.SDK.Widgets.WidgetDestroyedEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.Destroy"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddPaintHandler``1(``0,XP.SDK.Widgets.WidgetEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.Paint"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddDrawHandler``1(``0,XP.SDK.Widgets.WidgetEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.Draw"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddKeyPressedHandler``1(``0,XP.SDK.Widgets.WidgetRefEventHandler{XP.SDK.Widgets.Widget,XP.SDK.Widgets.Interop.KeyState})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.KeyPress"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddTakingFocusHandler``1(``0,XP.SDK.Widgets.WidgetTakingFocusEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.KeyTakeFocus"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddLostFocusHandler``1(``0,XP.SDK.Widgets.WidgetLostFocusEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.KeyLoseFocus"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddMouseDownHandler``1(``0,XP.SDK.Widgets.WidgetRefEventHandler{XP.SDK.Widgets.Widget,XP.SDK.Widgets.Interop.MouseState})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.MouseDown"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddMouseUpHandler``1(``0,XP.SDK.Widgets.WidgetRefEventHandler{XP.SDK.Widgets.Widget,XP.SDK.Widgets.Interop.MouseState})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.MouseUp"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddMouseDragHandler``1(``0,XP.SDK.Widgets.WidgetRefEventHandler{XP.SDK.Widgets.Widget,XP.SDK.Widgets.Interop.MouseState})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.MouseDrag"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddMouseWheelHandler``1(``0,XP.SDK.Widgets.WidgetRefEventHandler{XP.SDK.Widgets.Widget,XP.SDK.Widgets.Interop.MouseState})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.MouseWheel"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddReshapeHandler``1(``0,XP.SDK.Widgets.WidgetReshapeEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.Reshape"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddExposedChangedHandler``1(``0,XP.SDK.Widgets.WidgetEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.ExposedChanged"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddChildAddedHandler``1(``0,XP.SDK.Widgets.WidgetValueEventHandler{XP.SDK.Widgets.Widget,XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.AcceptChild"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddChildRemovedHandler``1(``0,XP.SDK.Widgets.WidgetValueEventHandler{XP.SDK.Widgets.Widget,XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.LoseChild"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddParentChangedHandler``1(``0,XP.SDK.Widgets.WidgetValueEventHandler{XP.SDK.Widgets.Widget,XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.AcceptParent"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddShownHandler``1(``0,XP.SDK.Widgets.WidgetValueEventHandler{XP.SDK.Widgets.Widget,XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.Shown"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddHiddenHandler``1(``0,XP.SDK.Widgets.WidgetValueEventHandler{XP.SDK.Widgets.Widget,XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.Hidden"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddDescriptorChangedHandler``1(``0,XP.SDK.Widgets.WidgetEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.DescriptorChanged"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddPropertyChangedHandler``1(``0,XP.SDK.Widgets.WidgetPropertyChangeEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.PropertyChanged"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddCursorAdjustHandler``1(``0,XP.SDK.Widgets.WidgetCursorAdjustEventHandler{XP.SDK.Widgets.Widget})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.CursorAdjust"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddPressedHandler``1(``0,XP.SDK.Widgets.WidgetEventHandler{XP.SDK.Widgets.Button})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.ButtonMessage.PushButtonPressed"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddIsCheckedChangedHandler``1(``0,XP.SDK.Widgets.WidgetValueEventHandler{XP.SDK.Widgets.Button,System.Boolean})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.ButtonMessage.ButtonStateChanged"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddCloseButtonPushedHandler``1(``0,XP.SDK.Widgets.WidgetEventHandler{XP.SDK.Widgets.MainWindow})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.MainWindowMessage.CloseButtonPushed"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddValueChangedHandler``1(``0,XP.SDK.Widgets.WidgetEventHandler{XP.SDK.Widgets.ScrollBar})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.ScrollBarMessage.ScrollBarSliderPositionChanged"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddTextChangedHandler``1(``0,XP.SDK.Widgets.WidgetEventHandler{XP.SDK.Widgets.TextField})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.TextFieldMessage.TextFieldChanged"/> message handler.
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.WidgetExtensions.AddKeyPressedHandler``1(``0,XP.SDK.Widgets.WidgetRefEventHandler{XP.SDK.Widgets.TextField,XP.SDK.Widgets.Interop.KeyState})">
            <summary>
            Adds a <see cref="F:XP.SDK.Widgets.WidgetMessage.KeyPress"/> message handler.
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetID">
            <summary>
            <para>
            A Widget ID is an opaque unique non-zero handle identifying your widget.
            Use 0 to specify "no widget". This type is defined as wide enough to hold a
            pointer. You receive a widget ID when you create a new widget and then use
            that widget ID to further refer to the widget.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetMessage">
            <summary>
            <para>
            Widgets receive 32-bit messages indicating what action is to be taken or
            notifications of events. The list of messages may be expanded.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetPropertyID">
            <summary>
            <para>
            Properties are values attached to instances of your widgets. A property is
            identified by a 32-bit ID and its value is the width of a pointer.
            </para>
            <para>
            Each widget instance may have a property or not have it. When you set a
            property on a widget for the first time, the property is added to the
            widget; it then stays there for the life of the widget.
            </para>
            <para>
            Some property IDs are predefined by the widget package; you can make up
            your own property IDs as well.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.WindowStyle">
            <summary>
            <para>
            There are a few built-in window styles in X-Plane that you can use.
            </para>
            <para>
            Note that X-Plane 6 does not offer real shadow-compositing; you must make
            sure to put a window on top of another window of the right style to the
            shadows work, etc. This applies to elements with insets and shadows. The
            rules are:
            </para>
            <para>
            Sub windows must go on top of main windows, and screens and list views on
            top of subwindows. Only help and main windows can be over the main screen.
            </para>
            <para>
            With X-Plane 7 any window or element may be placed over any other element.
            </para>
            <para>
            Some windows are scaled by stretching, some by repeating. The drawing
            routines know which scaling method to use. The list view cannot be rescaled
            in X-Plane 6 because it has both a repeating pattern and a gradient in one
            element. All other elements can be rescaled.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Camera">
            <summary>
            <para>
            The Camera APIs allow plug-ins to control the camera angle in X-Plane. This has a number of applications, including but not limited to:
            </para>
            <list type="bullet">
            <item>
            <description>Creating new views (including dynamic/user-controllable views) for the user.</description>
            </item>
            <item>
            <description>Creating applications that use X-Plane as a renderer of scenery, aircrafts, or both.</description>
            </item>
            </list>
            </summary>
            <remarks>
            <para>
            The camera is controlled via six parameters: a location in OpenGL coordinates and pitch, roll and yaw, similar to an airplanes position.
            OpenGL coordinate info is described in detail in the XPLMGraphics documentation; generally you should use the XPLMGraphics routines to convert from world to local coordinates.
            The cameras orientation starts facing level with the ground directly up the negative-Z axis (approximately north) with the horizon horizontal.
            It is then rotated clockwise for yaw, pitched up for positive pitch, and rolled clockwise around the vector it is looking along for roll.
            </para>
            <para>
            You control the camera either until the user selects a new view or permanently (the later being similar to how UDP camera control works).
            You control the camera by registering a callback per frame from which you calculate the new camera positions.
            This guarantees smooth camera motion.
            </para>
            <para>
            Use the XPLMDataAccess APIs to get information like the position of the aircraft, etc. for complex camera positioning.
            </para>
            <para>
            Note: if your goal is to move the virtual pilot in the cockpit, this API is not needed; simply update the datarefs for the pilots head position.
            </para>
            <para>
            For custom exterior cameras, set the cameras mode to an external view first to get correct sound and 2-d panel behavior.
            </para>
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.Camera.ControlCamera(XP.SDK.XPLM.CameraControlDuration,XP.SDK.XPLM.Camera.CameraControlAction,System.Action)">
            <summary>
            This function repositions the camera on the next drawing cycle.
            You must pass a non-null <paramref name="controlAction"/>.
            Specify in <paramref name="duration"/> how long youd like control (indefinitely or until a new view mode is set by the user).
            </summary>
            <param name="duration">How long youd like control (indefinitely or until a new view mode is set by the user).</param>
            <param name="controlAction">Camera control action.</param>
            <param name="onLoosingControl">Callback called before loosing control.</param>
            <returns>Camera controller.</returns>
        </member>
        <member name="P:XP.SDK.XPLM.Camera.IsBeingControlled">
            <summary>
            Gets the value indicating whether the camera is being controlled.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.Camera.CurrentControlDuration">
            <summary>
            Gets the current <see cref="T:XP.SDK.XPLM.CameraControlDuration"/> if the camera is being controlled; <see langword="null"/> otherwise.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Camera.ReadCurrentPosition(XP.SDK.XPLM.Interop.CameraPosition@)">
            <summary>
            Reads the current camera position.
            </summary>
            <param name="position">The current camera position</param>
            <seealso cref="M:XP.SDK.XPLM.Camera.GetCurrentPosition"/>
        </member>
        <member name="M:XP.SDK.XPLM.Camera.GetCurrentPosition">
            <summary>
            Get the current camera position.
            </summary>
            <remarks>
            For better performance consider using <see cref="M:XP.SDK.XPLM.Camera.ReadCurrentPosition(XP.SDK.XPLM.Interop.CameraPosition@)" /> function.
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.Camera.Controller.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:XP.SDK.XPLM.Camera.CameraControlAction">
            <summary>
            You use an CameraControlAction delegate to provide continuous control over the camera.
            You are passed in a structure in which to put the new camera position;
            modify it and return <see langword="true"/> to reposition the camera.
            Return <see langword="false"/> to surrender control of the camera; camera control will be handled by X-Plane on this draw loop.
            The contents of the structure as you are called are undefined.
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CameraControlDuration">
            <summary>
            <para>
            This enumeration states how long you want to retain control of the camera.
            You can retain it indefinitely or until the user selects a new view.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Command">
            <summary>
            The command management APIs let plugins interact with the command-system in X-Plane, the abstraction behind keyboard presses and joystick buttons.
            This API lets you create new commands and modify the behavior (or get notification) of existing ones.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.Command.CommandRef">
            <summary>
            Gets the command reference.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Command.Find(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Looks up a command by name.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Command.Create(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Creates a new command for a given string.
            If the command already exists, the existing command reference is returned.
            The description may appear in user interface contexts, such as the joystick configuration screen.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Command.Once">
            <summary>
            This executes a given command momentarily, that is, the command begins and ends immediately.
            This is the equivalent of calling <see cref="M:XP.SDK.XPLM.Command.Begin"/> and <see cref="M:XP.SDK.XPLM.Command.End"/> back ot back.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Command.Begin">
            <summary>
            <para>Starts the execution of a command.</para>
            <para>The command is "held down" until <see cref="M:XP.SDK.XPLM.Command.End"/> is called.</para>
            <para>You must balance each <see cref="M:XP.SDK.XPLM.Command.Begin"/> call with an <see cref="M:XP.SDK.XPLM.Command.End"/> call.</para> 
            </summary>
            <seealso cref="M:XP.SDK.XPLM.Command.BeginScope"/>
            <seealso cref="M:XP.SDK.XPLM.Command.BeginScopeAllocationFree"/>
        </member>
        <member name="M:XP.SDK.XPLM.Command.End">
            <summary>
            <para>Ends the execution of a given command that was started with <see cref="M:XP.SDK.XPLM.Command.Begin"/>.</para>
            <para>You must not issue XPLMCommandEnd for a command you did not begin.</para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Command.BeginScope">
            <summary>
            <para>Starts the execution of a command.</para>
            <para>The command is "held down" until the <see cref="M:System.IDisposable.Dispose"/> of the returned object is called.</para>
            </summary>
            <seealso cref="M:XP.SDK.XPLM.Command.BeginScopeAllocationFree"/>
        </member>
        <member name="M:XP.SDK.XPLM.Command.BeginScopeAllocationFree">
            <summary>
            <para>Starts the execution of a command.</para>
            <para>The command is "held down" until the <see cref="M:XP.SDK.XPLM.CommandExecutionScope.Dispose"/> of the returned object is called.</para>
            </summary>
            <seealso cref="M:XP.SDK.XPLM.Command.BeginScope"/>
        </member>
        <member name="E:XP.SDK.XPLM.Command.BeforeExecute">
            <summary>
            Raised before X-Plane executes the command.
            </summary>
            <remarks>
            Set <see cref="F:XP.SDK.XPLM.CommandBeforeExecuteEventArgs.Handled"/> to <see langword="true"/>
            to prevent the command from being handled by X-Plane and other plugins.
            </remarks>
        </member>
        <member name="E:XP.SDK.XPLM.Command.AfterExecute">
            <summary>
            Raised after X-Plane has executed the command.
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CommandButtonID">
            <summary>
            <para>
            These are enumerations for all of the things you can do with a joystick
            button in X-Plane. They currently match the buttons menu in the equipment
            setup dialog, but these enums will be stable even if they change in
            X-Plane.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CommandExecutionScope">
            <summary>
            Begins the command after construction and ends it on disposal.
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CommandKeyID">
            <summary>
            <para>
            These enums represent all the keystrokes available within X-Plane. They can
            be sent to X-Plane directly. For example, you can reverse thrust using
            these enumerations.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CommandPhase">
            <summary>
            <para>
            The phases of a command.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CommandRef">
            <summary>
            <para>
            A command ref is an opaque identifier for an X-Plane command. Command
            references stay the same for the life of your plugin but not between
            executions of X-Plane. Command refs are used to execute commands, create
            commands, and create callbacks for particular commands.
            </para>
            <para>
            Note that a command is not "owned" by a particular plugin. Since many
            plugins may participate in a command's execution, the command does not go
            away if the plugin that created it is unloaded.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.CommandRef.Find(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Looks up a command by name, and returns its command
            reference or <see langword="default"/> if the command does not exist.
            </summary>
            <param name="name">The command name.</param>
        </member>
        <member name="T:XP.SDK.XPLM.CursorStatus">
            <summary>
            <para>
            XPLMCursorStatus describes how you would like X-Plane to manage the cursor.
            See XPLMHandleCursor_f for more info.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.DataFileType">
            <summary>
            <para>
            These enums define types of data files you can load or unload using the
            SDK.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.DataRef">
            <summary>
            <para>
            A data ref is an opaque handle to data provided by the simulator or another
            plugin. It uniquely identifies one variable (or array of variables) over
            the lifetime of your plugin. You never hard code these values; you always
            get them from XPLMFindDataRef.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.DataTypeID">
            <summary>
            <para>
            This is an enumeration that defines the type of the data behind a data
            reference. This allows you to sanity check that the data type matches what
            you expect. But for the most part, you will know the type of data you are
            expecting from the online documentation.
            </para>
            <para>
            Data types each take a bit field; it is legal to have a single dataref be
            more than one type of data.  Whe this happens, you can pick any matching
            get/set API.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.DrawingPhase">
            <summary>
            <para>
            This constant indicates which part of drawing we are in.  Drawing is done
            from the back to the front.  We get a callback before or after each item.
            Metaphases provide access to the beginning and end of the 3d (scene) and
            2d (cockpit) drawing in a manner that is independent of new phases added
            via X-Plane implementation.
            </para>
            <para>
            **NOTE**: As of XPLM302 the legacy 3D drawing phases (xplm_Phase_FirstScene
            to xplm_Phase_LastScene) are deprecated. When running under X-Plane 11.50
            with the modern Vulkan or Metal backend, X-Plane will no longer call
            these drawing phases. There is a new drawing phase, xplm_Phase_Modern3D,
            which is supported under OpenGL and Vulkan which is called out roughly
            where the old before xplm_Phase_Airplanes phase was for blending. This
            phase is *NOT* supported under Metal and comes with potentially
            substantial performance overhead. Please do *NOT* opt into this phase if
            you don't do any actual drawing that requires the depth buffer in some
            way!
            </para>
            <para>
            **WARNING**: As X-Plane's scenery evolves, some drawing phases may cease to
            exist and new ones may be invented.  If you need a particularly specific
            use of these codes, consult Austin and/or be prepared to revise your code
            as X-Plane evolves.
            </para>
            </summary>
        </member>
        <member name="F:XP.SDK.XPLM.Features.WantsReflections">
            <summary>
            Available in the SDK 2.0 and later for X-Plane 9, enabling this capability causes your plugin
            to receive drawing hook callbacks when X-Plane builds its off-screen reflection and shadow rendering passes.
            Plugins should enable this and examine the dataref sim/graphics/view/plane_render_type
            to determine whether the drawing callback is for a reflection, shadow calculation, or the main screen.
            Rendering can be simplified or omitted for reflections, and non-solid drawing should be skipped for shadow calculations.
            </summary>
        </member>
        <member name="F:XP.SDK.XPLM.Features.UseNativePaths">
            <summary>
            Modifies the plugin system to use Unix-style paths on all operating systems. Enabled by default.
            </summary>
        </member>
        <member name="F:XP.SDK.XPLM.Features.UseNativeWidgetWindows">
            <summary>
            <para>
            This capability tells the widgets library to use new, modern X-Plane windows to anchor all widget trees. Without it, widgets will always use legacy windows.
            </para>
            <para>
            Plugins should enable this to allow their widget hierarchies to respond to the users UI size settings and to map widget-based windwos to a VR HMD.
            </para>
            <para>
            Before enabling this, make sure any custom widget code in your plugin is prepared to cope with the UI coordinate system not being th same as the OpenGL window coordinate system.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.FlightLoopID">
            <summary>
            <para>
            This is an opaque identifier for a flight loop callback. You can use this
            identifier to easily track and remove your callbacks, or to use the new
            flight loop APIs.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.FlightLoopPhaseType">
            <summary>
            <para>
            You can register a flight loop callback to run either before or after the
            flight model is integrated by X-Plane.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.FontID">
            <summary>
            <para>
            X-Plane features some fixed-character fonts.  Each font may have its own
            metrics.
            </para>
            <para>
            WARNING: Some of these fonts are no longer supported or may have changed
            geometries. For maximum copmatibility, see the comments below.
            </para>
            <para>
            Note: X-Plane 7 supports proportional-spaced fonts.  Since no measuring
            routine is available yet, the SDK will normally draw using a fixed-width
            font.  You can use a dataref to enable proportional font drawing on XP7 if
            you want to.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.SetGraphicsState(System.Boolean,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Changes OpenGLs fixed function pipeline state.
            You are not responsible for restoring any state that is accessed via SetGraphicsState,
            but you are responsible for not accessing this state directly.
            </summary>
            <param name="enableFog">Enables or disables fog, equivalent to: glEnable(GL_FOG).</param>
            <param name="numberTexUnits">
            Enables or disables a number of multitexturing units.
            If the number is 0, 2d texturing is disabled entirely, as in glDisable(GL_TEXTURE_2D);
            Otherwise, 2d texturing is enabled, and a number of multitexturing units are enabled sequentially,
            starting with unit 0, e.g. glActiveTextureARB(GL_TEXTURE0_ARB); glEnable (GL_TEXTURE_2D).
            </param>
            <param name="enableLighting">Enables or disables OpenGL lighting, e.g. glEnable(GL_LIGHTING); glEnable(GL_LIGHT0).</param>
            <param name="enableAlphaTesting">Enables or disables the alpha test per pixel, e.g. glEnable(GL_ALPHA_TEST).</param>
            <param name="enableAlphaBlending">Enables or disables alpha blending per pixel, e.g. glEnable(GL_BLEND).</param>
            <param name="enableDepthTesting">Enables per pixel depth testing, as in glEnable(GL_DEPTH_TEST).</param>
            <param name="enableDepthWriting">Enables writing back of depth information to the depth bufffer, as in glDepthMask(GL_TRUE).</param>
            <remarks>
            <para>
            The purpose of this function is to change OpenGL state while keeping
            X-Plane aware of the state changes; this keeps X-Plane from getting
            surprised by OGL state changes, and prevents X-Plane and plug-ins from
            having to set all state before all draws; SetGraphicsState internally
            skips calls to change state that is already properly enabled.
            </para>
            <para>
            X-Plane does not have a 'default' OGL state to plug-ins; plug-ins should
            totally set OGL state before drawing.  Use SetGraphicsState instead of
            any of the above OpenGL calls.
            </para>
            <para>
            WARNING: Any routine that performs drawing (e.g. DrawString or widget
            code) may change X-Plane's state.  Always set state before drawing after
            unknown code has executed.
            </para>
            <para>
            Deprecation Warnings: X-Planes lighting and fog environment is significantly more complex than the fixed function pipeline can express;
            do not assume that lighting and fog state is a good approximation for 3-d drawing.
            Prefer to use XPLMInstancing to draw objects.
            All calls to SetGraphicsState should have no fog or lighting.
            </para>
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.SetGraphicsState(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Changes OpenGLs fixed function pipeline state.
            You are not responsible for restoring any state that is accessed via SetGraphicsState,
            but you are responsible for not accessing this state directly.
            </summary>
            <param name="numberTexUnits">
            Enables or disables a number of multitexturing units.
            If the number is 0, 2d texturing is disabled entirely, as in glDisable(GL_TEXTURE_2D);
            Otherwise, 2d texturing is enabled, and a number of multitexturing units are enabled sequentially,
            starting with unit 0, e.g. glActiveTextureARB(GL_TEXTURE0_ARB); glEnable (GL_TEXTURE_2D).
            </param>
            <param name="enableAlphaTesting">Enables or disables the alpha test per pixel, e.g. glEnable(GL_ALPHA_TEST).</param>
            <param name="enableAlphaBlending">Enables or disables alpha blending per pixel, e.g. glEnable(GL_BLEND).</param>
            <param name="enableDepthTesting">Enables per pixel depth testing, as in glEnable(GL_DEPTH_TEST).</param>
            <param name="enableDepthWriting">Enables writing back of depth information to the depth bufffer, as in glDepthMask(GL_TRUE).</param>
            <remarks>
            <para>
            The purpose of this function is to change OpenGL state while keeping
            X-Plane aware of the state changes; this keeps X-Plane from getting
            surprised by OGL state changes, and prevents X-Plane and plug-ins from
            having to set all state before all draws; SetGraphicsState internally
            skips calls to change state that is already properly enabled.
            </para>
            <para>
            X-Plane does not have a 'default' OGL state to plug-ins; plug-ins should
            totally set OGL state before drawing.  Use SetGraphicsState instead of
            any of the above OpenGL calls.
            </para>
            <para>
            WARNING: Any routine that performs drawing (e.g. DrawString or widget
            code) may change X-Plane's state.  Always set state before drawing after
            unknown code has executed.
            </para>
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.BindTexture2d(System.Int32,System.Int32)">
            <summary>
            Changes what texture is bound to the 2d texturing target.
            This routine caches the current 2d texture across all texturing units in the sim and plug-ins, preventing extraneous binding.
            For example, consider several plug-ins running in series;
            if they all use the general interface bitmap to do UI,
            calling this function will skip the rebinding of the general interface texture on all but the first plug-in,
            which can provide better frame rate son some graphics cards.
            </summary>
            <param name="textureId">ID of the texture object to bind.</param>
            <param name="textureUnit">
            A zero-based texture unit (e.g. 0 for the first one), up to a maximum of 4 units.
            (This number may increase in future versions of X-Plane.)
            </param>
            <remarks>
            Use this routine instead of glBindTexture(GL_TEXTURE_2D, .).
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.GenerateTextureNumbers(System.Span{System.Int32}@)">
            <summary>
            Use this routine instead of glGenTextures to generate new texture object IDs.
            This routine historically ensured that plugins dont use texure IDs that X-Plane is reserving for its own use.
            </summary>
            <param name="textureIds"></param>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.WorldToLocal(System.Double,System.Double,System.Double)">
            <summary>
            Translates coordinates from latitude, longitude, and altitude to local scene coordinates.
            Latitude and longitude are in decimal degrees, and altitude is in meters MSL (mean sea level).
            The XYZ coordinates are in meters in the local OpenGL coordinate system.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.LocalToWorld(System.Double,System.Double,System.Double)">
            <summary>
            This routine translates a local coordinate triplet back into latitude, longitude, and altitude.
            Latitude and longitude are in decimal degrees, and altitude is in meters MSL (mean sea level).
            The XYZ coordinates are in meters in the local OpenGL coordinate system.
            </summary>
            <remarks>
            NOTE: world coordinates are less precise than local coordinates; you should try to avoid round tripping from local to world and back.
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.DrawTranslucentDarkBox(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a translucent dark box, partially obscuring parts of the screen but making text easy to read.
            This is the same graphics primitive used by X-Plane to show text files and ATC info.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.DrawString(XP.SDK.RGBColor@,System.Int32,System.Int32,System.ReadOnlySpan{System.Char}@,System.Int32@,XP.SDK.XPLM.FontID)">
            <summary>
            This routine draws a NULL terminated string in a given font.
            Pass in the lower left pixel that the character is to be drawn onto.
            Also pass the character and font ID.
            This function returns the x offset plus the width of all drawn characters.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.DrawString(XP.SDK.RGBColor@,System.Int32,System.Int32,System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.FontID)">
            <summary>
            This routine draws a NULL terminated string in a given font.
            Pass in the lower left pixel that the character is to be drawn onto.
            Also pass the character and font ID.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.DrawNumber(XP.SDK.RGBColor@,System.Int32,System.Int32,System.Double,System.Int32,System.Int32,System.Boolean,XP.SDK.XPLM.FontID)">
            <summary>
            This routine draws a number similar to the digit editing fields in PlaneMaker and data output display in X-Plane.
            Pass in a color, a position, a floating point value, and formatting info.
            Specify how many integer and how many decimal digits to show and whether to show a sign, as well as a character set.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.GetFontDimensions(XP.SDK.XPLM.FontID)">
            <summary>
            This routine returns the width and height of a character in a given font. It also tells you if the font only supports numeric digits. 
            </summary>
            <remarks>
            For a proportional font the width will be an arbitrary, hopefully average width.
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.MeasureString(XP.SDK.XPLM.FontID,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Returns the width in pixels of a string using a given font.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Graphics.MeasureString(XP.SDK.XPLM.FontID,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Returns the width in pixels of a UTF8 string using a given font.
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.HostApplicationID">
            <summary>
            <para>
            While the plug-in SDK is only accessible to plugins running inside X-Plane,
            the original authors considered extending the API to other applications
            that shared basic infrastructure with X-Plane. These enumerations are
            hold-overs from that original roadmap; all values other than X-Plane are
            deprecated. Your plugin should never need this enumeration.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.HotKey.SetHotKeyCombination(XP.SDK.XPLM.HotKeyID,System.Byte,XP.SDK.XPLM.KeyFlags)">
            <summary>
            Remaps a hot keys keystrokes. You may remap another plugin's keystrokes.
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.HotKeyID">
            <summary>
            <para>
            An opaque ID used to identify a hot key.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.InstanceRef">
            <summary>
            <para>
            An opaque handle to an instance.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.CameraAPI.ControlCamera(XP.SDK.XPLM.CameraControlDuration,,System.Void*)">
            <summary>
            <para>
            This function repositions the camera on the next drawing cycle. You must
            pass a non-null control function. Specify in inHowLong how long you'd like
            control (indefinitely or until a new view mode is set by the user).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.CameraAPI.DontControlCamera">
            <summary>
            <para>
            This function stops you from controlling the camera. If you have a camera
            control function, it will not be called with an inIsLosingControl flag.
            X-Plane will control the camera on the next cycle.
            </para>
            <para>
            For maximum compatibility you should not use this routine unless you are in
            posession of the camera.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.CameraAPI.IsCameraBeingControlled(XP.SDK.XPLM.CameraControlDuration*)">
            <summary>
            <para>
            This routine returns 1 if the camera is being controlled, zero if it is
            not. If it is and you pass in a pointer to a camera control duration, the
            current control duration will be returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.CameraAPI.ReadCameraPosition(XP.SDK.XPLM.Interop.CameraPosition*)">
            <summary>
            <para>
            This function reads the current camera position.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.CameraControlCallback">
            <summary>
            <para>
            You use an XPLMCameraControl function to provide continuous control over
            the camera. You are passed in a structure in which to put the new camera
            position; modify it and return 1 to reposition the camera. Return 0 to
            surrender control of the camera; camera control will be handled by X-Plane
            on this draw loop. The contents of the structure as you are called are
            undefined.
            </para>
            <para>
            If X-Plane is taking camera control away from you, this function will be
            called with inIsLosingControl set to 1 and ioCameraPosition NULL.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.CameraPosition">
            <summary>
            <para>
            This structure contains a full specification of the camera. X, Y, and Z are
            the camera's position in OpenGL coordiantes; pitch, roll, and yaw are
            rotations from a camera facing flat north in degrees. Positive pitch means
            nose up, positive roll means roll right, and positive yaw means yaw right,
            all in degrees. Zoom is a zoom factor, with 1.0 meaning normal zoom and 2.0
            magnifying by 2x (objects appear larger).
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.CommandCallback">
            <summary>
            <para>
            A command callback is a function in your plugin that is called when a
            command is pressed. Your callback receives the command reference for the
            particular command, the phase of the command that is executing, and a
            reference pointer that you specify when registering the callback.
            </para>
            <para>
            Your command handler should return 1 to let processing of the command
            continue to other plugins and X-Plane, or 0 to halt processing, potentially
            bypassing X-Plane code.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.CreateFlightLoop">
            <summary>
            <para>
            XPLMCreateFlightLoop_t contains the parameters to create a new flight loop
            callback. The strsucture can be expanded in future SDKs - always set
            structSize to the size of your structure in bytes.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.CreateMapLayer">
            <summary>
            <para>
            This structure defines all of the parameters used to create a map layer
            using XPLMCreateMapLayer. The structure will be expanded in future SDK APIs
            to include more features.  Always set the structSize member to the size of
            your struct in bytes!
            </para>
            <para>
            Each layer must be associated with exactly one map instance in X-Plane.
            That map, and that map alone, will call your callbacks. Likewise, when that
            map is deleted, your layer will be as well.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.CreateWindow">
            <summary>
            <para>
            The XPMCreateWindow_t structure defines all of the parameters used to
            create a modern window using XPLMCreateWindowEx().  The structure will be
            expanded in future SDK APIs to include more features.  Always set the
            structSize member to the size of your struct in bytes!
            </para>
            <para>
            All windows created by this function in the XPLM300 version of the API are
            created with the new X-Plane 11 GUI features. This means your plugin will
            get to "know" about the existence of X-Plane windows other than the main
            window. All drawing and mouse callbacks for your window will occur in
            "boxels," giving your windows automatic support for high-DPI scaling in
            X-Plane. In addition, your windows can opt-in to decoration with the
            X-Plane 11 window styling, and you can use the
            XPLMSetWindowPositioningMode() API to make your window "popped out" into a
            first-class operating system window.
            </para>
            <para>
            Note that this requires dealing with your window's bounds in "global
            desktop" positioning units, rather than the traditional panel coordinate
            system. In global desktop coordinates, the main X-Plane window may not have
            its origin at coordinate (0, 0), and your own window may have negative
            coordinates. Assuming you don't implicitly assume (0, 0) as your origin,
            the only API change you should need is to start using
            XPLMGetMouseLocationGlobal() rather than XPLMGetMouseLocation(), and
            XPLMGetScreenBoundsGlobal() instead of XPLMGetScreenSize().
            </para>
            <para>
            If you ask to be decorated as a floating window, you'll get the blue window
            control bar and blue backing that you see in X-Plane 11's normal "floating"
            windows (like the map).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.FindDataRef(System.Byte*)">
            <summary>
            <para>
            Given a c-style string that names the data ref, this routine looks up the
            actual opaque XPLMDataRef that you use to read and write the data. The
            string names for datarefs are published on the X-Plane SDK web site.
            </para>
            <para>
            This function returns NULL if the data ref cannot be found.
            </para>
            <para>
            NOTE: this function is relatively expensive; save the XPLMDataRef this
            function returns for future use. Do not look up your data ref by string
            every time you need to read or write it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.FindDataRef(XP.SDK.Utf8String@)">
            <summary>
            <para>
            Given a c-style string that names the data ref, this routine looks up the
            actual opaque XPLMDataRef that you use to read and write the data. The
            string names for datarefs are published on the X-Plane SDK web site.
            </para>
            <para>
            This function returns NULL if the data ref cannot be found.
            </para>
            <para>
            NOTE: this function is relatively expensive; save the XPLMDataRef this
            function returns for future use. Do not look up your data ref by string
            every time you need to read or write it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.FindDataRef(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Given a c-style string that names the data ref, this routine looks up the
            actual opaque XPLMDataRef that you use to read and write the data. The
            string names for datarefs are published on the X-Plane SDK web site.
            </para>
            <para>
            This function returns NULL if the data ref cannot be found.
            </para>
            <para>
            NOTE: this function is relatively expensive; save the XPLMDataRef this
            function returns for future use. Do not look up your data ref by string
            every time you need to read or write it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.CanWriteDataRef(XP.SDK.XPLM.DataRef)">
            <summary>
            <para>
            Given a data ref, this routine returns true if you can successfully set the
            data, false otherwise. Some datarefs are read-only.
            </para>
            <para>
            NOTE: even if a dataref is marked writable, it may not act writable.  This
            can happen for datarefs that X-Plane writes to on every frame of
            simulation.  In some cases, the dataref is writable but you have to set a
            separate "override" dataref to 1 to stop X-Plane from writing it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.IsDataRefGood(XP.SDK.XPLM.DataRef)">
            <summary>
            <para>
            This function returns true if the passed in handle is a valid dataref that
            is not orphaned.
            </para>
            <para>
            Note: there is normally no need to call this function; datarefs returned by
            XPLMFindDataRef remain valid (but possibly orphaned) unless there is a
            complete plugin reload (in which case your plugin is reloaded anyway).
            Orphaned datarefs can be safely read and return 0. Therefore you never need
            to call XPLMIsDataRefGood to 'check' the safety of a dataref.
            (XPLMIsDatarefGood performs some slow checking of the handle validity, so
            it has a perormance cost.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.GetDataRefTypes(XP.SDK.XPLM.DataRef)">
            <summary>
            <para>
            This routine returns the types of the data ref for accessor use. If a data
            ref is available in multiple data types, the bit-wise OR of these types
            will be returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.GetDatai(XP.SDK.XPLM.DataRef)">
            <summary>
            <para>
            Read an integer data ref and return its value. The return value is the
            dataref value or 0 if the dataref is NULL or the plugin is disabled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.SetDatai(XP.SDK.XPLM.DataRef,System.Int32)">
            <summary>
            <para>
            Write a new value to an integer data ref. This routine is a no-op if the
            plugin publishing the dataref is disabled, the dataref is NULL, or the
            dataref is not writable.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.GetDataf(XP.SDK.XPLM.DataRef)">
            <summary>
            <para>
            Read a single precision floating point dataref and return its value. The
            return value is the dataref value or 0.0 if the dataref is NULL or the
            plugin is disabled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.SetDataf(XP.SDK.XPLM.DataRef,System.Single)">
            <summary>
            <para>
            Write a new value to a single precision floating point data ref. This
            routine is a no-op if the plugin publishing the dataref is disabled, the
            dataref is NULL, or the dataref is not writable.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.GetDatad(XP.SDK.XPLM.DataRef)">
            <summary>
            <para>
            Read a double precision floating point dataref and return its value. The
            return value is the dataref value or 0.0 if the dataref is NULL or the
            plugin is disabled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.SetDatad(XP.SDK.XPLM.DataRef,System.Double)">
            <summary>
            <para>
            Write a new value to a double precision floating point data ref. This
            routine is a no-op if the plugin publishing the dataref is disabled, the
            dataref is NULL, or the dataref is not writable.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.GetDatavi(XP.SDK.XPLM.DataRef,System.Int32*,System.Int32,System.Int32)">
            <summary>
            <para>
            Read a part of an integer array dataref. If you pass NULL for outValues,
            the routine will return the size of the array, ignoring inOffset and inMax.
            </para>
            <para>
            If outValues is not NULL, then up to inMax values are copied from the
            dataref into outValues, starting at inOffset in the dataref. If inMax +
            inOffset is larger than the size of the dataref, less than inMax values
            will be copied. The number of values copied is returned.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.SetDatavi(XP.SDK.XPLM.DataRef,System.Int32*,System.Int32,System.Int32)">
            <summary>
            <para>
            Write part or all of an integer array dataref. The values passed by
            inValues are written into the dataref starting at inOffset. Up to inCount
            values are written; however if the values would write "off the end" of the
            dataref array, then fewer values are written.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.GetDatavf(XP.SDK.XPLM.DataRef,System.Single*,System.Int32,System.Int32)">
            <summary>
            <para>
            Read a part of a single precision floating point array dataref. If you pass
            NULL for outVaules, the routine will return the size of the array, ignoring
            inOffset and inMax.
            </para>
            <para>
            If outValues is not NULL, then up to inMax values are copied from the
            dataref into outValues, starting at inOffset in the dataref. If inMax +
            inOffset is larger than the size of the dataref, less than inMax values
            will be copied. The number of values copied is returned.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.SetDatavf(XP.SDK.XPLM.DataRef,System.Single*,System.Int32,System.Int32)">
            <summary>
            <para>
            Write part or all of a single precision floating point array dataref. The
            values passed by inValues are written into the dataref starting at
            inOffset. Up to inCount values are written; however if the values would
            write "off the end" of the dataref array, then fewer values are written.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.GetDatab(XP.SDK.XPLM.DataRef,System.Void*,System.Int32,System.Int32)">
            <summary>
            <para>
            Read a part of a byte array dataref. If you pass NULL for outVaules, the
            routine will return the size of the array, ignoring inOffset and inMax.
            </para>
            <para>
            If outValues is not NULL, then up to inMax values are copied from the
            dataref into outValues, starting at inOffset in the dataref. If inMax +
            inOffset is larger than the size of the dataref, less than inMax values
            will be copied. The number of values copied is returned.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.SetDatab(XP.SDK.XPLM.DataRef,System.Void*,System.Int32,System.Int32)">
            <summary>
            <para>
            Write part or all of a byte array dataref. The values passed by inValues
            are written into the dataref starting at inOffset. Up to inCount values are
            written; however if the values would write "off the end" of the dataref
            array, then fewer values are written.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.RegisterDataAccessor(System.Byte*,XP.SDK.XPLM.DataTypeID,System.Int32,,,,,,,,,,,,,System.Void*,System.Void*)">
            <summary>
            <para>
            This routine creates a new item of data that can be read and written. Pass
            in the data's full name for searching, the type(s) of the data for
            accessing, and whether the data can be written to. For each data type you
            support, pass in a read accessor function and a write accessor function if
            necessary. Pass NULL for data types you do not support or write accessors
            if you are read-only.
            </para>
            <para>
            You are returned a data ref for the new item of data created. You can use
            this data ref to unregister your data later or read or write from it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.RegisterDataAccessor(XP.SDK.Utf8String@,XP.SDK.XPLM.DataTypeID,System.Int32,,,,,,,,,,,,,System.Void*,System.Void*)">
            <summary>
            <para>
            This routine creates a new item of data that can be read and written. Pass
            in the data's full name for searching, the type(s) of the data for
            accessing, and whether the data can be written to. For each data type you
            support, pass in a read accessor function and a write accessor function if
            necessary. Pass NULL for data types you do not support or write accessors
            if you are read-only.
            </para>
            <para>
            You are returned a data ref for the new item of data created. You can use
            this data ref to unregister your data later or read or write from it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.RegisterDataAccessor(System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.DataTypeID,System.Int32,,,,,,,,,,,,,System.Void*,System.Void*)">
            <summary>
            <para>
            This routine creates a new item of data that can be read and written. Pass
            in the data's full name for searching, the type(s) of the data for
            accessing, and whether the data can be written to. For each data type you
            support, pass in a read accessor function and a write accessor function if
            necessary. Pass NULL for data types you do not support or write accessors
            if you are read-only.
            </para>
            <para>
            You are returned a data ref for the new item of data created. You can use
            this data ref to unregister your data later or read or write from it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.UnregisterDataAccessor(XP.SDK.XPLM.DataRef)">
            <summary>
            <para>
            Use this routine to unregister any data accessors you may have registered.
            You unregister a data ref by the XPLMDataRef you get back from
            registration. Once you unregister a data ref, your function pointer will
            not be called anymore.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.ShareData(System.Byte*,XP.SDK.XPLM.DataTypeID,,System.Void*)">
            <summary>
            <para>
            This routine connects a plug-in to shared data, creating the shared data if
            necessary. inDataName is a standard path for the data ref, and inDataType
            specifies the type. This function will create the data if it does not
            exist. If the data already exists but the type does not match, an error is
            returned, so it is important that plug-in authors collaborate to establish
            public standards for shared data.
            </para>
            <para>
            If a notificationFunc is passed in and is not NULL, that notification
            function will be called whenever the data is modified. The notification
            refcon will be passed to it. This allows your plug-in to know which shared
            data was changed if multiple shared data are handled by one callback, or if
            the plug-in does not use global variables.
            </para>
            <para>
            A one is returned for successfully creating or finding the shared data; a
            zero if the data already exists but is of the wrong type.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.ShareData(XP.SDK.Utf8String@,XP.SDK.XPLM.DataTypeID,,System.Void*)">
            <summary>
            <para>
            This routine connects a plug-in to shared data, creating the shared data if
            necessary. inDataName is a standard path for the data ref, and inDataType
            specifies the type. This function will create the data if it does not
            exist. If the data already exists but the type does not match, an error is
            returned, so it is important that plug-in authors collaborate to establish
            public standards for shared data.
            </para>
            <para>
            If a notificationFunc is passed in and is not NULL, that notification
            function will be called whenever the data is modified. The notification
            refcon will be passed to it. This allows your plug-in to know which shared
            data was changed if multiple shared data are handled by one callback, or if
            the plug-in does not use global variables.
            </para>
            <para>
            A one is returned for successfully creating or finding the shared data; a
            zero if the data already exists but is of the wrong type.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.ShareData(System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.DataTypeID,,System.Void*)">
            <summary>
            <para>
            This routine connects a plug-in to shared data, creating the shared data if
            necessary. inDataName is a standard path for the data ref, and inDataType
            specifies the type. This function will create the data if it does not
            exist. If the data already exists but the type does not match, an error is
            returned, so it is important that plug-in authors collaborate to establish
            public standards for shared data.
            </para>
            <para>
            If a notificationFunc is passed in and is not NULL, that notification
            function will be called whenever the data is modified. The notification
            refcon will be passed to it. This allows your plug-in to know which shared
            data was changed if multiple shared data are handled by one callback, or if
            the plug-in does not use global variables.
            </para>
            <para>
            A one is returned for successfully creating or finding the shared data; a
            zero if the data already exists but is of the wrong type.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.UnshareData(System.Byte*,XP.SDK.XPLM.DataTypeID,,System.Void*)">
            <summary>
            <para>
            This routine removes your notification function for shared data. Call it
            when done with the data to stop receiving change notifications. Arguments
            must match XPLMShareData. The actual memory will not necessarily be freed,
            since other plug-ins could be using it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.UnshareData(XP.SDK.Utf8String@,XP.SDK.XPLM.DataTypeID,,System.Void*)">
            <summary>
            <para>
            This routine removes your notification function for shared data. Call it
            when done with the data to stop receiving change notifications. Arguments
            must match XPLMShareData. The actual memory will not necessarily be freed,
            since other plug-ins could be using it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DataAccessAPI.UnshareData(System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.DataTypeID,,System.Void*)">
            <summary>
            <para>
            This routine removes your notification function for shared data. Call it
            when done with the data to stop receiving change notifications. Arguments
            must match XPLMShareData. The actual memory will not necessarily be freed,
            since other plug-ins could be using it.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.DataChangedCallback">
            <summary>
            <para>
            An XPLMDataChanged_f is a callback that the XPLM calls whenever any other
            plug-in modifies shared data. A refcon you provide is passed back to help
            identify which data is being changed. In response, you may want to call one
            of the XPLMGetDataxxx routines to find the new value of the data.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.RegisterDrawCallback(,XP.SDK.XPLM.DrawingPhase,System.Int32,System.Void*)">
            <summary>
            <para>
            This routine registers a low level drawing callback.  Pass in the phase you
            want to be called for and whether you want to be called before or after.
            This routine returns 1 if the registration was successful, or 0 if the
            phase does not exist in this version of X-Plane.  You may register a
            callback multiple times for the same or different phases as long as the
            refcon is unique each time.
            </para>
            <para>
            Note that this function will likely be removed during the X-Plane 11 run as
            part of the transition to Vulkan/Metal/etc. See the XPLMInstance API for
            future-proof drawing of 3-D objects.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.UnregisterDrawCallback(,XP.SDK.XPLM.DrawingPhase,System.Int32,System.Void*)">
            <summary>
            <para>
            This routine unregisters a draw callback.  You must unregister a callback
            for each time you register a callback if you have registered it multiple
            times with different refcons.  The routine returns 1 if it can find the
            callback to unregister, 0 otherwise.
            </para>
            <para>
            Note that this function will likely be removed during the X-Plane 11 run as
            part of the transition to Vulkan/Metal/etc. See the XPLMInstance API for
            future-proof drawing of 3-D objects.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.CreateWindowEx(XP.SDK.XPLM.Interop.CreateWindow*)">
            <summary>
            <para>
            This routine creates a new "modern" window. You pass in an
            XPLMCreateWindow_t structure with all of the fields set in.  You must set
            the structSize of the structure to the size of the actual structure you
            used.  Also, you must provide functions for every callback---you may not
            leave them null!  (If you do not support the cursor or mouse wheel, use
            functions that return the default values.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.CreateWindow(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,,,,System.Void*)">
            <summary>
            <para>
            Deprecated as of XPLM300.
            </para>
            <para>
            This routine creates a new legacy window. Unlike modern windows (created
            via XPLMCreateWindowEx()), legacy windows do not have access to X-Plane 11
            features like automatic scaling for high-DPI screens, native window styles,
            or support for being "popped out" into first-class operating system
            windows.
            </para>
            <para>
            Pass in the dimensions and offsets to the window's bottom left corner from
            the bottom left of the screen.  You can specify whether the window is
            initially visible or not.  Also, you pass in three callbacks to run the
            window and a refcon.  This function returns a window ID you can use to
            refer to the new window.
            </para>
            <para>
            NOTE: Legacy windows do not have "frames"; you are responsible for drawing
            the background and frame of the window.  Higher level libraries have
            routines which make this easy.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.DestroyWindow(XP.SDK.XPLM.WindowID)">
            <summary>
            <para>
            This routine destroys a window.  The window's callbacks are not called
            after this call. Keyboard focus is removed from the window before
            destroying it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetScreenSize(System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the size of the main X-Plane OpenGL window in pixels.
            This number can be used to get a rough idea of the amount of detail the
            user will be able to see when drawing in 3-d.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetScreenBoundsGlobal(System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the bounds of the "global" X-Plane desktop, in boxels.
            Unlike the non-global version XPLMGetScreenSize(), this is multi-monitor
            aware. There are three primary consequences of multimonitor awareness.
            </para>
            <para>
            First, if the user is running X-Plane in full-screen on two or more
            monitors (typically configured using one full-screen window per monitor),
            the global desktop will be sized to include all X-Plane windows.
            </para>
            <para>
            Second, the origin of the screen coordinates is not guaranteed to be (0,
            0). Suppose the user has two displays side-by-side, both running at 1080p.
            Suppose further that they've configured their OS to make the left display
            their "primary" monitor, and that X-Plane is running in full-screen on
            their right monitor only. In this case, the global desktop bounds would be
            the rectangle from (1920, 0) to (3840, 1080). If the user later asked
            X-Plane to draw on their primary monitor as well, the bounds would change
            to (0, 0) to (3840, 1080).
            </para>
            <para>
            Finally, if the usable area of the virtual desktop is not a perfect
            rectangle (for instance, because the monitors have different resolutions or
            because one monitor is configured in the operating system to be above and
            to the right of the other), the global desktop will include any wasted
            space. Thus, if you have two 1080p monitors, and monitor 2 is configured to
            have its bottom left touch monitor 1's upper right, your global desktop
            area would be the rectangle from (0, 0) to (3840, 2160).
            </para>
            <para>
            Note that popped-out windows (windows drawn in their own operating system
            windows, rather than "floating" within X-Plane) are not included in these
            bounds.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetAllMonitorBoundsGlobal(,System.Void*)">
            <summary>
            <para>
            This routine immediately calls you back with the bounds (in boxels) of each
            full-screen X-Plane window within the X-Plane global desktop space. Note
            that if a monitor is *not* covered by an X-Plane window, you cannot get its
            bounds this way. Likewise, monitors with only an X-Plane window (not in
            full-screen mode) will not be included.
            </para>
            <para>
            If X-Plane is running in full-screen and your monitors are of the same size
            and configured contiguously in the OS, then the combined global bounds of
            all full-screen monitors will match the total global desktop bounds, as
            returned by XPLMGetScreenBoundsGlobal(). (Of course, if X-Plane is running
            in windowed mode, this will not be the case. Likewise, if you have
            differently sized monitors, the global desktop space will include wasted
            space.)
            </para>
            <para>
            Note that this function's monitor indices match those provided by
            XPLMGetAllMonitorBoundsOS(), but the coordinates are different (since the
            X-Plane global desktop may not match the operating system's global desktop,
            and one X-Plane boxel may be larger than one pixel due to 150% or 200%
            scaling).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetAllMonitorBoundsOS(,System.Void*)">
            <summary>
            <para>
            This routine immediately calls you back with the bounds (in pixels) of each
            monitor within the operating system's global desktop space. Note that
            unlike XPLMGetAllMonitorBoundsGlobal(), this may include monitors that have
            no X-Plane window on them.
            </para>
            <para>
            Note that this function's monitor indices match those provided by
            XPLMGetAllMonitorBoundsGlobal(), but the coordinates are different (since
            the X-Plane global desktop may not match the operating system's global
            desktop, and one X-Plane boxel may be larger than one pixel).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetMouseLocation(System.Int32*,System.Int32*)">
            <summary>
            <para>
            Deprecated in XPLM300. Modern windows should use
            XPLMGetMouseLocationGlobal() instead.
            </para>
            <para>
            This routine returns the current mouse location in pixels relative to the
            main X-Plane window. The bottom left corner of the main window is (0, 0).
            Pass NULL to not receive info about either parameter.
            </para>
            <para>
            Because this function gives the mouse position relative to the main X-Plane
            window (rather than in global bounds), this function should only be used by
            legacy windows. Modern windows should instead get the mouse position in
            global desktop coordinates using XPLMGetMouseLocationGlobal().
            </para>
            <para>
            Note that unlike XPLMGetMouseLocationGlobal(), if the mouse goes outside
            the user's main monitor (for instance, to a pop out window or a secondary
            monitor), this function will not reflect it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetMouseLocationGlobal(System.Int32*,System.Int32*)">
            <summary>
            <para>
            Returns the current mouse location in global desktop boxels. Unlike
            XPLMGetMouseLocation(), the bottom left of the main X-Plane window is not
            guaranteed to be (0, 0)---instead, the origin is the lower left of the
            entire global desktop space. In addition, this routine gives the real mouse
            location when the mouse goes to X-Plane windows other than the primary
            display. Thus, it can be used with both pop-out windows and secondary
            monitors.
            </para>
            <para>
            This is the mouse location function to use with modern windows (i.e., those
            created by XPLMCreateWindowEx()).
            </para>
            <para>
            Pass NULL to not receive info about either parameter.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetWindowGeometry(XP.SDK.XPLM.WindowID,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the position and size of a window. The units and
            coordinate system vary depending on the type of window you have.
            </para>
            <para>
            If this is a legacy window (one compiled against a pre-XPLM300 version of
            the SDK, or an XPLM300 window that was not created using
            XPLMCreateWindowEx()), the units are pixels relative to the main X-Plane
            display.
            </para>
            <para>
            If, on the other hand, this is a new X-Plane 11-style window (compiled
            against the XPLM300 SDK and created using XPLMCreateWindowEx()), the units
            are global desktop boxels.
            </para>
            <para>
            Pass NULL to not receive any paramter.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowGeometry(XP.SDK.XPLM.WindowID,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            This routine allows you to set the position and size of a window.
            </para>
            <para>
            The units and coordinate system match those of XPLMGetWindowGeometry().
            That is, modern windows use global desktop boxel coordinates, while legacy
            windows use pixels relative to the main X-Plane display.
            </para>
            <para>
            Note that this only applies to "floating" windows (that is, windows that
            are drawn within the X-Plane simulation windows, rather than being "popped
            out" into their own first-class operating system windows). To set the
            position of windows whose positioning mode is xplm_WindowPopOut, you'll
            need to instead use XPLMSetWindowGeometryOS().
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetWindowGeometryOS(XP.SDK.XPLM.WindowID,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the position and size of a "popped out" window (i.e.,
            a window whose positioning mode is xplm_WindowPopOut), in operating system
            pixels.  Pass NULL to not receive any parameter.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowGeometryOS(XP.SDK.XPLM.WindowID,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            This routine allows you to set the position and size, in operating system
            pixel coordinates, of a popped out window (that is, a window whose
            positioning mode is xplm_WindowPopOut, which exists outside the X-Plane
            simulation window, in its own first-class operating system window).
            </para>
            <para>
            Note that you are responsible for ensuring both that your window is popped
            out (using XPLMWindowIsPoppedOut()) and that a monitor really exists at the
            OS coordinates you provide (using XPLMGetAllMonitorBoundsOS()).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetWindowGeometryVR(XP.SDK.XPLM.WindowID,System.Int32*,System.Int32*)">
            <summary>
            <para>
            Returns the width and height, in boxels, of a window in VR. Note that you
            are responsible for ensuring your window is in VR (using
            XPLMWindowIsInVR()).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowGeometryVR(XP.SDK.XPLM.WindowID,System.Int32,System.Int32)">
            <summary>
            <para>
            This routine allows you to set the size, in boxels, of a window in VR (that
            is, a window whose positioning mode is xplm_WindowVR).
            </para>
            <para>
            Note that you are responsible for ensuring your window is in VR (using
            XPLMWindowIsInVR()).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetWindowIsVisible(XP.SDK.XPLM.WindowID)">
            <summary>
            <para>
            Returns true (1) if the specified window is visible.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowIsVisible(XP.SDK.XPLM.WindowID,System.Int32)">
            <summary>
            <para>
            This routine shows or hides a window.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.WindowIsPoppedOut(XP.SDK.XPLM.WindowID)">
            <summary>
            <para>
            True if this window has been popped out (making it a first-class window in
            the operating system), which in turn is true if and only if you have set
            the window's positioning mode to xplm_WindowPopOut.
            </para>
            <para>
            Only applies to modern windows. (Windows created using the deprecated
            XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of
            the SDK cannot be popped out.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.WindowIsInVR(XP.SDK.XPLM.WindowID)">
            <summary>
            <para>
            True if this window has been moved to the virtual reality (VR) headset,
            which in turn is true if and only if you have set the window's positioning
            mode to xplm_WindowVR.
            </para>
            <para>
            Only applies to modern windows. (Windows created using the deprecated
            XPLMCreateWindow(), or windows compiled against a pre-XPLM301 version of
            the SDK cannot be moved to VR.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowGravity(XP.SDK.XPLM.WindowID,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>
            A window's "gravity" controls how the window shifts as the whole X-Plane
            window resizes. A gravity of 1 means the window maintains its positioning
            relative to the right or top edges, 0 the left/bottom, and 0.5 keeps it
            centered.
            </para>
            <para>
            Default gravity is (0, 1, 0, 1), meaning your window will maintain its
            position relative to the top left and will not change size as its
            containing window grows.
            </para>
            <para>
            If you wanted, say, a window that sticks to the top of the screen (with a
            constant height), but which grows to take the full width of the window, you
            would pass (0, 1, 1, 1). Because your left and right edges would maintain
            their positioning relative to their respective edges of the screen, the
            whole width of your window would change with the X-Plane window.
            </para>
            <para>
            Only applies to modern windows. (Windows created using the deprecated
            XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of
            the SDK will simply get the default gravity.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowResizingLimits(XP.SDK.XPLM.WindowID,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Sets the minimum and maximum size of the client rectangle of the given
            window. (That is, it does not include any window styling that you might
            have asked X-Plane to apply on your behalf.) All resizing operations are
            constrained to these sizes.
            </para>
            <para>
            Only applies to modern windows. (Windows created using the deprecated
            XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of
            the SDK will have no minimum or maximum size.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowPositioningMode(XP.SDK.XPLM.WindowID,XP.SDK.XPLM.WindowPositioningMode,System.Int32)">
            <summary>
            <para>
            Sets the policy for how X-Plane will position your window.
            </para>
            <para>
            Some positioning modes apply to a particular monitor. For those modes, you
            can pass a negative monitor index to position the window on the main
            X-Plane monitor (the screen with the X-Plane menu bar at the top). Or, if
            you have a specific monitor you want to position your window on, you can
            pass a real monitor index as received from, e.g.,
            XPLMGetAllMonitorBoundsOS().
            </para>
            <para>
            Only applies to modern windows. (Windows created using the deprecated
            XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of
            the SDK will always use xplm_WindowPositionFree.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowTitle(XP.SDK.XPLM.WindowID,System.Byte*)">
            <summary>
            <para>
            Sets the name for a window. This only applies to windows that opted-in to
            styling as an X-Plane 11 floating window (i.e., with styling mode
            xplm_WindowDecorationRoundRectangle) when they were created using
            XPLMCreateWindowEx().
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowTitle(XP.SDK.XPLM.WindowID,XP.SDK.Utf8String@)">
            <summary>
            <para>
            Sets the name for a window. This only applies to windows that opted-in to
            styling as an X-Plane 11 floating window (i.e., with styling mode
            xplm_WindowDecorationRoundRectangle) when they were created using
            XPLMCreateWindowEx().
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowTitle(XP.SDK.XPLM.WindowID,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Sets the name for a window. This only applies to windows that opted-in to
            styling as an X-Plane 11 floating window (i.e., with styling mode
            xplm_WindowDecorationRoundRectangle) when they were created using
            XPLMCreateWindowEx().
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetWindowRefCon(XP.SDK.XPLM.WindowID)">
            <summary>
            <para>
            Returns a window's reference constant, the unique value you can use for
            your own purposes.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetWindowRefCon(XP.SDK.XPLM.WindowID,System.Void*)">
            <summary>
            <para>
            Sets a window's reference constant.  Use this to pass data to yourself in
            the callbacks.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.TakeKeyboardFocus(XP.SDK.XPLM.WindowID)">
            <summary>
            <para>
            This routine gives a specific window keyboard focus.  Keystrokes will be
            sent to that window.  Pass a window ID of 0 to remove keyboard focus from
            any plugin-created windows and instead pass keyboard strokes directly to
            X-Plane.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.HasKeyboardFocus(XP.SDK.XPLM.WindowID)">
            <summary>
            <para>
            Returns true (1) if the indicated window has keyboard focus. Pass a window
            ID of 0 to see if no plugin window has focus, and all keystrokes will go
            directly to X-Plane.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.BringWindowToFront(XP.SDK.XPLM.WindowID)">
            <summary>
            <para>
            This routine brings the window to the front of the Z-order for its layer.
            Windows are brought to the front automatically when they are created.
            Beyond that, you should make sure you are front before handling mouse
            clicks.
            </para>
            <para>
            Note that this only brings your window to the front of its layer
            (XPLMWindowLayer). Thus, if you have a window in the floating window layer
            (xplm_WindowLayerFloatingWindows), but there is a modal window (in layer
            xplm_WindowLayerModal) above you, you would still not be the true frontmost
            window after calling this. (After all, the window layers are strictly
            ordered, and no window in a lower layer can ever be above any window in a
            higher one.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.IsWindowInFront(XP.SDK.XPLM.WindowID)">
            <summary>
            <para>
            This routine returns true if the window you passed in is the frontmost
            visible window in its layer (XPLMWindowLayer).
            </para>
            <para>
            Thus, if you have a window at the front of the floating window layer
            (xplm_WindowLayerFloatingWindows), this will return true even if there is a
            modal window (in layer xplm_WindowLayerModal) above you. (Not to worry,
            though: in such a case, X-Plane will not pass clicks or keyboard input down
            to your layer until the window above stops "eating" the input.)
            </para>
            <para>
            Note that legacy windows are always placed in layer
            xplm_WindowLayerFlightOverlay, while modern-style windows default to
            xplm_WindowLayerFloatingWindows. This means it's perfectly consistent to
            have two different plugin-created windows (one legacy, one modern) *both*
            be in the front (of their different layers!) at the same time.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.RegisterKeySniffer(,System.Int32,System.Void*)">
            <summary>
            <para>
            This routine registers a key sniffing callback.  You specify whether you
            want to sniff before the window system, or only sniff keys the window
            system does not consume.  You should ALMOST ALWAYS sniff non-control keys
            after the window system.  When the window system consumes a key, it is
            because the user has "focused" a window.  Consuming the key or taking
            action based on the key will produce very weird results.  Returns
            1 if successful.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.UnregisterKeySniffer(,System.Int32,System.Void*)">
            <summary>
            <para>
            This routine unregisters a key sniffer.  You must unregister a key sniffer
            for every time you register one with the exact same signature.  Returns 1
            if successful.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.RegisterHotKey(System.Byte,XP.SDK.XPLM.KeyFlags,System.Byte*,,System.Void*)">
            <summary>
            <para>
            This routine registers a hot key.  You specify your preferred key stroke
            virtual key/flag combination, a description of what your callback does (so
            other plug-ins can describe the plug-in to the user for remapping) and a
            callback function and opaque pointer to pass in).  A new hot key ID is
            returned.  During execution, the actual key associated with your hot key
            may change, but you are insulated from this.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.RegisterHotKey(System.Byte,XP.SDK.XPLM.KeyFlags,XP.SDK.Utf8String@,,System.Void*)">
            <summary>
            <para>
            This routine registers a hot key.  You specify your preferred key stroke
            virtual key/flag combination, a description of what your callback does (so
            other plug-ins can describe the plug-in to the user for remapping) and a
            callback function and opaque pointer to pass in).  A new hot key ID is
            returned.  During execution, the actual key associated with your hot key
            may change, but you are insulated from this.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.RegisterHotKey(System.Byte,XP.SDK.XPLM.KeyFlags,System.ReadOnlySpan{System.Char}@,,System.Void*)">
            <summary>
            <para>
            This routine registers a hot key.  You specify your preferred key stroke
            virtual key/flag combination, a description of what your callback does (so
            other plug-ins can describe the plug-in to the user for remapping) and a
            callback function and opaque pointer to pass in).  A new hot key ID is
            returned.  During execution, the actual key associated with your hot key
            may change, but you are insulated from this.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.UnregisterHotKey(XP.SDK.XPLM.HotKeyID)">
            <summary>
            <para>
            Unregisters a hot key.  You can only unregister your own hot keys.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.CountHotKeys">
            <summary>
            <para>
            Returns the number of current hot keys.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetNthHotKey(System.Int32)">
            <summary>
            <para>
            Returns a hot key by index, for iteration on all hot keys.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.GetHotKeyInfo(XP.SDK.XPLM.HotKeyID,System.Byte*,XP.SDK.XPLM.KeyFlags*,System.Byte*,XP.SDK.XPLM.PluginID*)">
            <summary>
            <para>
            Returns information about the hot key.  Return NULL for any parameter you
            don't want info about.  The description should be at least 512 chars long.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.DisplayAPI.SetHotKeyCombination(XP.SDK.XPLM.HotKeyID,System.Byte,XP.SDK.XPLM.KeyFlags)">
            <summary>
            <para>
            Remaps a hot key's keystrokes.  You may remap another plugin's keystrokes.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.DrawCallback">
            <summary>
            <para>
            This is the prototype for a low level drawing callback.  You are passed in
            the phase and whether it is before or after.  If you are before the phase,
            return 1 to let X-Plane draw or 0 to suppress X-Plane drawing.  If you are
            after the phase the return value is ignored.
            </para>
            <para>
            Refcon is a unique value that you specify when registering the callback,
            allowing you to slip a pointer to your own data to the callback.
            </para>
            <para>
            Upon entry the OpenGL context will be correctly set up for you and OpenGL
            will be in 'local' coordinates for 3d drawing and panel coordinates for 2d
            drawing.  The OpenGL state (texturing, etc.) will be unknown.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.DrawInfo">
            <summary>
            <para>
            The XPLMDrawInfo_t structure contains positioning info for one object that
            is to be drawn. Be sure to set structSize to the size of the structure for
            future expansion.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.DrawWindowCallback">
            <summary>
            <para>
            A callback to handle 2-D drawing of your window.  You are passed in your
            window and its refcon. Draw the window.  You can use other XPLM functions
            from this header to find the current dimensions of your window, etc.  When
            this callback is called, the OpenGL context will be set properly for 2-D
            window drawing.
            </para>
            <para>
            **Note**: Because you are drawing your window over a background, you can
            make a translucent window easily by simply not filling in your entire
            window's bounds.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.ErrorCallback">
            <summary>
            <para>
            An XPLM error callback is a function that you provide to receive debugging
            information from the plugin SDK. See XPLMSetErrorCallback for more
            information. NOTE: for the sake of debugging, your error callback will be
            called even if your plugin is not enabled, allowing you to receive debug
            info in your XPluginStart and XPluginStop callbacks. To avoid causing logic
            errors in the management code, do not call any other plugin routines from
            your error callback - it is only meant for catching errors in the
            debugging.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.FeatureEnumeratorCallback">
            <summary>
            <para>
            You pass an XPLMFeatureEnumerator_f to get a list of all features supported
            by a given version running version of X-Plane.  This routine is called once
            for each feature.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.FlightLoopCallback">
            <summary>
            <para>
            This is your flight loop callback. Each time the flight loop is iterated
            through, you receive this call at the end.
            </para>
            <para>
            Flight loop callbacks receive a number of input timing parameters. These
            input timing parameters are not particularly useful; you may need to track
            your own timing data (e.g. by reading datarefs). The input parameters are:
            </para>
            <para>
            - inElapsedSinceLastCall: the wall time since your last callback.
            - inElapsedTimeSinceLastFlightLoop: the wall time since any flight loop was
            dispatched.
            - inCounter: a monotonically increasing counter, bumped once per flight
            loop dispatch from the sim.
            - inRefcon: your own ptr constant from when you regitered yor callback.
            </para>
            <para>
            Your return value controls when you will next be called.
            </para>
            <para>
            - Return 0 to stop receiving callbacks.
            - Pass a positive number to specify how many seconds until the next
            callback. (You will be called at or after this time, not before.)
            - Pass a negative number to specify how many loops must go by until you
            are called. For example, -1.0 means call me the very next loop.
            </para>
            <para>
            Try to run your flight loop as infrequently as is practical, and suspend it
            (using return value 0) when you do not need it; lots of flight loop
            callbacks that do nothing lowers X-Plane's frame rate.
            </para>
            <para>
            Your callback will NOT be unregistered if you return 0; it will merely be
            inactive.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.GetDatabCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.GetDatadCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.GetDatafCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.GetDataiCallback">
            <summary>
            <para>
            Data provider function pointers.
            </para>
            <para>
            These define the function pointers you provide to get or set data. Note
            that you are passed a generic pointer for each one. This is the same
            pointer you pass in your register routine; you can use it to locate plugin
            variables, etc.
            </para>
            <para>
            The semantics of your callbacks are the same as the dataref accessor above
            - basically routines like XPLMGetDatai are just pass-throughs from a caller
            to your plugin. Be particularly mindful in implementing array dataref
            read-write accessors; you are responsible for avoiding overruns, supporting
            offset read/writes, and handling a read with a NULL buffer.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.GetDatavfCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.GetDataviCallback">
            <summary>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.DrawString(XP.SDK.RGBColor@,System.Int32,System.Int32,XP.SDK.Utf8String@,System.Int32*,XP.SDK.XPLM.FontID)">
            <summary>
            <para>
            This routine draws a NULL terminated string in a given font.  Pass in the
            lower left pixel that the character is to be drawn onto.  Also pass the
            character and font ID. This function returns the x offset plus the width of
            all drawn characters. 
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.DrawString(XP.SDK.RGBColor@,System.Int32,System.Int32,System.ReadOnlySpan{System.Char}@,System.Int32*,XP.SDK.XPLM.FontID)">
            <summary>
            <para>
            This routine draws a NULL terminated string in a given font.  Pass in the
            lower left pixel that the character is to be drawn onto.  Also pass the
            character and font ID. This function returns the x offset plus the width of
            all drawn characters. 
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.SetGraphicsState(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            XPLMSetGraphicsState changes OpenGL's fixed function pipeline state.  You
            are not responsible for restoring any state that is accessed via
            XPLMSetGraphicsState, but you are responsible for not accessing this state
            directly.
            </para>
            <para>
            - inEnableFog - enables or disables fog, equivalent to: glEnable(GL_FOG);
            - inNumberTexUnits - enables or disables a number of multitexturing units.
            If the number is 0, 2d texturing is disabled entirely, as in
            glDisable(GL_TEXTURE_2D);  Otherwise, 2d texturing is enabled, and a
            number of multitexturing units are enabled sequentially, starting with
            unit 0, e.g. glActiveTextureARB(GL_TEXTURE0_ARB); glEnable
            (GL_TEXTURE_2D);
            - inEnableLighting - enables or disables OpenGL lighting, e.g.
            glEnable(GL_LIGHTING); glEnable(GL_LIGHT0);
            - inEnableAlphaTesting - enables or disables the alpha test per pixel, e.g.
            glEnable(GL_ALPHA_TEST);
            - inEnableAlphaBlending - enables or disables alpha blending per pixel,
            e.g. glEnable(GL_BLEND);
            - inEnableDepthTesting - enables per pixel depth testing, as in
            glEnable(GL_DEPTH_TEST);
            - inEnableDepthWriting - enables writing back of depth information to the
            depth bufffer, as in glDepthMask(GL_TRUE);
            </para>
            <para>
            The purpose of this function is to change OpenGL state while keeping
            X-Plane aware of the state changes; this keeps X-Plane from getting
            surprised by OGL state changes, and prevents X-Plane and plug-ins from
            having to set all state before all draws; XPLMSetGraphicsState internally
            skips calls to change state that is already properly enabled.
            </para>
            <para>
            X-Plane does not have a 'default' OGL state for plug-ins with respect to
            the above state vector; plug-ins should totally set OGL state using this
            API before drawing.  Use XPLMSetGraphicsState instead of any of the above
            OpenGL calls.
            </para>
            <para>
            WARNING: Any routine that performs drawing (e.g. XPLMDrawString or widget
            code) may change X-Plane's state.  Always set state before drawing after
            unknown code has executed.
            </para>
            <para>
            *Deprecation Warnings*: X-Plane's lighting and fog environemnt is
            significantly more complex than the fixed function pipeline can express;
            do not assume that lighting and fog state is a good approximation for 3-d
            drawing.  Prefer to use XPLMInstancing to draw objects.  All calls to
            XPLMSetGraphicsState should have no fog or lighting.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.BindTexture2d(System.Int32,System.Int32)">
            <summary>
            <para>
            XPLMBindTexture2d changes what texture is bound to the 2d texturing
            target. This routine caches the current 2d texture across all texturing
            units in the sim and plug-ins, preventing extraneous binding.  For
            example, consider several plug-ins running in series; if they all use the
            'general interface' bitmap to do UI, calling this function will skip the
            rebinding of the general interface texture on all but the first plug-in,
            which can provide better frame rate son some graphics cards.
            </para>
            <para>
            inTextureID is the ID of the texture object to bind; inTextureUnit is a
            zero-based texture unit (e.g. 0 for the first one), up to a maximum of 4
            units.  (This number may increase in future versions of X-Plane.)
            </para>
            <para>
            Use this routine instead of glBindTexture(GL_TEXTURE_2D, ....);
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.GenerateTextureNumbers(System.Int32*,System.Int32)">
            <summary>
            <para>
            Use this routine instead of glGenTextures to generate new texture object
            IDs. This routine historically ensured that plugins don't use texure IDs
            that X-Plane is reserving for its own use.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.WorldToLocal(System.Double,System.Double,System.Double,System.Double*,System.Double*,System.Double*)">
            <summary>
            <para>
            This routine translates coordinates from latitude, longitude, and altitude
            to local scene coordinates. Latitude and longitude are in decimal degrees,
            and altitude is in meters MSL (mean sea level).  The XYZ coordinates are in
            meters in the local OpenGL coordinate system.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.LocalToWorld(System.Double,System.Double,System.Double,System.Double*,System.Double*,System.Double*)">
            <summary>
            <para>
            This routine translates a local coordinate triplet back into latitude,
            longitude, and altitude.  Latitude and longitude are in decimal degrees,
            and altitude is in meters MSL (mean sea level).  The XYZ coordinates are in
            meters in the local OpenGL coordinate system.
            </para>
            <para>
            NOTE: world coordinates are less precise than local coordinates; you should
            try to avoid round tripping from local to world and back.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.DrawTranslucentDarkBox(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            This routine draws a translucent dark box, partially obscuring parts of the
            screen but making text easy to read.  This is the same graphics primitive
            used by X-Plane to show text files and ATC info.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.DrawString(System.Single*,System.Int32,System.Int32,System.Byte*,System.Int32*,XP.SDK.XPLM.FontID)">
            <summary>
            <para>
            This routine draws a NULL termianted string in a given font.  Pass in the
            lower left pixel that the character is to be drawn onto.  Also pass the
            character and font ID. This function returns the x offset plus the width of
            all drawn characters. The color to draw in is specified as a pointer to an
            array of three floating point colors, representing RGB intensities from 0.0
            to 1.0.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.DrawNumber(System.Single*,System.Int32,System.Int32,System.Double,System.Int32,System.Int32,System.Int32,XP.SDK.XPLM.FontID)">
            <summary>
            <para>
            This routine draws a number similar to the digit editing fields in
            PlaneMaker and data output display in X-Plane.  Pass in a color, a
            position, a floating point value, and formatting info.  Specify how many
            integer and how many decimal digits to show and whether to show a sign, as
            well as a character set. This routine returns the xOffset plus width of the
            string drawn.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.GetFontDimensions(XP.SDK.XPLM.FontID,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the width and height of a character in a given font.
            It also tells you if the font only supports numeric digits.  Pass NULL if
            you don't need a given field.  Note that for a proportional font the width
            will be an arbitrary, hopefully average width.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.MeasureString(XP.SDK.XPLM.FontID,System.Byte*,System.Int32)">
            <summary>
            <para>
            This routine returns the width in pixels of a string using a given font.
            The string is passed as a pointer plus length (and does not need to be null
            terminated); this is used to allow for measuring substrings. The return
            value is floating point; it is possible that future font drawing may allow
            for fractional pixels.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.MeasureString(XP.SDK.XPLM.FontID,XP.SDK.Utf8String@,System.Int32)">
            <summary>
            <para>
            This routine returns the width in pixels of a string using a given font.
            The string is passed as a pointer plus length (and does not need to be null
            terminated); this is used to allow for measuring substrings. The return
            value is floating point; it is possible that future font drawing may allow
            for fractional pixels.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.GraphicsAPI.MeasureString(XP.SDK.XPLM.FontID,System.ReadOnlySpan{System.Char}@,System.Int32)">
            <summary>
            <para>
            This routine returns the width in pixels of a string using a given font.
            The string is passed as a pointer plus length (and does not need to be null
            terminated); this is used to allow for measuring substrings. The return
            value is floating point; it is possible that future font drawing may allow
            for fractional pixels.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.HandleCursorCallback">
            <summary>
            <para>
            The SDK calls your cursor status callback when the mouse is over your
            plugin window.  Return a cursor status code to indicate how you would like
            X-Plane to manage the cursor.  If you return xplm_CursorDefault, the SDK
            will try lower-Z-order plugin windows, then let the sim manage the cursor.
            </para>
            <para>
            Note: you should never show or hide the cursor yourself---these APIs are
            typically reference-counted and thus cannot safely and predictably be used
            by the SDK.  Instead return one of xplm_CursorHidden to hide the cursor or
            xplm_CursorArrow/xplm_CursorCustom to show the cursor.
            </para>
            <para>
            If you want to implement a custom cursor by drawing a cursor in OpenGL, use
            xplm_CursorHidden to hide the OS cursor and draw the cursor using a 2-d
            drawing callback (after xplm_Phase_Window is probably a good choice, but
            see deprecation warnings on the drawing APIs!).  If you want to use a
            custom OS-based cursor, use xplm_CursorCustom to ask X-Plane to show the
            cursor but not affect its image.  You can then use an OS specific call like
            SetThemeCursor (Mac) or SetCursor/LoadCursor (Windows).
            </para>
            <para>
            The units for x and y values match the units used in your window. Thus, for
            "modern" windows (those created via XPLMCreateWindowEx() and compiled
            against the XPLM300 library), the units are boxels, while legacy windows
            will get pixels. Legacy windows have their origin in the lower left of the
            main X-Plane window, while modern windows have their origin in the lower
            left of the global desktop space. In both cases, x increases as you move
            right, and y increases as you move up.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.HandleKeyCallback">
            <summary>
            <para>
            This function is called when a key is pressed or keyboard focus is taken
            away from your window.  If losingFocus is 1, you are losing the keyboard
            focus, otherwise a key was pressed and inKey contains its character.  You
            are also passed your window and a refcon.
            </para>
            <para>
            Warning: this API declares virtual keys as a signed character; however the
            VKEY #define macros in XPLMDefs.h define the vkeys using unsigned values
            (that is 0x80 instead of -0x80).  So you may need to cast the incoming vkey
            to an unsigned char to get correct comparisons in C.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.HandleMouseClickCallback">
            <summary>
            <para>
            You receive this call for one of three events:
            </para>
            <para>
            - when the user clicks the mouse button down
            - (optionally) when the user drags the mouse after a down-click, but before
            the up-click
            - when the user releases the down-clicked mouse button.
            </para>
            <para>
            You receive the x and y of the click, your window, and a refcon.  Return 1
            to consume the click, or 0 to pass it through.
            </para>
            <para>
            WARNING: passing clicks through windows (as of this writing) causes mouse
            tracking problems in X-Plane; do not use this feature!
            </para>
            <para>
            The units for x and y values match the units used in your window. Thus, for
            "modern" windows (those created via XPLMCreateWindowEx() and compiled
            against the XPLM300 library), the units are boxels, while legacy windows
            will get pixels. Legacy windows have their origin in the lower left of the
            main X-Plane window, while modern windows have their origin in the lower
            left of the global desktop space. In both cases, x increases as you move
            right, and y increases as you move up.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.HandleMouseWheelCallback">
            <summary>
            <para>
            The SDK calls your mouse wheel callback when one of the mouse wheels is
            scrolled within your window.  Return 1 to consume the mouse wheel movement
            or 0 to pass them on to a lower window.  (If your window appears opaque to
            the user, you should consume mouse wheel scrolling even if it does
            nothing.)  The number of "clicks" indicates how far the wheel was turned
            since the last callback. The wheel is 0 for the vertical axis or 1 for the
            horizontal axis (for OS/mouse combinations that support this).
            </para>
            <para>
            The units for x and y values match the units used in your window. Thus, for
            "modern" windows (those created via XPLMCreateWindowEx() and compiled
            against the XPLM300 library), the units are boxels, while legacy windows
            will get pixels. Legacy windows have their origin in the lower left of the
            main X-Plane window, while modern windows have their origin in the lower
            left of the global desktop space. In both cases, x increases as you move
            right, and y increases as you move up.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.HotKeyCallback">
            <summary>
            <para>
            Your hot key callback simply takes a pointer of your choosing.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.InstanceAPI.CreateInstance(XP.SDK.XPLM.ObjectRef,System.Byte**)">
            <summary>
            <para>
            XPLMCreateInstance creates a new instance, managed by your plug-in, and
            returns a handle to the instance. A few important requirements:
            </para>
            <para>
            * The object passed in must be fully loaded and returned from the XPLM
            before you can create your instance; you cannot pass a null obj ref, nor
            can you change the ref later.
            </para>
            <para>
            * If you use any custom datarefs in your object, they must be registered
            before the object is loaded. This is true even if their data will be
            provided via the instance dataref list.
            </para>
            <para>
            * The instance dataref array must be a valid ptr to an array of at least
            one item that is null terminated.  That is, if you do not want any
            datarefs, you must passa ptr to an array with a null item.  You cannot
            pass null for this.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.InstanceAPI.DestroyInstance(XP.SDK.XPLM.InstanceRef)">
            <summary>
            <para>
            XPLMDestroyInstance destroys and deallocates your instance; once called,
            you are still responsible for releasing the OBJ ref.
            </para>
            <para>
            Tip: you can release your OBJ ref after you call XPLMCreateInstance as long
            as you never use it again; the instance will maintain its own reference to
            the OBJ and the object OBJ be deallocated when the instance is destroyed.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.InstanceAPI.InstanceSetPosition(XP.SDK.XPLM.InstanceRef,XP.SDK.XPLM.Interop.DrawInfo*,System.Single*)">
            <summary>
            <para>
            Updates both the position of the instance and all datarefs you registered
            for it.  Call this from a flight loop callback or UI callback.
            </para>
            <para>
            __DO NOT__ call XPLMInstanceSetPosition from a drawing callback; the whole
            point of instancing is that you do not need any drawing callbacks. Setting
            instance data from a drawing callback may have undefined consequences, and
            the drawing callback hurts FPS unnecessarily.
            </para>
            <para>
            The memory pointed to by the data pointer must be large enough to hold one
            float for every data ref you have registered, and must contain valid
            floating point data.
            </para>
            <para>
            BUG: before X-Plane 11.50, if you have no dataref registered, you must
            still pass a valid pointer for data and not null.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.KeySnifferCallback">
            <summary>
            <para>
            This is the prototype for a low level key-sniffing function.  Window-based
            UI _should not use this_!  The windowing system provides high-level
            mediated keyboard access, via the callbacks you attach to your
            XPLMCreateWindow_t. By comparison, the key sniffer provides low level
            keyboard access.
            </para>
            <para>
            Key sniffers are provided to allow libraries to provide non-windowed user
            interaction.  For example, the MUI library uses a key sniffer to do pop-up
            text entry.
            </para>
            <para>
            Return 1 to pass the key on to the next sniffer, the window manager,
            X-Plane, or whomever is down stream.  Return 0 to consume the key.
            </para>
            <para>
            Warning: this API declares virtual keys as a signed character; however the
            VKEY #define macros in XPLMDefs.h define the vkeys using unsigned values
            (that is 0x80 instead of -0x80).  So you may need to cast the incoming vkey
            to an unsigned char to get correct comparisons in C.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.LibraryEnumeratorCallback">
            <summary>
            <para>
            An XPLMLibraryEnumerator_f is a callback you provide that is called once
            for each library element that is located. The returned paths will be
            relative to the X-System folder.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.CreateMapLayer(XP.SDK.XPLM.Interop.CreateMapLayer*)">
            <summary>
            <para>
            This routine creates a new map layer. You pass in an XPLMCreateMapLayer_t
            structure with all of the fields set in.  You must set the structSize of
            the structure to the size of the actual structure you used.
            </para>
            <para>
            Returns NULL if the layer creation failed. This happens most frequently
            because the map you specified in your
            XPLMCreateMapLayer_t::mapToCreateLayerIn field doesn't exist (that is, if
            XPLMMapExists() returns 0 for the specified map). You can use
            XPLMRegisterMapCreationHook() to get a notification each time a new map is
            opened in X-Plane, at which time you can create layers in it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.DestroyMapLayer(XP.SDK.XPLM.MapLayerID)">
            <summary>
            <para>
            Destroys a map layer you created (calling your
            XPLMMapWillBeDeletedCallback_f if applicable). Returns true if a deletion
            took place.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.RegisterMapCreationHook(,System.Void*)">
            <summary>
            <para>
            Registers your callback to receive a notification each time a new map is
            constructed in X-Plane. This callback is the best time to add your custom
            map layer using XPLMCreateMapLayer().
            </para>
            <para>
            Note that you will not be notified about any maps that already exist---you
            can use XPLMMapExists() to check for maps that were created previously.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.MapExists(System.Byte*)">
            <summary>
            <para>
            Returns 1 if the map with the specified identifier already exists in
            X-Plane. In that case, you can safely call XPLMCreateMapLayer() specifying
            that your layer should be added to that map.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.MapExists(XP.SDK.Utf8String@)">
            <summary>
            <para>
            Returns 1 if the map with the specified identifier already exists in
            X-Plane. In that case, you can safely call XPLMCreateMapLayer() specifying
            that your layer should be added to that map.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.MapExists(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Returns 1 if the map with the specified identifier already exists in
            X-Plane. In that case, you can safely call XPLMCreateMapLayer() specifying
            that your layer should be added to that map.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.DrawMapIconFromSheet(XP.SDK.XPLM.MapLayerID,System.Byte*,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,XP.SDK.XPLM.MapOrientation,System.Single,System.Single)">
            <summary>
            <para>
            Enables plugin-created map layers to draw PNG icons using X-Plane's
            built-in icon drawing functionality. Only valid from within an
            XPLMIconDrawingCallback_t (but you can request an arbitrary number of icons
            to be drawn from within your callback).
            </para>
            <para>
            X-Plane will automatically manage the memory for your texture so that it
            only has to be loaded from disk once as long as you continue drawing it
            per-frame. (When you stop drawing it, the memory may purged in a "garbage
            collection" pass, require a load from disk in the future.)
            </para>
            <para>
            Instead of having X-Plane draw a full PNG, this method allows you to use UV
            coordinates to request a portion of the image to be drawn. This allows you
            to use a single texture load (of an icon sheet, for example) to draw many
            icons. Doing so is much more efficient than drawing a dozen different small
            PNGs.
            </para>
            <para>
            The UV coordinates used here treat the texture you load as being comprised
            of a number of identically sized "cells." You specify the width and height
            in cells (ds and dt, respectively), as well as the coordinates within the
            cell grid for the sub-image you'd like to draw.
            </para>
            <para>
            Note that you can use different ds and dt values in subsequent calls with
            the same texture sheet. This enables you to use icons of different sizes in
            the same sheet if you arrange them properly in the PNG.
            </para>
            <para>
            This function is only valid from within an XPLMIconDrawingCallback_t (but
            you can request an arbitrary number of icons to be drawn from within your
            callback).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.DrawMapIconFromSheet(XP.SDK.XPLM.MapLayerID,XP.SDK.Utf8String@,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,XP.SDK.XPLM.MapOrientation,System.Single,System.Single)">
            <summary>
            <para>
            Enables plugin-created map layers to draw PNG icons using X-Plane's
            built-in icon drawing functionality. Only valid from within an
            XPLMIconDrawingCallback_t (but you can request an arbitrary number of icons
            to be drawn from within your callback).
            </para>
            <para>
            X-Plane will automatically manage the memory for your texture so that it
            only has to be loaded from disk once as long as you continue drawing it
            per-frame. (When you stop drawing it, the memory may purged in a "garbage
            collection" pass, require a load from disk in the future.)
            </para>
            <para>
            Instead of having X-Plane draw a full PNG, this method allows you to use UV
            coordinates to request a portion of the image to be drawn. This allows you
            to use a single texture load (of an icon sheet, for example) to draw many
            icons. Doing so is much more efficient than drawing a dozen different small
            PNGs.
            </para>
            <para>
            The UV coordinates used here treat the texture you load as being comprised
            of a number of identically sized "cells." You specify the width and height
            in cells (ds and dt, respectively), as well as the coordinates within the
            cell grid for the sub-image you'd like to draw.
            </para>
            <para>
            Note that you can use different ds and dt values in subsequent calls with
            the same texture sheet. This enables you to use icons of different sizes in
            the same sheet if you arrange them properly in the PNG.
            </para>
            <para>
            This function is only valid from within an XPLMIconDrawingCallback_t (but
            you can request an arbitrary number of icons to be drawn from within your
            callback).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.DrawMapIconFromSheet(XP.SDK.XPLM.MapLayerID,System.ReadOnlySpan{System.Char}@,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,XP.SDK.XPLM.MapOrientation,System.Single,System.Single)">
            <summary>
            <para>
            Enables plugin-created map layers to draw PNG icons using X-Plane's
            built-in icon drawing functionality. Only valid from within an
            XPLMIconDrawingCallback_t (but you can request an arbitrary number of icons
            to be drawn from within your callback).
            </para>
            <para>
            X-Plane will automatically manage the memory for your texture so that it
            only has to be loaded from disk once as long as you continue drawing it
            per-frame. (When you stop drawing it, the memory may purged in a "garbage
            collection" pass, require a load from disk in the future.)
            </para>
            <para>
            Instead of having X-Plane draw a full PNG, this method allows you to use UV
            coordinates to request a portion of the image to be drawn. This allows you
            to use a single texture load (of an icon sheet, for example) to draw many
            icons. Doing so is much more efficient than drawing a dozen different small
            PNGs.
            </para>
            <para>
            The UV coordinates used here treat the texture you load as being comprised
            of a number of identically sized "cells." You specify the width and height
            in cells (ds and dt, respectively), as well as the coordinates within the
            cell grid for the sub-image you'd like to draw.
            </para>
            <para>
            Note that you can use different ds and dt values in subsequent calls with
            the same texture sheet. This enables you to use icons of different sizes in
            the same sheet if you arrange them properly in the PNG.
            </para>
            <para>
            This function is only valid from within an XPLMIconDrawingCallback_t (but
            you can request an arbitrary number of icons to be drawn from within your
            callback).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.DrawMapLabel(XP.SDK.XPLM.MapLayerID,System.Byte*,System.Single,System.Single,XP.SDK.XPLM.MapOrientation,System.Single)">
            <summary>
            <para>
            Enables plugin-created map layers to draw text labels using X-Plane's
            built-in labeling functionality. Only valid from within an
            XPLMMapLabelDrawingCallback_f (but you can request an arbitrary number of
            text labels to be drawn from within your callback).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.DrawMapLabel(XP.SDK.XPLM.MapLayerID,XP.SDK.Utf8String@,System.Single,System.Single,XP.SDK.XPLM.MapOrientation,System.Single)">
            <summary>
            <para>
            Enables plugin-created map layers to draw text labels using X-Plane's
            built-in labeling functionality. Only valid from within an
            XPLMMapLabelDrawingCallback_f (but you can request an arbitrary number of
            text labels to be drawn from within your callback).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.DrawMapLabel(XP.SDK.XPLM.MapLayerID,System.ReadOnlySpan{System.Char}@,System.Single,System.Single,XP.SDK.XPLM.MapOrientation,System.Single)">
            <summary>
            <para>
            Enables plugin-created map layers to draw text labels using X-Plane's
            built-in labeling functionality. Only valid from within an
            XPLMMapLabelDrawingCallback_f (but you can request an arbitrary number of
            text labels to be drawn from within your callback).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.MapProject(XP.SDK.XPLM.MapProjectionID,System.Double,System.Double,System.Single*,System.Single*)">
            <summary>
            <para>
            Projects a latitude/longitude into map coordinates. This is the inverse of
            XPLMMapUnproject().
            </para>
            <para>
            Only valid from within a map layer callback (one of
            XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,
            XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.MapUnproject(XP.SDK.XPLM.MapProjectionID,System.Single,System.Single,System.Double*,System.Double*)">
            <summary>
            <para>
            Transforms map coordinates back into a latitude and longitude. This is the
            inverse of XPLMMapProject().
            </para>
            <para>
            Only valid from within a map layer callback (one of
            XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,
            XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.MapScaleMeter(XP.SDK.XPLM.MapProjectionID,System.Single,System.Single)">
            <summary>
            <para>
            Returns the number of map units that correspond to a distance of one meter
            at a given set of map coordinates.
            </para>
            <para>
            Only valid from within a map layer callback (one of
            XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,
            XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MapAPI.MapGetNorthHeading(XP.SDK.XPLM.MapProjectionID,System.Single,System.Single)">
            <summary>
            <para>
            Returns the heading (in degrees clockwise from "up") that corresponds to
            north at a given point on the map. In other words, if your runway has a
            true heading of 360, you would use "north" as the Cartesian angle at which
            to draw the runway on the map. (You would add the result of
            XPLMMapGetNorthHeading() to your true heading to get the map angle.)
            </para>
            <para>
            This is necessary becuase X-Plane's map can be rotated to match your
            aircraft's orientation; north is not always "up."
            </para>
            <para>
            Only valid from within a map layer callback (one of
            XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,
            XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.MapCreatedCallback">
            <summary>
            <para>
            A callback to notify your plugin that a new map has been created in
            X-Plane. This is the best time to add a custom map layer using
            XPLMCreateMapLayer().
            </para>
            <para>
            No OpenGL drawing is permitted within this callback.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.MapDrawingCallback">
            <summary>
            <para>
            This is the OpenGL map drawing callback for plugin-created map layers. You
            can perform arbitrary OpenGL drawing from this callback, with one
            exception: changes to the Z-buffer are not permitted, and will result in
            map drawing errors.
            </para>
            <para>
            All drawing done from within this callback appears beneath all built-in
            X-Plane icons and labels, but above the built-in "fill" layers (layers
            providing major details, like terrain and water). Note, however, that the
            relative ordering between the drawing callbacks of different plugins is not
            guaranteed.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.MapIconDrawingCallback">
            <summary>
            <para>
            This is the icon drawing callback that enables plugin-created map layers to
            draw icons using X-Plane's built-in icon drawing functionality. You can
            request an arbitrary number of PNG icons to be drawn via
            XPLMDrawMapIconFromSheet() from within this callback, but you may not
            perform any OpenGL drawing here.
            </para>
            <para>
            Icons enqueued by this function will appear above all OpenGL drawing
            (performed by your optional XPLMMapDrawingCallback_f), and above all
            built-in X-Plane map icons of the same layer type ("fill" or "markings," as
            determined by the XPLMMapLayerType in your XPLMCreateMapLayer_t). Note,
            however, that the relative ordering between the drawing callbacks of
            different plugins is not guaranteed.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.MapLabelDrawingCallback">
            <summary>
            <para>
            This is the label drawing callback that enables plugin-created map layers
            to draw text labels using X-Plane's built-in labeling functionality. You
            can request an arbitrary number of text labels to be drawn via
            XPLMDrawMapLabel() from within this callback, but you may not perform any
            OpenGL drawing here.
            </para>
            <para>
            Labels enqueued by this function will appear above all OpenGL drawing
            (performed by your optional XPLMMapDrawingCallback_f), and above all
            built-in map icons and labels of the same layer type ("fill" or "markings,"
            as determined by the XPLMMapLayerType in your XPLMCreateMapLayer_t). Note,
            however, that the relative ordering between the drawing callbacks of
            different plugins is not guaranteed.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.MapPrepareCacheCallback">
            <summary>
            <para>
            A callback used to allow you to cache whatever information your layer needs
            to draw in the current map area.
            </para>
            <para>
            This is called each time the map's total bounds change. This is typically
            triggered by new DSFs being loaded, such that X-Plane discards old,
            now-distant DSFs and pulls in new ones. At that point, the available bounds
            of the map also change to match the new DSF area.
            </para>
            <para>
            By caching just the information you need to draw in this area, your future
            draw calls can be made faster, since you'll be able to simply "splat" your
            precomputed information each frame.
            </para>
            <para>
            We guarantee that the map projection will not change between successive
            prepare cache calls, nor will any draw call give you bounds outside these
            total map bounds. So, if you cache the projected map coordinates of all the
            items you might want to draw in the total map area, you can be guaranteed
            that no draw call will be asked to do any new work.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.MapWillBeDeletedCallback">
            <summary>
            <para>
            Called just before your map layer gets deleted. Because SDK-created map
            layers have the same lifetime as the X-Plane map that contains them, if the
            map gets unloaded from memory, your layer will too.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.MenuHandlerCallback">
            <summary>
            <para>
            A menu handler function takes two reference pointers, one for the menu
            (specified when the menu was created) and one for the item (specified when
            the item was created).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.FindPluginsMenu">
            <summary>
            <para>
            This function returns the ID of the plug-ins menu, which is created for you
            at startup.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.FindAircraftMenu">
            <summary>
            <para>
            This function returns the ID of the menu for the currently-loaded aircraft,
            used for showing aircraft-specific commands.
            </para>
            <para>
            The aircraft menu is created by X-Plane at startup, but it remains hidden
            until it is populated via XPLMAppendMenuItem() or
            XPLMAppendMenuItemWithCommand().
            </para>
            <para>
            Only plugins loaded with the user's current aircraft are allowed to access
            the aircraft menu. For all other plugins, this will return NULL, and any
            attempts to add menu items to it will fail.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.CreateMenu(System.Byte*,XP.SDK.XPLM.MenuID,System.Int32,,System.Void*)">
            <summary>
            <para>
            This function creates a new menu and returns its ID.  It returns NULL if
            the menu cannot be created.  Pass in a parent menu ID and an item index to
            create a submenu, or NULL for the parent menu to put the menu in the menu
            bar.  The menu's name is only used if the menu is in the menubar.  You also
            pass a handler function and a menu reference value. Pass NULL for the
            handler if you do not need callbacks from the menu (for example, if it only
            contains submenus).
            </para>
            <para>
            Important: you must pass a valid, non-empty menu title even if the menu is
            a submenu where the title is not visible.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.CreateMenu(XP.SDK.Utf8String@,XP.SDK.XPLM.MenuID,System.Int32,,System.Void*)">
            <summary>
            <para>
            This function creates a new menu and returns its ID.  It returns NULL if
            the menu cannot be created.  Pass in a parent menu ID and an item index to
            create a submenu, or NULL for the parent menu to put the menu in the menu
            bar.  The menu's name is only used if the menu is in the menubar.  You also
            pass a handler function and a menu reference value. Pass NULL for the
            handler if you do not need callbacks from the menu (for example, if it only
            contains submenus).
            </para>
            <para>
            Important: you must pass a valid, non-empty menu title even if the menu is
            a submenu where the title is not visible.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.CreateMenu(System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.MenuID,System.Int32,,System.Void*)">
            <summary>
            <para>
            This function creates a new menu and returns its ID.  It returns NULL if
            the menu cannot be created.  Pass in a parent menu ID and an item index to
            create a submenu, or NULL for the parent menu to put the menu in the menu
            bar.  The menu's name is only used if the menu is in the menubar.  You also
            pass a handler function and a menu reference value. Pass NULL for the
            handler if you do not need callbacks from the menu (for example, if it only
            contains submenus).
            </para>
            <para>
            Important: you must pass a valid, non-empty menu title even if the menu is
            a submenu where the title is not visible.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.DestroyMenu(XP.SDK.XPLM.MenuID)">
            <summary>
            <para>
            This function destroys a menu that you have created.  Use this to remove a
            submenu if necessary.  (Normally this function will not be necessary.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.ClearAllMenuItems(XP.SDK.XPLM.MenuID)">
            <summary>
            <para>
            This function removes all menu items from a menu, allowing you to rebuild
            it.  Use this function if you need to change the number of items on a menu.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.AppendMenuItem(XP.SDK.XPLM.MenuID,System.Byte*,System.Void*,System.Int32)">
            <summary>
            <para>
            This routine appends a new menu item to the bottom of a menu and returns
            its index. Pass in the menu to add the item to, the items name, and a void
            * ref for this item.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            <para>
            Note that all menu indices returned are relative to your plugin's menus
            only; if your plugin creates two sub-menus in the Plugins menu at different
            times, it doesn't matter how many other plugins also create sub-menus of
            Plugins in the intervening time: your sub-menus will be given menu indices
            0 and 1. (The SDK does some work in the back-end to filter out menus that
            are irrelevant to your plugin in order to deliver this consistency for each
            plugin.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.AppendMenuItem(XP.SDK.XPLM.MenuID,XP.SDK.Utf8String@,System.Void*,System.Int32)">
            <summary>
            <para>
            This routine appends a new menu item to the bottom of a menu and returns
            its index. Pass in the menu to add the item to, the items name, and a void
            * ref for this item.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            <para>
            Note that all menu indices returned are relative to your plugin's menus
            only; if your plugin creates two sub-menus in the Plugins menu at different
            times, it doesn't matter how many other plugins also create sub-menus of
            Plugins in the intervening time: your sub-menus will be given menu indices
            0 and 1. (The SDK does some work in the back-end to filter out menus that
            are irrelevant to your plugin in order to deliver this consistency for each
            plugin.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.AppendMenuItem(XP.SDK.XPLM.MenuID,System.ReadOnlySpan{System.Char}@,System.Void*,System.Int32)">
            <summary>
            <para>
            This routine appends a new menu item to the bottom of a menu and returns
            its index. Pass in the menu to add the item to, the items name, and a void
            * ref for this item.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            <para>
            Note that all menu indices returned are relative to your plugin's menus
            only; if your plugin creates two sub-menus in the Plugins menu at different
            times, it doesn't matter how many other plugins also create sub-menus of
            Plugins in the intervening time: your sub-menus will be given menu indices
            0 and 1. (The SDK does some work in the back-end to filter out menus that
            are irrelevant to your plugin in order to deliver this consistency for each
            plugin.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.AppendMenuItemWithCommand(XP.SDK.XPLM.MenuID,System.Byte*,XP.SDK.XPLM.CommandRef)">
            <summary>
            <para>
            Like XPLMAppendMenuItem(), but instead of the new menu item triggering the
            XPLMMenuHandler_f of the containiner menu, it will simply execute the
            command you pass in. Using a command for your menu item allows the user to
            bind a keyboard shortcut to the command and see that shortcut represented
            in the menu.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            <para>
            Like XPLMAppendMenuItem(), all menu indices are relative to your plugin's
            menus only.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.AppendMenuItemWithCommand(XP.SDK.XPLM.MenuID,XP.SDK.Utf8String@,XP.SDK.XPLM.CommandRef)">
            <summary>
            <para>
            Like XPLMAppendMenuItem(), but instead of the new menu item triggering the
            XPLMMenuHandler_f of the containiner menu, it will simply execute the
            command you pass in. Using a command for your menu item allows the user to
            bind a keyboard shortcut to the command and see that shortcut represented
            in the menu.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            <para>
            Like XPLMAppendMenuItem(), all menu indices are relative to your plugin's
            menus only.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.AppendMenuItemWithCommand(XP.SDK.XPLM.MenuID,System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.CommandRef)">
            <summary>
            <para>
            Like XPLMAppendMenuItem(), but instead of the new menu item triggering the
            XPLMMenuHandler_f of the containiner menu, it will simply execute the
            command you pass in. Using a command for your menu item allows the user to
            bind a keyboard shortcut to the command and see that shortcut represented
            in the menu.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            <para>
            Like XPLMAppendMenuItem(), all menu indices are relative to your plugin's
            menus only.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.AppendMenuSeparator(XP.SDK.XPLM.MenuID)">
            <summary>
            <para>
            This routine adds a separator to the end of a menu.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.SetMenuItemName(XP.SDK.XPLM.MenuID,System.Int32,System.Byte*,System.Int32)">
            <summary>
            <para>
            This routine changes the name of an existing menu item.  Pass in the menu
            ID and the index of the menu item.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.SetMenuItemName(XP.SDK.XPLM.MenuID,System.Int32,XP.SDK.Utf8String@,System.Int32)">
            <summary>
            <para>
            This routine changes the name of an existing menu item.  Pass in the menu
            ID and the index of the menu item.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.SetMenuItemName(XP.SDK.XPLM.MenuID,System.Int32,System.ReadOnlySpan{System.Char}@,System.Int32)">
            <summary>
            <para>
            This routine changes the name of an existing menu item.  Pass in the menu
            ID and the index of the menu item.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.CheckMenuItem(XP.SDK.XPLM.MenuID,System.Int32,XP.SDK.XPLM.MenuCheck)">
            <summary>
            <para>
            Set whether a menu item is checked.  Pass in the menu ID and item index.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.CheckMenuItemState(XP.SDK.XPLM.MenuID,System.Int32,XP.SDK.XPLM.MenuCheck*)">
            <summary>
            <para>
            This routine returns whether a menu item is checked or not. A menu item's
            check mark may be on or off, or a menu may not have an icon at all.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.EnableMenuItem(XP.SDK.XPLM.MenuID,System.Int32,System.Int32)">
            <summary>
            <para>
            Sets whether this menu item is enabled.  Items start out enabled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.MenusAPI.RemoveMenuItem(XP.SDK.XPLM.MenuID,System.Int32)">
            <summary>
            <para>
            Removes one item from a menu.  Note that all menu items below are moved up
            one; your plugin must track the change in index numbers.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.GetFirstNavAid">
            <summary>
            <para>
            This returns the very first navaid in the database.  Use this to traverse
            the entire database.  Returns XPLM_NAV_NOT_FOUND if the nav database is
            empty.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.GetNextNavAid(XP.SDK.XPLM.NavRef)">
            <summary>
            <para>
            Given a valid nav aid ref, this routine returns the next navaid.  It
            returns XPLM_NAV_NOT_FOUND if the nav aid passed in was invalid or if the
            navaid passed in was the last one in the database.  Use this routine to
            iterate across all like-typed navaids or the entire database.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.FindFirstNavAidOfType(XP.SDK.XPLM.NavType)">
            <summary>
            <para>
            This routine returns the ref of the first navaid of the given type in the
            database or XPLM_NAV_NOT_FOUND if there are no navaids of that type in the
            database.  You must pass exactly one nav aid type to this routine.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.FindLastNavAidOfType(XP.SDK.XPLM.NavType)">
            <summary>
            <para>
            This routine returns the ref of the last navaid of the given type in the
            database or XPLM_NAV_NOT_FOUND if there are no navaids of that type in the
            database.  You must pass exactly one nav aid type to this routine.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.FindNavAid(System.Byte*,System.Byte*,System.Single*,System.Single*,System.Int32*,XP.SDK.XPLM.NavType)">
            <summary>
            <para>
            This routine provides a number of searching capabilities for the nav
            database. XPLMFindNavAid will search through every nav aid whose type is
            within inType (multiple types may be added together) and return any
            nav-aids found based on the following rules:
            </para>
            <para>
            * If inLat and inLon are not NULL, the navaid nearest to that lat/lon will
            be returned, otherwise the last navaid found will be returned.
            </para>
            <para>
            * If inFrequency is not NULL, then any navaids considered must match this
            frequency.  Note that this will screen out radio beacons that do not have
            frequency data published (like inner markers) but not fixes and airports.
            </para>
            <para>
            * If inNameFragment is not NULL, only navaids that contain the fragment in
            their name will be returned.
            </para>
            <para>
            * If inIDFragment is not NULL, only navaids that contain the fragment in
            their IDs will be returned.
            </para>
            <para>
            This routine provides a simple way to do a number of useful searches:
            * Find the nearest navaid on this frequency.
            * Find the nearest airport.
            * Find the VOR whose ID is "KBOS".
            * Find the nearest airport whose name contains "Chicago".
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.FindNavAid(XP.SDK.Utf8String@,XP.SDK.Utf8String@,System.Single*,System.Single*,System.Int32*,XP.SDK.XPLM.NavType)">
            <summary>
            <para>
            This routine provides a number of searching capabilities for the nav
            database. XPLMFindNavAid will search through every nav aid whose type is
            within inType (multiple types may be added together) and return any
            nav-aids found based on the following rules:
            </para>
            <para>
            * If inLat and inLon are not NULL, the navaid nearest to that lat/lon will
            be returned, otherwise the last navaid found will be returned.
            </para>
            <para>
            * If inFrequency is not NULL, then any navaids considered must match this
            frequency.  Note that this will screen out radio beacons that do not have
            frequency data published (like inner markers) but not fixes and airports.
            </para>
            <para>
            * If inNameFragment is not NULL, only navaids that contain the fragment in
            their name will be returned.
            </para>
            <para>
            * If inIDFragment is not NULL, only navaids that contain the fragment in
            their IDs will be returned.
            </para>
            <para>
            This routine provides a simple way to do a number of useful searches:
            * Find the nearest navaid on this frequency.
            * Find the nearest airport.
            * Find the VOR whose ID is "KBOS".
            * Find the nearest airport whose name contains "Chicago".
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.FindNavAid(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char}@,System.Single*,System.Single*,System.Int32*,XP.SDK.XPLM.NavType)">
            <summary>
            <para>
            This routine provides a number of searching capabilities for the nav
            database. XPLMFindNavAid will search through every nav aid whose type is
            within inType (multiple types may be added together) and return any
            nav-aids found based on the following rules:
            </para>
            <para>
            * If inLat and inLon are not NULL, the navaid nearest to that lat/lon will
            be returned, otherwise the last navaid found will be returned.
            </para>
            <para>
            * If inFrequency is not NULL, then any navaids considered must match this
            frequency.  Note that this will screen out radio beacons that do not have
            frequency data published (like inner markers) but not fixes and airports.
            </para>
            <para>
            * If inNameFragment is not NULL, only navaids that contain the fragment in
            their name will be returned.
            </para>
            <para>
            * If inIDFragment is not NULL, only navaids that contain the fragment in
            their IDs will be returned.
            </para>
            <para>
            This routine provides a simple way to do a number of useful searches:
            * Find the nearest navaid on this frequency.
            * Find the nearest airport.
            * Find the VOR whose ID is "KBOS".
            * Find the nearest airport whose name contains "Chicago".
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.GetNavAidInfo(XP.SDK.XPLM.NavRef,XP.SDK.XPLM.NavType*,System.Single*,System.Single*,System.Single*,System.Int32*,System.Single*,System.Byte*,System.Byte*,System.Byte*)">
            <summary>
            <para>
            This routine returns information about a navaid.  Any non-null field is
            filled out with information if it is available.
            </para>
            <para>
            Frequencies are in the nav.dat convention as described in the X-Plane nav
            database FAQ: NDB frequencies are exact, all others are multiplied by 100.
            </para>
            <para>
            The buffer for IDs should be at least 6 chars and the buffer for names
            should be at least 41 chars, but since these values are likely to go up, I
            recommend passing at least 32 chars for IDs and 256 chars for names when
            possible.
            </para>
            <para>
            The outReg parameter tells if the navaid is within the local "region" of
            loaded DSFs.  (This information may not be particularly useful to plugins.)
            The parameter is a single byte value 1 for true or 0 for false, not a C
            string.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.CountFMSEntries">
            <summary>
            <para>
            This routine returns the number of entries in the FMS.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.GetDisplayedFMSEntry">
            <summary>
            <para>
            This routine returns the index of the entry the pilot is viewing.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.GetDestinationFMSEntry">
            <summary>
            <para>
            This routine returns the index of the entry the FMS is flying to.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.SetDisplayedFMSEntry(System.Int32)">
            <summary>
            <para>
            This routine changes which entry the FMS is showing to the index specified.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.SetDestinationFMSEntry(System.Int32)">
            <summary>
            <para>
            This routine changes which entry the FMS is flying the aircraft toward.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.GetFMSEntryInfo(System.Int32,XP.SDK.XPLM.NavType*,System.Byte*,XP.SDK.XPLM.NavRef*,System.Int32*,System.Single*,System.Single*)">
            <summary>
            <para>
            This routine returns information about a given FMS entry. If the entry is
            an airport or navaid, a reference to a nav entry can be returned allowing
            you to find additional information (such as a frequency, ILS heading, name,
            etc.). Note that this reference can be XPLM_NAV_NOT_FOUND until the
            information has been looked up asynchronously, so after flightplan changes,
            it might take up to a second for this field to become populated. The other
            information is available immediately. For a lat/lon entry, the lat/lon is
            returned by this routine but the navaid cannot be looked up (and the
            reference will be XPLM_NAV_NOT_FOUND). FMS name entry buffers should be at
            least 256 chars in length.
            </para>
            <para>
            WARNING: Due to a bug in X-Plane prior to 11.31, the navaid reference will
            not be set to XPLM_NAV_NOT_FOUND while no data is available, and instead
            just remain the value of the variable that you passed the pointer to.
            Therefore, always initialize the variable to XPLM_NAV_NOT_FOUND before
            passing the pointer to this function.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.SetFMSEntryInfo(System.Int32,XP.SDK.XPLM.NavRef,System.Int32)">
            <summary>
            <para>
            This routine changes an entry in the FMS to have the destination navaid
            passed in and the altitude specified.  Use this only for airports, fixes,
            and radio-beacon navaids.  Currently of radio beacons, the FMS can only
            support VORs and NDBs. Use the routines below to clear or fly to a lat/lon.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.SetFMSEntryLatLon(System.Int32,System.Single,System.Single,System.Int32)">
            <summary>
            <para>
            This routine changes the entry in the FMS to a lat/lon entry with the given
            coordinates.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.ClearFMSEntry(System.Int32)">
            <summary>
            <para>
            This routine clears the given entry, potentially shortening the flight
            plan.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.GetGPSDestinationType">
            <summary>
            <para>
            This routine returns the type of the currently selected GPS destination,
            one of fix, airport, VOR or NDB.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.NavigationAPI.GetGPSDestination">
            <summary>
            <para>
            This routine returns the current GPS destination.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.ObjectLoadedCallback">
            <summary>
            <para>
            You provide this callback when loading an object asynchronously; it will be
            called once the object is loaded. Your refcon is passed back. The object
            ref passed in is the newly loaded object (ready for use) or NULL if an
            error occured.
            </para>
            <para>
            If your plugin is disabled, this callback will be delivered as soon as the
            plugin is re-enabled. If your plugin is unloaded before this callback is
            ever called, the SDK will release the object handle for you.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.PlaneDrawState">
            <summary>
            <para>
            This structure contains additional plane parameter info to be passed to
            draw plane.  Make sure to fill in the size of the structure field with
            sizeof(XPLMDrawPlaneState_t) so that the XPLM can tell how many fields you
            knew about when compiling your plugin (since more fields may be added
            later).
            </para>
            <para>
            Most of these fields are ratios from 0 to 1 for control input.  X-Plane
            calculates what the actual controls look like based on the .acf file for
            that airplane.  Note for the yoke inputs, this is what the pilot of the
            plane has commanded (post artificial stability system if there were one)
            and affects aelerons, rudder, etc.  It is not  necessarily related to the
            actual position of the plane!
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.SetUsersAircraft(System.Byte*)">
            <summary>
            <para>
            This routine changes the user's aircraft.  Note that this will reinitialize
            the user to be on the nearest airport's first runway.  Pass in a full path
            (hard drive and everything including the .acf extension) to the .acf file.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.SetUsersAircraft(XP.SDK.Utf8String@)">
            <summary>
            <para>
            This routine changes the user's aircraft.  Note that this will reinitialize
            the user to be on the nearest airport's first runway.  Pass in a full path
            (hard drive and everything including the .acf extension) to the .acf file.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.SetUsersAircraft(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine changes the user's aircraft.  Note that this will reinitialize
            the user to be on the nearest airport's first runway.  Pass in a full path
            (hard drive and everything including the .acf extension) to the .acf file.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.PlaceUserAtAirport(System.Byte*)">
            <summary>
            <para>
            This routine places the user at a given airport.  Specify the airport by
            its X-Plane airport ID (e.g. 'KBOS').
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.PlaceUserAtAirport(XP.SDK.Utf8String@)">
            <summary>
            <para>
            This routine places the user at a given airport.  Specify the airport by
            its X-Plane airport ID (e.g. 'KBOS').
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.PlaceUserAtAirport(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine places the user at a given airport.  Specify the airport by
            its X-Plane airport ID (e.g. 'KBOS').
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.PlaceUserAtLocation(System.Double,System.Double,System.Single,System.Single,System.Single)">
            <summary>
            <para>
            Places the user at a specific location after performing any necessary
            scenery loads.
            </para>
            <para>
            As with in-air starts initiated from the X-Plane user interface, the
            aircraft will always start with its engines running, regardless of the
            user's preferences (i.e., regardless of what the dataref
            `sim/operation/prefs/startup_running` says).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.CountAircraft(System.Int32*,System.Int32*,XP.SDK.XPLM.PluginID*)">
            <summary>
            <para>
            This function returns the number of aircraft X-Plane is capable of having,
            as well as the number of aircraft that are currently active.  These numbers
            count the user's aircraft.  It can also return the plugin that is currently
            controlling aircraft.  In X-Plane 7, this routine reflects the number of
            aircraft the user has enabled in the rendering options window.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.GetNthAircraftModel(System.Int32,System.Byte*,System.Byte*)">
            <summary>
            <para>
            This function returns the aircraft model for the Nth aircraft.  Indices are
            zero based, with zero being the user's aircraft.  The file name should be
            at least 256 chars in length; the path should be at least 512 chars in
            length.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.AcquirePlanes(System.Byte**,,System.Void*)">
            <summary>
            <para>
            XPLMAcquirePlanes grants your plugin exclusive access to the aircraft.  It
            returns 1 if you gain access, 0 if you do not.
            </para>
            <para>
            inAircraft - pass in an array of pointers to strings specifying the planes
            you want loaded.  For any plane index you do not want loaded, pass a
            0-length string.  Other strings should be full paths with the .acf
            extension.  NULL terminates this array, or pass NULL if there are no planes
            you want loaded.
            </para>
            <para>
            If you pass in a callback and do not receive access to the planes your
            callback will be called when the airplanes are available. If you do receive
            airplane access, your callback will not be called.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.ReleasePlanes">
            <summary>
            <para>
            Call this function to release access to the planes.  Note that if you are
            disabled, access to planes is released for you and you must reacquire it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.SetActiveAircraftCount(System.Int32)">
            <summary>
            <para>
            This routine sets the number of active planes.  If you pass in a number
            higher than the total number of planes availables, only the total number of
            planes available is actually used.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.SetAircraftModel(System.Int32,System.Byte*)">
            <summary>
            <para>
            This routine loads an aircraft model.  It may only be called if you have
            exclusive access to the airplane APIs.  Pass in the path of the model with
            the .acf extension.  The index is zero based, but you may not pass in 0
            (use XPLMSetUsersAircraft to load the user's aircracft).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.SetAircraftModel(System.Int32,XP.SDK.Utf8String@)">
            <summary>
            <para>
            This routine loads an aircraft model.  It may only be called if you have
            exclusive access to the airplane APIs.  Pass in the path of the model with
            the .acf extension.  The index is zero based, but you may not pass in 0
            (use XPLMSetUsersAircraft to load the user's aircracft).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.SetAircraftModel(System.Int32,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine loads an aircraft model.  It may only be called if you have
            exclusive access to the airplane APIs.  Pass in the path of the model with
            the .acf extension.  The index is zero based, but you may not pass in 0
            (use XPLMSetUsersAircraft to load the user's aircracft).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PlanesAPI.DisableAIForPlane(System.Int32)">
            <summary>
            <para>
            This routine turns off X-Plane's AI for a given plane.  The plane will
            continue to draw and be a real plane in X-Plane, but will not move itself.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.PlanesAvailableCallback">
            <summary>
            <para>
            Your airplanes available callback is called when another plugin gives up
            access to the multiplayer planes.  Use this to wait for access to
            multiplayer.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.GetMyID">
            <summary>
            <para>
            This routine returns the plugin ID of the calling plug-in.  Call this to
            get your own ID.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.CountPlugins">
            <summary>
            <para>
            This routine returns the total number of plug-ins that are loaded, both
            disabled and enabled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.GetNthPlugin(System.Int32)">
            <summary>
            <para>
            This routine returns the ID of a plug-in by index.  Index is 0 based from 0
            to XPLMCountPlugins-1, inclusive. Plugins may be returned in any arbitrary
            order.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.FindPluginByPath(System.Byte*)">
            <summary>
            <para>
            This routine returns the plug-in ID of the plug-in whose file exists at the
            passed in absolute file system path.  XPLM_NO_PLUGIN_ID is returned if the
            path does not point to a currently loaded plug-in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.FindPluginByPath(XP.SDK.Utf8String@)">
            <summary>
            <para>
            This routine returns the plug-in ID of the plug-in whose file exists at the
            passed in absolute file system path.  XPLM_NO_PLUGIN_ID is returned if the
            path does not point to a currently loaded plug-in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.FindPluginByPath(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine returns the plug-in ID of the plug-in whose file exists at the
            passed in absolute file system path.  XPLM_NO_PLUGIN_ID is returned if the
            path does not point to a currently loaded plug-in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.FindPluginBySignature(System.Byte*)">
            <summary>
            <para>
            This routine returns the plug-in ID of the plug-in whose signature matches
            what is passed in or XPLM_NO_PLUGIN_ID if no running plug-in has this
            signature.  Signatures are the best way to identify another plug-in as they
            are independent of the file system path of a plug-in or the human-readable
            plug-in name, and should be unique for all plug-ins.  Use this routine to
            locate another plugin that your plugin interoperates with
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.FindPluginBySignature(XP.SDK.Utf8String@)">
            <summary>
            <para>
            This routine returns the plug-in ID of the plug-in whose signature matches
            what is passed in or XPLM_NO_PLUGIN_ID if no running plug-in has this
            signature.  Signatures are the best way to identify another plug-in as they
            are independent of the file system path of a plug-in or the human-readable
            plug-in name, and should be unique for all plug-ins.  Use this routine to
            locate another plugin that your plugin interoperates with
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.FindPluginBySignature(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine returns the plug-in ID of the plug-in whose signature matches
            what is passed in or XPLM_NO_PLUGIN_ID if no running plug-in has this
            signature.  Signatures are the best way to identify another plug-in as they
            are independent of the file system path of a plug-in or the human-readable
            plug-in name, and should be unique for all plug-ins.  Use this routine to
            locate another plugin that your plugin interoperates with
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.GetPluginInfo(XP.SDK.XPLM.PluginID,System.Byte*,System.Byte*,System.Byte*,System.Byte*)">
            <summary>
            <para>
            This routine returns information about a plug-in.  Each parameter should be
            a pointer to a buffer of at least
            256 characters, or NULL to not receive the information.
            </para>
            <para>
            outName - the human-readable name of the plug-in. outFilePath - the
            absolute file path to the file that contains this plug-in. outSignature - a
            unique string that identifies this plug-in. outDescription - a
            human-readable description of this plug-in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.IsPluginEnabled(XP.SDK.XPLM.PluginID)">
            <summary>
            <para>
            Returns whether the specified plug-in is enabled for running.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.EnablePlugin(XP.SDK.XPLM.PluginID)">
            <summary>
            <para>
            This routine enables a plug-in if it is not already enabled. It returns 1
            if the plugin was enabled or successfully enables itself, 0 if it does not.
            Plugins may fail to enable (for example, if resources cannot be acquired)
            by returning 0 from their XPluginEnable callback.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.DisablePlugin(XP.SDK.XPLM.PluginID)">
            <summary>
            <para>
            This routine disableds an enabled plug-in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.ReloadPlugins">
            <summary>
            <para>
            This routine reloads all plug-ins.  Once this routine is called and you
            return from the callback you were within (e.g. a menu select callback) you
            will receive your XPluginDisable and XPluginStop callbacks and your DLL
            will be unloaded, then the start process happens as if the sim was starting
            up.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.SendMessageToPlugin(XP.SDK.XPLM.PluginID,System.Int32,System.Void*)">
            <summary>
            <para>
            This function sends a message to another plug-in or X-Plane.  Pass
            XPLM_NO_PLUGIN_ID to broadcast to all plug-ins.  Only enabled plug-ins with
            a message receive function receive the message.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.HasFeature(System.Byte*)">
            <summary>
            <para>
            This returns 1 if the given installation of X-Plane supports a feature, or
            0 if it does not.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.HasFeature(XP.SDK.Utf8String@)">
            <summary>
            <para>
            This returns 1 if the given installation of X-Plane supports a feature, or
            0 if it does not.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.HasFeature(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This returns 1 if the given installation of X-Plane supports a feature, or
            0 if it does not.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.IsFeatureEnabled(System.Byte*)">
            <summary>
            <para>
            This returns 1 if a feature is currently enabled for your plugin, or 0 if
            it is not enabled.  It is an error to call this routine with an unsupported
            feature.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.IsFeatureEnabled(XP.SDK.Utf8String@)">
            <summary>
            <para>
            This returns 1 if a feature is currently enabled for your plugin, or 0 if
            it is not enabled.  It is an error to call this routine with an unsupported
            feature.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.IsFeatureEnabled(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This returns 1 if a feature is currently enabled for your plugin, or 0 if
            it is not enabled.  It is an error to call this routine with an unsupported
            feature.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.EnableFeature(System.Byte*,System.Int32)">
            <summary>
            <para>
            This routine enables or disables a feature for your plugin.  This will
            change the running behavior of X-Plane and your plugin in some way,
            depending on the feature.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.EnableFeature(XP.SDK.Utf8String@,System.Int32)">
            <summary>
            <para>
            This routine enables or disables a feature for your plugin.  This will
            change the running behavior of X-Plane and your plugin in some way,
            depending on the feature.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.EnableFeature(System.ReadOnlySpan{System.Char}@,System.Int32)">
            <summary>
            <para>
            This routine enables or disables a feature for your plugin.  This will
            change the running behavior of X-Plane and your plugin in some way,
            depending on the feature.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.PluginAPI.EnumerateFeatures(,System.Void*)">
            <summary>
            <para>
            This routine calls your enumerator callback once for each feature that this
            running version of X-Plane supports. Use this routine to determine all of
            the features that X-Plane can support.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.ProbeInfo">
            <summary>
            <para>
            XPLMProbeInfo_t contains the results of a probe call. Make sure to set
            structSize to the size of the struct before using it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.ProcessingAPI.GetElapsedTime">
            <summary>
            <para>
            This routine returns the elapsed time since the sim started up in decimal
            seconds. This is a wall timer; it keeps counting upward even if the sim is
            pasued.
            </para>
            <para>
            __WARNING__: XPLMGetElapsedTime is not a very good timer!  It lacks
            precision in both its data type and its source.  Do not attempt to use it
            for timing critical applications like network multiplayer.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.ProcessingAPI.GetCycleNumber">
            <summary>
            <para>
            This routine returns a counter starting at zero for each sim cycle
            computed/video frame rendered.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.ProcessingAPI.RegisterFlightLoopCallback(,System.Single,System.Void*)">
            <summary>
            <para>
            This routine registers your flight loop callback. Pass in a pointer to a
            flight loop function and a refcon. inInterval defines when you will be
            called. Pass in a positive number to specify seconds from registration time
            to the next callback. Pass in a negative number to indicate when you will
            be called (e.g. pass -1 to be called at the next cylcle). Pass 0 to not be
            called; your callback will be inactive.
            </para>
            <para>
            (This legacy function only installs pre-flight-loop callbacks; use
            XPLMCreateFlightLoop for more control.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.ProcessingAPI.UnregisterFlightLoopCallback(,System.Void*)">
            <summary>
            <para>
            This routine unregisters your flight loop callback. Do NOT call it from
            your flight loop callback. Once your flight loop callback is unregistered,
            it will not be called again.
            </para>
            <para>
            Only use this on flight loops registered via
            XPLMRegisterFlightLoopCallback.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.ProcessingAPI.SetFlightLoopCallbackInterval(,System.Single,System.Int32,System.Void*)">
            <summary>
            <para>
            This routine sets when a callback will be called. Do NOT call it from your
            callback; use the return value of the callback to change your callback
            interval from inside your callback.
            </para>
            <para>
            inInterval is formatted the same way as in XPLMRegisterFlightLoopCallback;
            positive for seconds, negative for cycles, and 0 for deactivating the
            callback. If inRelativeToNow is 1, times are from the time of this call;
            otherwise they are from the time the callback was last called (or the time
            it was registered if it has never been called.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.ProcessingAPI.CreateFlightLoop(XP.SDK.XPLM.Interop.CreateFlightLoop*)">
            <summary>
            <para>
            This routine creates a flight loop callback and returns its ID. The flight
            loop callback is created using the input param struct, and is inited to be
            unscheduled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.ProcessingAPI.DestroyFlightLoop(XP.SDK.XPLM.FlightLoopID)">
            <summary>
            <para>
            This routine destroys a flight loop callback by ID. Only call it on flight
            loops created with the newer XPLMCreateFlightLoop API.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.ProcessingAPI.ScheduleFlightLoop(XP.SDK.XPLM.FlightLoopID,System.Single,System.Int32)">
            <summary>
            <para>
            This routine schedules a flight loop callback for future execution. If
            inInterval is negative, it is run in a certain number of frames based on
            the absolute value of the input. If the interval is positive, it is a
            duration in seconds.
            </para>
            <para>
            If inRelativeToNow is true, ties are interpretted relative to the time this
            routine is called; otherwise they are relative to the last call time or the
            time the flight loop was registered (if never called).
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.ReceiveMonitorBoundsGlobalCallback">
            <summary>
            <para>
            This function is informed of the global bounds (in boxels) of a particular
            monitor within the X-Plane global desktop space. Note that X-Plane must be
            running in full screen on a monitor in order for that monitor to be passed
            to you in this callback.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.ReceiveMonitorBoundsOSCallback">
            <summary>
            <para>
            This function is informed of the global bounds (in pixels) of a particular
            monitor within the operating system's global desktop space. Note that a
            monitor index being passed to you here does not indicate that X-Plane is
            running in full screen on this monitor, or even that any X-Plane windows
            exist on this monitor.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.CreateProbe(XP.SDK.XPLM.ProbeType)">
            <summary>
            <para>
            Creates a new probe object of a given type and returns.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.DestroyProbe(XP.SDK.XPLM.ProbeRef)">
            <summary>
            <para>
            Deallocates an existing probe object.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.ProbeTerrainXYZ(XP.SDK.XPLM.ProbeRef,System.Single,System.Single,System.Single,XP.SDK.XPLM.Interop.ProbeInfo*)">
            <summary>
            <para>
            Probes the terrain. Pass in the XYZ coordinate of the probe point, a probe
            object, and an XPLMProbeInfo_t struct that has its structSize member set
            properly. Other fields are filled in if we hit terrain, and a probe result
            is returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.GetMagneticVariation(System.Double,System.Double)">
            <summary>
            <para>
            Returns X-Plane's simulated magnetic variation (declination) at the
            indication latitude and longitude.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.DegTrueToDegMagnetic(System.Single)">
            <summary>
            <para>
            Converts a heading in degrees relative to true north into a value relative
            to magnetic north at the user's current location.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.DegMagneticToDegTrue(System.Single)">
            <summary>
            <para>
            Converts a heading in degrees relative to magnetic north at the user's
            current location into a value relative to true north.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.LoadObject(System.Byte*)">
            <summary>
            <para>
            This routine loads an OBJ file and returns a handle to it. If X-Plane has
            already loaded the object, the handle to the existing object is returned.
            Do not assume you will get the same handle back twice, but do make sure to
            call unload once for every load to avoid "leaking" objects. The object will
            be purged from memory when no plugins and no scenery are using it.
            </para>
            <para>
            The path for the object must be relative to the X-System base folder. If
            the path is in the root of the X-System folder you may need to prepend ./
            to it; loading objects in the root of the X-System folder is STRONGLY
            discouraged - your plugin should not dump art resources in the root folder!
            </para>
            <para>
            XPLMLoadObject will return NULL if the object cannot be loaded (either
            because it is not found or the file is misformatted). This routine will
            load any object that can be used in the X-Plane scenery system.
            </para>
            <para>
            It is important that the datarefs an object uses for animation already be
            loaded before you load the object. For this reason it may be necessary to
            defer object loading until the sim has fully started.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.LoadObject(XP.SDK.Utf8String@)">
            <summary>
            <para>
            This routine loads an OBJ file and returns a handle to it. If X-Plane has
            already loaded the object, the handle to the existing object is returned.
            Do not assume you will get the same handle back twice, but do make sure to
            call unload once for every load to avoid "leaking" objects. The object will
            be purged from memory when no plugins and no scenery are using it.
            </para>
            <para>
            The path for the object must be relative to the X-System base folder. If
            the path is in the root of the X-System folder you may need to prepend ./
            to it; loading objects in the root of the X-System folder is STRONGLY
            discouraged - your plugin should not dump art resources in the root folder!
            </para>
            <para>
            XPLMLoadObject will return NULL if the object cannot be loaded (either
            because it is not found or the file is misformatted). This routine will
            load any object that can be used in the X-Plane scenery system.
            </para>
            <para>
            It is important that the datarefs an object uses for animation already be
            loaded before you load the object. For this reason it may be necessary to
            defer object loading until the sim has fully started.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.LoadObject(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine loads an OBJ file and returns a handle to it. If X-Plane has
            already loaded the object, the handle to the existing object is returned.
            Do not assume you will get the same handle back twice, but do make sure to
            call unload once for every load to avoid "leaking" objects. The object will
            be purged from memory when no plugins and no scenery are using it.
            </para>
            <para>
            The path for the object must be relative to the X-System base folder. If
            the path is in the root of the X-System folder you may need to prepend ./
            to it; loading objects in the root of the X-System folder is STRONGLY
            discouraged - your plugin should not dump art resources in the root folder!
            </para>
            <para>
            XPLMLoadObject will return NULL if the object cannot be loaded (either
            because it is not found or the file is misformatted). This routine will
            load any object that can be used in the X-Plane scenery system.
            </para>
            <para>
            It is important that the datarefs an object uses for animation already be
            loaded before you load the object. For this reason it may be necessary to
            defer object loading until the sim has fully started.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.LoadObjectAsync(System.Byte*,,System.Void*)">
            <summary>
            <para>
            This routine loads an object asynchronously; control is returned to you
            immediately while X-Plane loads the object. The sim will not stop flying
            while the object loads. For large objects, it may be several seconds before
            the load finishes.
            </para>
            <para>
            You provide a callback function that is called once the load has completed.
            Note that if the object cannot be loaded, you will not find out until the
            callback function is called with a NULL object handle.
            </para>
            <para>
            There is no way to cancel an asynchronous object load; you must wait for
            the load to complete and then release the object if it is no longer
            desired.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.LoadObjectAsync(XP.SDK.Utf8String@,,System.Void*)">
            <summary>
            <para>
            This routine loads an object asynchronously; control is returned to you
            immediately while X-Plane loads the object. The sim will not stop flying
            while the object loads. For large objects, it may be several seconds before
            the load finishes.
            </para>
            <para>
            You provide a callback function that is called once the load has completed.
            Note that if the object cannot be loaded, you will not find out until the
            callback function is called with a NULL object handle.
            </para>
            <para>
            There is no way to cancel an asynchronous object load; you must wait for
            the load to complete and then release the object if it is no longer
            desired.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.LoadObjectAsync(System.ReadOnlySpan{System.Char}@,,System.Void*)">
            <summary>
            <para>
            This routine loads an object asynchronously; control is returned to you
            immediately while X-Plane loads the object. The sim will not stop flying
            while the object loads. For large objects, it may be several seconds before
            the load finishes.
            </para>
            <para>
            You provide a callback function that is called once the load has completed.
            Note that if the object cannot be loaded, you will not find out until the
            callback function is called with a NULL object handle.
            </para>
            <para>
            There is no way to cancel an asynchronous object load; you must wait for
            the load to complete and then release the object if it is no longer
            desired.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.UnloadObject(XP.SDK.XPLM.ObjectRef)">
            <summary>
            <para>
            This routine marks an object as no longer being used by your plugin.
            Objects are reference counted: once no plugins are using an object, it is
            purged from memory. Make sure to call XPLMUnloadObject once for each
            successful call to XPLMLoadObject.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.LookupObjects(System.Byte*,System.Single,System.Single,,System.Void*)">
            <summary>
            <para>
            This routine looks up a virtual path in the library system and returns all
            matching elements. You provide a callback - one virtual path may match many
            objects in the library. XPLMLookupObjects returns the number of objects
            found.
            </para>
            <para>
            The latitude and longitude parameters specify the location the object will
            be used. The library system allows for scenery packages to only provide
            objects to certain local locations. Only objects that are allowed at the
            latitude/longitude you provide will be returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.LookupObjects(XP.SDK.Utf8String@,System.Single,System.Single,,System.Void*)">
            <summary>
            <para>
            This routine looks up a virtual path in the library system and returns all
            matching elements. You provide a callback - one virtual path may match many
            objects in the library. XPLMLookupObjects returns the number of objects
            found.
            </para>
            <para>
            The latitude and longitude parameters specify the location the object will
            be used. The library system allows for scenery packages to only provide
            objects to certain local locations. Only objects that are allowed at the
            latitude/longitude you provide will be returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.SceneryAPI.LookupObjects(System.ReadOnlySpan{System.Char}@,System.Single,System.Single,,System.Void*)">
            <summary>
            <para>
            This routine looks up a virtual path in the library system and returns all
            matching elements. You provide a callback - one virtual path may match many
            objects in the library. XPLMLookupObjects returns the number of objects
            found.
            </para>
            <para>
            The latitude and longitude parameters specify the location the object will
            be used. The library system allows for scenery packages to only provide
            objects to certain local locations. Only objects that are allowed at the
            latitude/longitude you provide will be returned.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.SetDatabCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.SetDatadCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.SetDatafCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.SetDataiCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.SetDatavfCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Interop.SetDataviCallback">
            <summary>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.GetSystemPath(System.Byte*)">
            <summary>
            <para>
            This function returns the full path to the X-System folder. Note that this
            is a directory path, so it ends in a trailing : or /.
            </para>
            <para>
            The buffer you pass should be at least 512 characters long.  The path is
            returned using the current native or OS path conventions.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.GetPrefsPath(System.Byte*)">
            <summary>
            <para>
            This routine returns a full path to a file that is within X-Plane's
            preferences directory. (You should remove the file name back to the last
            directory separator to get the preferences directory using
            XPLMExtractFileAndPath.)
            </para>
            <para>
            The buffer you pass should be at least 512 characters long.  The path is
            returned using the current native or OS path conventions.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.GetDirectorySeparator">
            <summary>
            <para>
            This routine returns a string with one char and a null terminator that is
            the directory separator for the current platform. This allows you to write
            code that concatinates directory paths without having to #ifdef for
            platform. The character returned will reflect the current file path mode.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.ExtractFileAndPath(System.Byte*)">
            <summary>
            <para>
            Given a full path to a file, this routine separates the path from the file.
            If the path is a partial directory (e.g. ends in : or
            \
            ) the trailing
            directory separator is removed. This routine works in-place; a pointer to
            the file part of the buffer is returned; the original buffer still starts
            with the path and is null terminated with no trailing separator.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.GetDirectoryContents(System.Byte*,System.Int32,System.Byte*,System.Int32,System.Byte**,System.Int32,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns a list of files in a directory (specified by a full
            path, no trailing : or
            \
            ). The output is returned as a list of NULL
            terminated strings. An index array (if specified) is filled with pointers
            into the strings. The last file is indicated by a zero-length string (and
            NULL in the indices). This routine will return 1 if you had capacity for
            all files or 0 if you did not. You can also skip a given number of files.
            </para>
            <para>
            * inDirectoryPath - a null terminated C string containing the full path to
            the directory with no trailing directory char.
            </para>
            <para>
            * inFirstReturn - the zero-based index of the first file in the directory
            to return. (Usually zero to fetch all in one pass.)
            </para>
            <para>
            * outFileNames - a buffer to receive a series of sequential null
            terminated C-string file names. A zero-length C string will be appended
            to the very end.
            </para>
            <para>
            * inFileNameBufSize - the size of the file name buffer in bytes.
            </para>
            <para>
            * outIndices - a pointer to an array of character pointers that will
            become an index into the directory. The last file will be followed by a
            NULL value. Pass NULL if you do not want indexing information.
            </para>
            <para>
            * inIndexCount - the max size of the index in entries.
            </para>
            <para>
            * outTotalFiles - if not NULL, this is filled in with the number of files
            in the directory.
            </para>
            <para>
            * outReturnedFiles - if not NULL, the number of files returned by this
            iteration.
            </para>
            <para>
            Return value: 1 if all info could be returned, 0 if there was a buffer
            overrun.
            </para>
            <para>
            WARNING: Before X-Plane 7 this routine did not properly iterate through
            directories. If X-Plane
            6 compatibility is needed, use your own code to iterate directories.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.GetDirectoryContents(XP.SDK.Utf8String@,System.Int32,System.Byte*,System.Int32,System.Byte**,System.Int32,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns a list of files in a directory (specified by a full
            path, no trailing : or
            \
            ). The output is returned as a list of NULL
            terminated strings. An index array (if specified) is filled with pointers
            into the strings. The last file is indicated by a zero-length string (and
            NULL in the indices). This routine will return 1 if you had capacity for
            all files or 0 if you did not. You can also skip a given number of files.
            </para>
            <para>
            * inDirectoryPath - a null terminated C string containing the full path to
            the directory with no trailing directory char.
            </para>
            <para>
            * inFirstReturn - the zero-based index of the first file in the directory
            to return. (Usually zero to fetch all in one pass.)
            </para>
            <para>
            * outFileNames - a buffer to receive a series of sequential null
            terminated C-string file names. A zero-length C string will be appended
            to the very end.
            </para>
            <para>
            * inFileNameBufSize - the size of the file name buffer in bytes.
            </para>
            <para>
            * outIndices - a pointer to an array of character pointers that will
            become an index into the directory. The last file will be followed by a
            NULL value. Pass NULL if you do not want indexing information.
            </para>
            <para>
            * inIndexCount - the max size of the index in entries.
            </para>
            <para>
            * outTotalFiles - if not NULL, this is filled in with the number of files
            in the directory.
            </para>
            <para>
            * outReturnedFiles - if not NULL, the number of files returned by this
            iteration.
            </para>
            <para>
            Return value: 1 if all info could be returned, 0 if there was a buffer
            overrun.
            </para>
            <para>
            WARNING: Before X-Plane 7 this routine did not properly iterate through
            directories. If X-Plane
            6 compatibility is needed, use your own code to iterate directories.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.GetDirectoryContents(System.ReadOnlySpan{System.Char}@,System.Int32,System.Byte*,System.Int32,System.Byte**,System.Int32,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns a list of files in a directory (specified by a full
            path, no trailing : or
            \
            ). The output is returned as a list of NULL
            terminated strings. An index array (if specified) is filled with pointers
            into the strings. The last file is indicated by a zero-length string (and
            NULL in the indices). This routine will return 1 if you had capacity for
            all files or 0 if you did not. You can also skip a given number of files.
            </para>
            <para>
            * inDirectoryPath - a null terminated C string containing the full path to
            the directory with no trailing directory char.
            </para>
            <para>
            * inFirstReturn - the zero-based index of the first file in the directory
            to return. (Usually zero to fetch all in one pass.)
            </para>
            <para>
            * outFileNames - a buffer to receive a series of sequential null
            terminated C-string file names. A zero-length C string will be appended
            to the very end.
            </para>
            <para>
            * inFileNameBufSize - the size of the file name buffer in bytes.
            </para>
            <para>
            * outIndices - a pointer to an array of character pointers that will
            become an index into the directory. The last file will be followed by a
            NULL value. Pass NULL if you do not want indexing information.
            </para>
            <para>
            * inIndexCount - the max size of the index in entries.
            </para>
            <para>
            * outTotalFiles - if not NULL, this is filled in with the number of files
            in the directory.
            </para>
            <para>
            * outReturnedFiles - if not NULL, the number of files returned by this
            iteration.
            </para>
            <para>
            Return value: 1 if all info could be returned, 0 if there was a buffer
            overrun.
            </para>
            <para>
            WARNING: Before X-Plane 7 this routine did not properly iterate through
            directories. If X-Plane
            6 compatibility is needed, use your own code to iterate directories.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.LoadDataFile(XP.SDK.XPLM.DataFileType,System.Byte*)">
            <summary>
            <para>
            Loads a data file of a given type. Paths must be relative to the X-System
            folder. To clear the replay, pass a NULL file name (this is only valid with
            replay movies, not sit files).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.LoadDataFile(XP.SDK.XPLM.DataFileType,XP.SDK.Utf8String@)">
            <summary>
            <para>
            Loads a data file of a given type. Paths must be relative to the X-System
            folder. To clear the replay, pass a NULL file name (this is only valid with
            replay movies, not sit files).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.LoadDataFile(XP.SDK.XPLM.DataFileType,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Loads a data file of a given type. Paths must be relative to the X-System
            folder. To clear the replay, pass a NULL file name (this is only valid with
            replay movies, not sit files).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.SaveDataFile(XP.SDK.XPLM.DataFileType,System.Byte*)">
            <summary>
            <para>
            Saves the current situation or replay; paths are relative to the X-System
            folder.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.SaveDataFile(XP.SDK.XPLM.DataFileType,XP.SDK.Utf8String@)">
            <summary>
            <para>
            Saves the current situation or replay; paths are relative to the X-System
            folder.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.SaveDataFile(XP.SDK.XPLM.DataFileType,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Saves the current situation or replay; paths are relative to the X-System
            folder.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.GetVersions(System.Int32*,System.Int32*,XP.SDK.XPLM.HostApplicationID*)">
            <summary>
            <para>
            This routine returns the revision of both X-Plane and the XPLM DLL. All
            versions are three-digit decimal numbers (e.g. 606 for version 6.06 of
            X-Plane); the current revision of the XPLM is 200 (2.00). This routine also
            returns the host ID of the app running us.
            </para>
            <para>
            The most common use of this routine is to special-case around X-Plane
            version-specific behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.GetLanguage">
            <summary>
            <para>
            This routine returns the langauge the sim is running in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.FindSymbol(System.Byte*)">
            <summary>
            <para>
            This routine will attempt to find the symbol passed in the inString
            parameter. If the symbol is found a pointer the function is returned,
            othewise the function will return NULL.
            </para>
            <para>
            You can use XPLMFindSymbol to utilize newer SDK API features without
            requiring newer versions of the SDK (and X-Plane) as your minimum X-Plane
            version as follows:
            </para>
            <para>
            * Define the XPLMnnn macro to the minimum required XPLM version you will
            ship with (e.g. XPLM210 for X-Plane 10 compatibility).
            </para>
            <para>
            * Use XPLMGetVersions and XPLMFindSymbol to detect that the host sim is
            new enough to use new functions and resolve function pointers.
            </para>
            <para>
            * Conditionally use the new functions if and only if XPLMFindSymbol only
            returns a non- NULL pointer.
            </para>
            <para>
            Warning: you should always check the XPLM API version as well as the
            results of XPLMFindSymbol to determine if funtionality is safe to use.
            </para>
            <para>
            To use functionality via XPLMFindSymbol you will need to copy your own
            definitions of the X-Plane API prototypes and cast the returned pointer to
            the correct type.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.FindSymbol(XP.SDK.Utf8String@)">
            <summary>
            <para>
            This routine will attempt to find the symbol passed in the inString
            parameter. If the symbol is found a pointer the function is returned,
            othewise the function will return NULL.
            </para>
            <para>
            You can use XPLMFindSymbol to utilize newer SDK API features without
            requiring newer versions of the SDK (and X-Plane) as your minimum X-Plane
            version as follows:
            </para>
            <para>
            * Define the XPLMnnn macro to the minimum required XPLM version you will
            ship with (e.g. XPLM210 for X-Plane 10 compatibility).
            </para>
            <para>
            * Use XPLMGetVersions and XPLMFindSymbol to detect that the host sim is
            new enough to use new functions and resolve function pointers.
            </para>
            <para>
            * Conditionally use the new functions if and only if XPLMFindSymbol only
            returns a non- NULL pointer.
            </para>
            <para>
            Warning: you should always check the XPLM API version as well as the
            results of XPLMFindSymbol to determine if funtionality is safe to use.
            </para>
            <para>
            To use functionality via XPLMFindSymbol you will need to copy your own
            definitions of the X-Plane API prototypes and cast the returned pointer to
            the correct type.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.FindSymbol(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine will attempt to find the symbol passed in the inString
            parameter. If the symbol is found a pointer the function is returned,
            othewise the function will return NULL.
            </para>
            <para>
            You can use XPLMFindSymbol to utilize newer SDK API features without
            requiring newer versions of the SDK (and X-Plane) as your minimum X-Plane
            version as follows:
            </para>
            <para>
            * Define the XPLMnnn macro to the minimum required XPLM version you will
            ship with (e.g. XPLM210 for X-Plane 10 compatibility).
            </para>
            <para>
            * Use XPLMGetVersions and XPLMFindSymbol to detect that the host sim is
            new enough to use new functions and resolve function pointers.
            </para>
            <para>
            * Conditionally use the new functions if and only if XPLMFindSymbol only
            returns a non- NULL pointer.
            </para>
            <para>
            Warning: you should always check the XPLM API version as well as the
            results of XPLMFindSymbol to determine if funtionality is safe to use.
            </para>
            <para>
            To use functionality via XPLMFindSymbol you will need to copy your own
            definitions of the X-Plane API prototypes and cast the returned pointer to
            the correct type.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.SetErrorCallback()">
            <summary>
            <para>
            XPLMSetErrorCallback installs an error-reporting callback for your plugin.
            Normally the plugin system performs minimum diagnostics to maximize
            performance. When you install an error callback, you will receive calls due
            to certain plugin errors, such as passing bad parameters or incorrect data.
            </para>
            <para>
            Important: the error callback determines *programming* errors, e.g. bad API
            parameters. Every error that is returned by the error callback represents a
            mistake in your plugin that you should fix. Error callbacks are not used to
            report expected run-time problems (e.g. disk I/O errors).
            </para>
            <para>
            The intention is for you to install the error callback during debug
            sections and put a break-point inside your callback. This will cause you to
            break into the debugger from within the SDK at the point in your plugin
            where you made an illegal call.
            </para>
            <para>
            Installing an error callback may activate error checking code that would
            not normally run, and this may adversely affect performance, so do not
            leave error callbacks installed in shipping plugins. Since the only useful
            response to an error is to change code, error callbacks are not useful "in
            the field".
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.DebugString(System.Byte*)">
            <summary>
            <para>
            This routine outputs a C-style string to the Log.txt file. The file is
            immediately flushed so you will not lose data. (This does cause a
            performance penalty.)
            </para>
            <para>
            Please do *not* leave routine diagnostic logging enabled in your shipping
            plugin. The X-Plane Log file is shared by X-Plane and every plugin in the
            system, and plugins that (when functioning normally) print verbose log
            output make it difficult for developers to find error conditions from other
            parts of the system.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.DebugString(XP.SDK.Utf8String@)">
            <summary>
            <para>
            This routine outputs a C-style string to the Log.txt file. The file is
            immediately flushed so you will not lose data. (This does cause a
            performance penalty.)
            </para>
            <para>
            Please do *not* leave routine diagnostic logging enabled in your shipping
            plugin. The X-Plane Log file is shared by X-Plane and every plugin in the
            system, and plugins that (when functioning normally) print verbose log
            output make it difficult for developers to find error conditions from other
            parts of the system.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.DebugString(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine outputs a C-style string to the Log.txt file. The file is
            immediately flushed so you will not lose data. (This does cause a
            performance penalty.)
            </para>
            <para>
            Please do *not* leave routine diagnostic logging enabled in your shipping
            plugin. The X-Plane Log file is shared by X-Plane and every plugin in the
            system, and plugins that (when functioning normally) print verbose log
            output make it difficult for developers to find error conditions from other
            parts of the system.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.SpeakString(System.Byte*)">
            <summary>
            <para>
            This function displays the string in a translucent overlay over the current
            display and also speaks the string if text-to-speech is enabled. The string
            is spoken asynchronously, this function returns immediately. This function
            may not speak or print depending on user preferences.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.SpeakString(XP.SDK.Utf8String@)">
            <summary>
            <para>
            This function displays the string in a translucent overlay over the current
            display and also speaks the string if text-to-speech is enabled. The string
            is spoken asynchronously, this function returns immediately. This function
            may not speak or print depending on user preferences.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.SpeakString(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This function displays the string in a translucent overlay over the current
            display and also speaks the string if text-to-speech is enabled. The string
            is spoken asynchronously, this function returns immediately. This function
            may not speak or print depending on user preferences.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.GetVirtualKeyDescription(System.Byte)">
            <summary>
            <para>
            Given a virtual key code (as defined in XPLMDefs.h) this routine returns a
            human-readable string describing the character. This routine is provided
            for showing users what keyboard mappings they have set up. The string may
            read 'unknown' or be a blank or NULL string if the virtual key is unknown.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.ReloadScenery">
            <summary>
            <para>
            XPLMReloadScenery reloads the current set of scenery. You can use this
            function in two typical ways: simply call it to reload the scenery, picking
            up any new installed scenery, .env files, etc. from disk. Or, change the
            lat/ref and lon/ref data refs and then call this function to shift the
            scenery environment.  This routine is equivalent to picking "reload
            scenery" from the developer menu.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.FindCommand(System.Byte*)">
            <summary>
            <para>
            XPLMFindCommand looks up a command by name, and returns its command
            reference or NULL if the command does not exist.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.FindCommand(XP.SDK.Utf8String@)">
            <summary>
            <para>
            XPLMFindCommand looks up a command by name, and returns its command
            reference or NULL if the command does not exist.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.FindCommand(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            XPLMFindCommand looks up a command by name, and returns its command
            reference or NULL if the command does not exist.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.CommandBegin(XP.SDK.XPLM.CommandRef)">
            <summary>
            <para>
            XPLMCommandBegin starts the execution of a command, specified by its
            command reference. The command is "held down" until XPLMCommandEnd is
            called.  You must balance each XPLMCommandBegin call with an XPLMCommandEnd
            call.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.CommandEnd(XP.SDK.XPLM.CommandRef)">
            <summary>
            <para>
            XPLMCommandEnd ends the execution of a given command that was started with
            XPLMCommandBegin.  You must not issue XPLMCommandEnd for a command you did
            not begin.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.CommandOnce(XP.SDK.XPLM.CommandRef)">
            <summary>
            <para>
            This executes a given command momentarily, that is, the command begins and
            ends immediately. This is the equivalent of calling XPLMCommandBegin() and
            XPLMCommandEnd() back ot back.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.CreateCommand(System.Byte*,System.Byte*)">
            <summary>
            <para>
            XPLMCreateCommand creates a new command for a given string. If the command
            already exists, the existing command reference is returned. The description
            may appear in user interface contexts, such as the joystick configuration
            screen.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.CreateCommand(XP.SDK.Utf8String@,XP.SDK.Utf8String@)">
            <summary>
            <para>
            XPLMCreateCommand creates a new command for a given string. If the command
            already exists, the existing command reference is returned. The description
            may appear in user interface contexts, such as the joystick configuration
            screen.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.CreateCommand(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            XPLMCreateCommand creates a new command for a given string. If the command
            already exists, the existing command reference is returned. The description
            may appear in user interface contexts, such as the joystick configuration
            screen.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.RegisterCommandHandler(XP.SDK.XPLM.CommandRef,,System.Int32,System.Void*)">
            <summary>
            <para>
            XPLMRegisterCommandHandler registers a callback to be called when a command
            is executed. You provide a callback with a reference pointer.
            </para>
            <para>
            If inBefore is true, your command handler callback will be executed before
            X-Plane executes the command, and returning 0 from your callback will
            disable X-Plane's processing of the command. If inBefore is false, your
            callback will run after X-Plane. (You can register a single callback both
            before and after a command.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Interop.UtilitiesAPI.UnregisterCommandHandler(XP.SDK.XPLM.CommandRef,,System.Int32,System.Void*)">
            <summary>
            <para>
            XPLMUnregisterCommandHandler removes a command callback registered with
            XPLMRegisterCommandHandler.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.KeyFlags">
            <summary>
            <para>
            These bitfields define modifier keys in a platform independent way. When a
            key is pressed, a series of messages are sent to your plugin.  The down
            flag is set in the first of these messages, and the up flag in the last.
            While the key is held down, messages are sent with neither to indicate that
            the key is being held down as a repeated character.
            </para>
            <para>
            The control flag is mapped to the control flag on Macintosh and PC.
            Generally X-Plane uses the control key and not the command key on
            Macintosh, providing a consistent interface across platforms that does not
            necessarily match the Macintosh user interface guidelines.  There is not
            yet a way for plugins to access the Macintosh control keys without using
            #ifdefed code.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.KeySniffer">
            <summary>
            Key sniffer provides low-level keyboard handlers.
            Allows for intercepting keystrokes outside the normal rules of the user interface.
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.KeySniffer.Callback">
            <summary>
            Key sniffer callback.
            </summary>
            <returns>
            Return <see langword="true"/> to pass the key on to the next sniffer, the window manager,
            X-Plane, or whomever is down stream.  Return <see langword="false"/> to consume the key.
            </returns>
        </member>
        <member name="M:XP.SDK.XPLM.KeySniffer.TryRegisterCallback(XP.SDK.XPLM.KeySniffer.Callback,System.Boolean)">
            <summary>
            <para>
            This routine registers a key sniffing callback.  You specify whether you
            want to sniff before the window system, or only sniff keys the window
            system does not consume.  You should ALMOST ALWAYS sniff non-control keys
            after the window system.  When the window system consumes a key, it is
            because the user has "focused" a window.  Consuming the key or taking
            action based on the key will produce very weird results.  
            </para>
            </summary>
            <returns>
            The <see cref="T:System.IDisposable"/> object, than you must use for unsubscription, if the subscription succeeds.
            <see langword="null"/> otherwise.
            </returns>
        </member>
        <member name="T:XP.SDK.XPLM.LanguageCode">
            <summary>
            <para>
            These enums define what language the sim is running in. These enumerations
            do not imply that the sim can or does run in all of these languages; they
            simply provide a known encoding in the event that a given sim version is
            localized to a certain language.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MagneticVariation">
            <summary>
            <para>
            Use the magnetic variation (more properly, the "magnetic declination") API to find the offset of magnetic north from true north at a given latitude and longitude within the simulator.
            </para>
            <para>
            In the real world, the Earths magnetic field is irregular, such that true north (the direction along a meridian toward the north pole) does not necessarily match what a magnetic compass shows as north.
            </para>
            <para>
            Using this API ensures that you present the same offsets to users as X-Planes built-in instruments.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.MagneticVariation.Get(System.Double,System.Double)">
            <summary>
            <para>
            Returns X-Plane's simulated magnetic variation (declination) at the
            indication latitude and longitude.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.MagneticVariation.TrueToMagnetic(System.Single)">
            <summary>
            <para>
            Converts a heading in degrees relative to true north into a value relative
            to magnetic north at the user's current location.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.MagneticVariation.MagneticToTrue(System.Single)">
            <summary>
            <para>
            Converts a heading in degrees relative to magnetic north at the user's
            current location into a value relative to true north.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.MapLayer.Dispose">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.XPLM.MapLayerID">
            <summary>
            <para>
            This is an opaque handle for a plugin-created map layer. Pass it to the map
            drawing APIs from an appropriate callback to draw in the layer you created.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MapLayerType">
            <summary>
            <para>
            Indicates the type of map layer you are creating. Fill layers will always
            be drawn beneath markings layers.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MapOrientation">
            <summary>
            <para>
            Indicates whether a map element should be match its rotation to the map
            itself, or to the user interface. For instance, the map itself may be
            rotated such that "up" matches the user's aircraft, but you may want to
            draw a text label such that it is always rotated zero degrees relative to
            the user's perspective. In that case, you would have it draw with UI
            orientation.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MapProjectionID">
            <summary>
            <para>
            This is an opaque handle for a map projection. Pass it to the projection
            APIs to translate between map coordinates and latitude/longitudes.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MapStyle">
            <summary>
            <para>
            Indicates the visual style being drawn by the map. In X-Plane, the user can
            choose between a number of map types, and different map types may have use
            a different visual representation for the same elements (for instance, the
            visual style of the terrain layer changes drastically between the VFR and
            IFR layers), or certain layers may be disabled entirely in some map types
            (e.g., localizers are only visible in the IFR low-enroute style).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.#ctor">
            <summary>
            Initializes a new top-level menu.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.Menu.Id">
            <summary>
            Gets the menu ID.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.Menu.Items">
            <summary>
            Gets the list of menu items.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.Menu.PluginsMenu">
            <summary>
            Gets the plug-in's menu, which is created for you at startup.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.Menu.AircraftMenu">
            <summary>
            Gets the aircraft menu for the currently-loaded aircraft,
            used for showing aircraft-specific commands.
            </summary>
            <remarks>
            <para>
            The aircraft menu is created by X-Plane at startup,
            but it remains hidden until it is populated via
            <see cref="M:XP.SDK.XPLM.Menu.AddItem(System.String,XP.SDK.XPLM.MenuItem@,XP.SDK.TypedEventHandler{XP.SDK.XPLM.MenuItem})"/>,
            <see cref="M:XP.SDK.XPLM.Menu.AddItem(System.String,System.Action{XP.SDK.XPLM.MenuItem})"/>,
            <see cref="M:XP.SDK.XPLM.Menu.AddItem(System.String,XP.SDK.XPLM.CommandRef,XP.SDK.XPLM.MenuItem@)"/>,
            <see cref="M:XP.SDK.XPLM.Menu.AddItem(System.String,XP.SDK.XPLM.CommandRef,System.Action{XP.SDK.XPLM.MenuItem})"/>,
            <see cref="M:XP.SDK.XPLM.Menu.AddItem(System.String,XP.SDK.XPLM.Command,XP.SDK.XPLM.MenuItem@)"/> or
            <see cref="M:XP.SDK.XPLM.Menu.AddItem(System.String,XP.SDK.XPLM.Command,System.Action{XP.SDK.XPLM.MenuItem})"/>.
            </para>
            <para>
            Only plugins loaded with the user's current aircraft are allowed to access
            the aircraft menu. For all other plugins, this will return <see langword="null"/>, and any
            attempts to add menu items to it will fail.
            </para>
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.AddItem(System.String,XP.SDK.XPLM.MenuItem@,XP.SDK.TypedEventHandler{XP.SDK.XPLM.MenuItem})">
            <summary>
            Adds a new menu item to the menu.
            </summary>
            <param name="name">The menu item display name.</param>
            <param name="item">The created menu item.</param>
            <param name="onClick">An optional Click event handler.</param>
            <returns>The current menu instance.</returns>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.AddItem(System.String,System.Action{XP.SDK.XPLM.MenuItem})">
            <summary>
            Adds a new menu item to the menu.
            </summary>
            <param name="name">The menu item display name.</param>
            <param name="config">The delegate that can be used to configure the created menu item.</param>
            <returns>The current menu instance.</returns>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.AddItem(System.String,XP.SDK.XPLM.CommandRef,XP.SDK.XPLM.MenuItem@)">
            <summary>
            Adds a new menu item to the menu.
            </summary>
            <param name="name">The menu item display name.</param>
            <param name="commandRef">The command to execute on item click.</param>
            <param name="item">The created menu item.</param>
            <returns>The current menu instance.</returns>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.AddItem(System.String,XP.SDK.XPLM.CommandRef,System.Action{XP.SDK.XPLM.MenuItem})">
            <summary>
            Adds a new menu item to the menu.
            </summary>
            <param name="name">The menu item display name.</param>
            <param name="commandRef">The command to execute on item click.</param>
            <param name="config">The delegate that can be used to configure the created menu item.</param>
            <returns>The current menu instance.</returns>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.AddItem(System.String,XP.SDK.XPLM.Command,XP.SDK.XPLM.MenuItem@)">
            <summary>
            Adds a new menu item to the menu.
            </summary>
            <param name="name">The menu item display name.</param>
            <param name="command">The command to execute on item click.</param>
            <param name="item">The created menu item.</param>
            <returns>The current menu instance.</returns>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.AddItem(System.String,XP.SDK.XPLM.Command,System.Action{XP.SDK.XPLM.MenuItem})">
            <summary>
            Adds a new menu item to the menu.
            </summary>
            <param name="name">The menu item display name.</param>
            <param name="command">The command to execute on item click.</param>
            <param name="config">The delegate that can be used to configure the created menu item.</param>
            <returns>The current menu instance.</returns>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.AddSeparator(XP.SDK.XPLM.MenuItem@)">
            <summary>
            Adds a new menu item separator.
            </summary>
            <param name="item">The created separator.</param>
            <returns>The current menu instance.</returns>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.AddSeparator">
            <summary>
            Adds a new menu item separator.
            </summary>
            <returns>The current menu instance.</returns>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.RemoveItem(System.Int32)">
            <summary>
            Removes the menu item by index.
            </summary>
            <param name="index">The index of the menu item to remove.</param>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.RemoveItem(XP.SDK.XPLM.MenuItem)">
            <summary>
            Removes the menu item.
            </summary>
            <param name="item">The menu item to remove.</param>
            <returns><see langword="true" /> if the item existed in the menu and was removed; <see langword="false" /> otherwise.</returns>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.ClearItems">
            <summary>
            Removes all menu items.
            </summary>
        </member>
        <member name="E:XP.SDK.XPLM.Menu.Click">
            <summary>
            Raised when the user clicks a menu item.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Menu.Dispose">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.XPLM.MenuCheck">
            <summary>
            <para>
            These enumerations define the various 'check' states for an X-Plane menu.
            'checking' in X-Plane actually appears as a light which may or may not be
            lit.  So there are three possible states.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MenuID">
            <summary>
            <para>
            This is a unique ID for each menu you create.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MenuItem">
            <summary>
            The menu item.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.MenuItem.Name">
            <summary>
            Gets or sets the menu item name.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.MenuItem.IsEnabled">
            <summary>
            Gets or sets the value indicating whether the menu item is enabled.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.MenuItem.CheckState">
            <summary>
            Gets or sets the check state of the menu.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.MenuItem.IsSeparator">
            <summary>
            Gets the value indicating whether the menu item is a separator.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.MenuItem.SubMenu">
            <summary>
            Gets the item's sub-menu.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.MenuItem.CreateSubMenu">
            <summary>
            Creates an item's sub-menu.
            </summary>
            <returns>The new item's sub-menu.</returns>
            <exception cref="T:System.InvalidOperationException">The item's sub-menu already exists.</exception>
            <exception cref="T:System.InvalidOperationException">The item is a separator.</exception>
        </member>
        <member name="M:XP.SDK.XPLM.MenuItem.GetOrCreateSubMenu">
            <summary>
            Gets or creates an item's sub-menu.
            </summary>
            <returns>The item's sub-menu.</returns>
            <exception cref="T:System.InvalidOperationException">The item is a separator.</exception>
        </member>
        <member name="M:XP.SDK.XPLM.MenuItem.DestroySubMenu">
            <summary>
            Destroys the item's sub-menu.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.MenuItem.UniqueId">
            <summary>
            Gets the item's sub-menu.
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MouseStatus">
            <summary>
            <para>
            When the mouse is clicked, your mouse click routine is called repeatedly.
            It is first called with the mouse down message.  It is then called zero or
            more times with the mouse-drag message, and finally it is called once with
            the mouse up message.  All of these messages will be directed to the same
            window; you are guaranteed to not receive a drag or mouse-up event without
            first receiving the corresponding mouse-down.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.NavRef">
            <summary>
            <para>
            XPLMNavRef is an iterator into the navigation database.  The navigation
            database is essentially an array, but it is not necessarily densely
            populated. The only assumption you can safely make is that like-typed
            nav-aids are grouped together.
            </para>
            <para>
            Use XPLMNavRef to refer to a nav-aid.
            </para>
            <para>
            XPLM_NAV_NOT_FOUND is returned by functions that return an XPLMNavRef when
            the iterator must be invalid.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.NavType">
            <summary>
            <para>
            These enumerations define the different types of navaids.  They are each
            defined with a separate bit so that they may be bit-wise added together to
            form sets of nav-aid types.
            </para>
            <para>
            NOTE: xplm_Nav_LatLon is a specific lat-lon coordinate entered into the
            FMS. It will not exist in the database, and cannot be programmed into the
            FMS. Querying the FMS for navaids will return it.  Use
            XPLMSetFMSEntryLatLon to set a lat/lon waypoint.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.ObjectRef">
            <summary>
            <para>
            An XPLMObjectRef is a opaque handle to an .obj file that has been loaded
            into memory.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.PluginID">
            <summary>
            <para>
            Each plug-in is identified by a unique integer ID.  This ID can be used to
            disable or enable a plug-in, or discover what plug-in is 'running' at the
            time.  A plug-in ID is unique within the currently running instance of
            X-Plane unless plug-ins are reloaded.  Plug-ins may receive a different
            unique ID each time they are loaded. This includes the unloading and
            reloading of plugins that are part of the user's aircraft.
            </para>
            <para>
            For persistent identification of plug-ins, use XPLMFindPluginBySignature in
            XPLMUtiltiies.h
            </para>
            <para>
            -1 indicates no plug-in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Probe.Dispose">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.XPLM.ProbeRef">
            <summary>
            <para>
            An XPLMProbeRef is an opaque handle to a probe, used for querying the
            terrain.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.ProbeResult">
            <summary>
            <para>
            Probe results - possible results from a probe query.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.ProbeType">
            <summary>
            <para>
            XPLMProbeType defines the type of terrain probe - each probe has a
            different algorithm. (Only one type of probe is provided right now, but
            future APIs will expose more flexible or poewrful or useful probes.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Screen">
            <summary>
            Provides information about the screen.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.Screen.BoundsGlobal">
            <summary>
            This property returns the bounds of the "global" X-Plane desktop, in boxels.
            It is multi-monitor aware. 
            </summary>
            <remarks>
            <para>
            There are three primary consequences of multimonitor awareness.
            </para>
            <para>
            First, if the user is running X-Plane in full-screen on two or more
            monitors (typically configured using one full-screen window per monitor),
            the global desktop will be sized to include all X-Plane windows.
            </para>
            <para>
            Second, the origin of the screen coordinates is not guaranteed to be (0,
            0). Suppose the user has two displays side-by-side, both running at 1080p.
            Suppose further that they've configured their OS to make the left display
            their "primary" monitor, and that X-Plane is running in full-screen on
            their right monitor only. In this case, the global desktop bounds would be
            the rectangle from (1920, 0) to (3840, 1080). If the user later asked
            X-Plane to draw on their primary monitor as well, the bounds would change
            to (0, 0) to (3840, 1080).
            </para>
            <para>
            Finally, if the usable area of the virtual desktop is not a perfect
            rectangle (for instance, because the monitors have different resolutions or
            because one monitor is configured in the operating system to be above and
            to the right of the other), the global desktop will include any wasted
            space. Thus, if you have two 1080p monitors, and monitor 2 is configured to
            have its bottom left touch monitor 1's upper right, your global desktop
            area would be the rectangle from (0, 0) to (3840, 2160).
            </para>
            <para>
            Note that popped-out windows (windows drawn in their own operating system
            windows, rather than "floating" within X-Plane) are not included in these
            bounds.
            </para>
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.Screen.AllMonitorBoundsGlobal">
            <summary>
            Gets the bounds (in boxels) of all full-screen X-Plane windows within the X-Plane global desktop space.
            </summary>
            <remarks>
            <para>
            Note  that if a monitor is *not* covered by an X-Plane window, you cannot get its
            bounds this way. Likewise, monitors with only an X-Plane window (not in
            full-screen mode) will not be included.
            </para>
            <para>
            If X-Plane is running in full-screen and your monitors are of the same size
            and configured contiguously in the OS, then the combined global bounds of
            all full-screen monitors will match the total global desktop bounds, as
            returned by <see cref="P:XP.SDK.XPLM.Screen.BoundsGlobal"/>. (Of course, if X-Plane is running
            in windowed mode, this will not be the case. Likewise, if you have
            differently sized monitors, the global desktop space will include wasted
            space.)
            </para>
            <para>
            Note that this function's monitor indices match those provided by
            <see cref="P:XP.SDK.XPLM.Screen.AllMonitorBoundsOS"/>, but the coordinates are different (since the
            X-Plane global desktop may not match the operating system's global desktop,
            and one X-Plane boxel may be larger than one pixel due to 150% or 200%
            scaling).
            </para>
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.Screen.AllMonitorBoundsOS">
            <summary>
            <para>
            This property returns the bounds (in pixels) of each
            monitor within the operating system's global desktop space. Note that
            unlike <see cref="P:XP.SDK.XPLM.Screen.AllMonitorBoundsGlobal"/>, this may include monitors that have
            no X-Plane window on them.
            </para>
            </summary>
            <remarks>
            <para>
            Note that this function's monitor indices match those provided by
            <see cref="P:XP.SDK.XPLM.Screen.AllMonitorBoundsGlobal"/>, but the coordinates are different (since
            the X-Plane global desktop may not match the operating system's global
            desktop, and one X-Plane boxel may be larger than one pixel).
            </para>
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.Screen.MouseLocationGlobal">
            <summary>
            Returns the current mouse location in global desktop boxels.
            </summary>
            <remarks>
            The bottom left of the main X-Plane window is not
            guaranteed to be (0, 0). Instead, the origin is the lower left of the
            entire global desktop space. In addition, this routine gives the real mouse
            location when the mouse goes to X-Plane windows other than the primary
            display. Thus, it can be used with both pop-out windows and secondary
            </remarks>
        </member>
        <member name="T:XP.SDK.XPLM.TextureID">
            <summary>
            <para>
            XPLM Texture IDs name well-known textures in the sim for you to use. This
            allows you to recycle textures from X-Plane, saving VRAM.
            </para>
            <para>
            *Warning*: do not use these enums.  The only remaining use they have is to
            access the legacy compatibility v10 UI texture; if you need this, get it
            via the Widgets library.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.User.SetAircraft(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Changes the users aircraft. Note that this will reinitialize the user to be on the nearest airports first runway.
            </summary>
            <param name="aircraftPath">A full path (hard drive and everything including the .acf extension) to the .acf file.</param>
        </member>
        <member name="M:XP.SDK.XPLM.User.PlaceAtAirport(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Places the user at a given airport.
            </summary>
            <param name="airportCode">The airport by its X-Plane airport ID (e.g. 'KBOS').</param>
        </member>
        <member name="M:XP.SDK.XPLM.User.PlaceAtLocation(System.Double,System.Double,System.Single,System.Single,System.Single)">
            <summary>
            Places the user at a specific location after performing any necessary scenery loads.
            </summary>
            <remarks>
            As with in-air starts initiated from the X-Plane user interface,
            the aircraft will always start with its engines running, regardless of the users preferences
            (i.e., regardless of what the dataref <c>sim/operation/prefs/startup_running</c> says).
            </remarks>
        </member>
        <member name="T:XP.SDK.XPLM.Window">
            <summary>
            Represents the modern (XPLM300) X-Plane window.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Window.#ctor(XP.SDK.Rect@,System.Boolean,XP.SDK.XPLM.WindowLayer,XP.SDK.XPLM.WindowDecoration,XP.SDK.XPLM.MouseHandlers)">
            <summary>
            Creates a new instance of Window.
            </summary>
            <param name="bounds">Window bounds in global desktop boxels.</param>
            <param name="visible">Window visibility.</param>
            <param name="layer">Window layer.</param>
            <param name="decoration">The type of X-Plane 11-style "wrapper" you want around your window, if any.</param>
            <param name="mouseHandlers">The mouse events, that the window must handle.</param>
        </member>
        <member name="M:XP.SDK.XPLM.Window.OnDrawWindow">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.XPLM.Window.OnMouseLeftButtonEvent(System.Int32,System.Int32,XP.SDK.XPLM.MouseStatus)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.XPLM.Window.OnMouseRightButtonEvent(System.Int32,System.Int32,XP.SDK.XPLM.MouseStatus)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.XPLM.Window.OnMouseWheelEvent(System.Int32,System.Int32,XP.SDK.XPLM.MouseWheel,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.XPLM.Window.OnKeyEvent(System.Byte,XP.SDK.XPLM.KeyFlags,System.Byte,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:XP.SDK.XPLM.Window.OnCursorRequested(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="E:XP.SDK.XPLM.Window.DrawWindow">
            <summary>
            Occurs when the window content must be drawn.
            </summary>
        </member>
        <member name="E:XP.SDK.XPLM.Window.MouseLeftButtonEvent">
            <summary>
            Occurs on left mouse button input event.
            </summary>
        </member>
        <member name="E:XP.SDK.XPLM.Window.MouseRightButtonEvent">
            <summary>
            Occurs on right mouse button input event.
            </summary>
        </member>
        <member name="E:XP.SDK.XPLM.Window.MouseWheelEvent">
            <summary>
            Occurs on mouse wheel input event.
            </summary>
        </member>
        <member name="E:XP.SDK.XPLM.Window.KeyEvent">
            <summary>
            Occurs on keyboard input event.
            </summary>
        </member>
        <member name="E:XP.SDK.XPLM.Window.CursorRequested">
            <summary>
            Occurs when the cursor for the current mouse coordinates is requested.
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.WindowBase">
            <summary>
            The base class for modern (XPLM300) X-Plane windows.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.#ctor(XP.SDK.Rect@,System.Boolean,XP.SDK.XPLM.WindowLayer,XP.SDK.XPLM.WindowDecoration,XP.SDK.XPLM.MouseHandlers)">
            <summary>
            Creates a new instance of WindowBase.
            </summary>
            <param name="bounds">Window bounds in global desktop boxels.</param>
            <param name="visible">Window visibility.</param>
            <param name="layer">Window layer.</param>
            <param name="decoration">The type of X-Plane 11-style "wrapper" you want around your window, if any.</param>
            <param name="mouseHandlers">The mouse events, that the window must handle.</param>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.HasKeyboardFocus">
            <summary>
            Gets the value indicating whether this window has keyboard focus.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.Id">
            <summary>
            Gets the window ID.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.IsInFront">
            <summary>
            Gets the value indicating whether the window is the frontmost
            visible window in its layer.
            </summary>
            <remarks>
            If you have a window at the front of the floating window layer
            (<see cref="F:XP.SDK.XPLM.WindowLayer.FloatingWindows"/>), this will return true even if there is a
            modal window (in layer <see cref="F:XP.SDK.XPLM.WindowLayer.Modal"/>) above you. (Not to worry,
            though: in such a case, X-Plane will not pass clicks or keyboard input down
            to your layer until the window above stops "eating" the input.)
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.IsInVirtualReality">
            <summary>
            True if this window has been moved to the virtual reality (VR) headset,
            which in turn is true if and only if you have set the window's positioning
            mode to <see cref="F:XP.SDK.XPLM.WindowPositioningMode.VR"/>.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.IsPoppedOut">
            <summary>
            True if this window has been popped out (making it a first-class window in
            the operating system), which in turn is true if and only if you have set
            the window's positioning mode to <see cref="F:XP.SDK.XPLM.WindowPositioningMode.PopOut"/>.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.IsVisible">
            <summary>
            Gets or sets the window visibility.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.Geometry">
            <summary>
            <para>Gets or sets the position and size of the windows.</para>
            <para>The units are global desktop boxels.</para>
            </summary>
            <remarks>
             <para>
            Note that the setter only applies to "floating" windows (that is, windows that
            are drawn within the X-Plane simulation windows, rather than being "popped
            out" into their own first-class operating system windows). To set the
            position of windows whose positioning mode is <see cref="F:XP.SDK.XPLM.WindowPositioningMode.PopOut"/>, you'll
            need to instead set <see cref="P:XP.SDK.XPLM.WindowBase.GeometryOS"/>.
            </para>
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.GeometryOS">
            <summary>
            <para>
            Gets or sets the position and size of a "popped out" window
            (i.e. a window whose positioning mode is <see cref="F:XP.SDK.XPLM.WindowPositioningMode.PopOut"/>).
            </para>
            <para>The unites are in operating system pixels.</para>
            </summary>
            <remarks>
            <para>
            If the window is not popped out, the property returns an empty rectangle.
            </para>
            <para>
            Note that when setting the value, you are responsible for ensuring that a monitor really exists at the
            OS coordinates you provide (using XPLMGetAllMonitorBoundsOS()).
            </para>
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.GeometryVR">
            <summary>
            Gets or sets the size, in boxels, of a window in VR.
            </summary>
            <remarks>
            <para>If the window is not in virtual reality, the property returns a zero size.</para>
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.Title">
            <summary>
            Gets or sets the window title.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.MouseLocationGlobal">
            <summary>
            Returns the current mouse location in global desktop boxels.
            </summary>
            <remarks>
            The bottom left of the main X-Plane window is not
            guaranteed to be (0, 0). Instead, the origin is the lower left of the
            entire global desktop space. In addition, this routine gives the real mouse
            location when the mouse goes to X-Plane windows other than the primary
            display. Thus, it can be used with both pop-out windows and secondary
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.WindowBase.XPlaneHasKeyboardFocus">
            <summary>
            Gets the value indicating if XPlane itself has the keyboard focus, and thus no window has focus.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.BringToFront">
            <summary>
            This routine brings the window to the front of the Z-order for its layer.
            Windows are brought to the front automatically when they are created.
            Beyond that, you should make sure you are front before handling mouse
            clicks.
            </summary>
            <remarks>
            Note that this only brings your window to the front of its layer
            (<see cref="T:XP.SDK.XPLM.WindowLayer"/>). Thus, if you have a window in the floating window layer
            (<see cref="F:XP.SDK.XPLM.WindowLayer.FloatingWindows"/>), but there is a modal window (in layer
            <see cref="F:XP.SDK.XPLM.WindowLayer.Modal"/>) above you, you would still not be the true frontmost
            window after calling this. (After all, the window layers are strictly
            ordered, and no window in a lower layer can ever be above any window in a
            higher one.)
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.ReleaseKeyboardFocus">
            <summary>
            Releases keyboard focus from this window.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.SetGravity(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Set the window gravity.
            </summary>
            <remarks>
            <para>
            A window's "gravity" controls how the window shifts as the whole X-Plane
            window resizes. A gravity of 1 means the window maintains its positioning
            relative to the right or top edges, 0 the left/bottom, and 0.5 keeps it
            centered.
            </para>
            <para>
            Default gravity is (0, 1, 0, 1), meaning your window will maintain its
            position relative to the top left and will not change size as its
            containing window grows.
            </para>
            <para>
            If you wanted, say, a window that sticks to the top of the screen (with a
            constant height), but which grows to take the full width of the window, you
            would pass (0, 1, 1, 1). Because your left and right edges would maintain
            their positioning relative to their respective edges of the screen, the
            whole width of your window would change with the X-Plane window.
            </para>
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.SetPositioningMode(XP.SDK.XPLM.WindowPositioningMode,System.Int32)">
            <summary>
            Sets the policy for how X-Plane will position your window.
            </summary>
            <remarks>
            <para>
            Some positioning modes apply to a particular monitor. For those modes, you
            can pass a negative monitor index to position the window on the main
            X-Plane monitor (the screen with the X-Plane menu bar at the top). Or, if
            you have a specific monitor you want to position your window on, you can
            pass a real monitor index as received from, e.g., <see cref="P:XP.SDK.XPLM.Screen.AllMonitorBoundsOS"/>.
            </para>
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.SetResizingLimits(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the minimum and maximum size of the client rectangle of the given
            window. (That is, it does not include any window styling that you might
            have asked X-Plane to apply on your behalf.) All resizing operations are
            constrained to these sizes.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.TakeKeyboardFocus">
            <summary>
            Gives the keyboard focus to this window.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.RemoveKeyboardFocus">
            <summary>
            Removes keyboard focus from currently focused window.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.FromId(XP.SDK.XPLM.WindowID)">
            <summary>
            Gets the window with the specified <paramref name="id"/>.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.OnDrawWindow">
            <summary>
            Override this method to handle drawing inside the window.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.OnMouseLeftButtonEvent(System.Int32,System.Int32,XP.SDK.XPLM.MouseStatus)">
            <summary>
            Override this method to handle mouse left button events.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.OnMouseRightButtonEvent(System.Int32,System.Int32,XP.SDK.XPLM.MouseStatus)">
            <summary>
            Override this method to handle mouse right button events.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.OnMouseWheelEvent(System.Int32,System.Int32,XP.SDK.XPLM.MouseWheel,System.Int32)">
            <summary>
            Override this method to handle mouse wheel button events.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.OnKeyEvent(System.Byte,XP.SDK.XPLM.KeyFlags,System.Byte,System.Boolean)">
            <summary>
            Override this method to handle keyboard events.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.OnCursorRequested(System.Int32,System.Int32)">
            <summary>
            Override this method to change the cursor depending on the mouse coordinates..
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.Dispose(System.Boolean)">
            <summary>
            Frees the resources allocated for this window.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.WindowBase.Dispose">
            <inheritdoc />
        </member>
        <member name="T:XP.SDK.XPLM.WindowDecoration">
            <summary>
            <para>
            XPLMWindowDecoration describes how "modern" windows will be displayed. This
            impacts both how X-Plane draws your window as well as certain mouse
            handlers.
            </para>
            <para>
            Your window's decoration can only be specified when you create the window
            (in the XPLMCreateWindow_t you pass to XPLMCreateWindowEx()).
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.WindowID">
            <summary>
            <para>
            This is an opaque identifier for a window.  You use it to control your
            window. When you create a window (via either XPLMCreateWindow() or
            XPLMCreateWindowEx()), you will specify callbacks to handle drawing, mouse
            interaction, etc.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.WindowLayer">
            <summary>
            <para>
            XPLMWindowLayer describes where in the ordering of windows X-Plane should
            place a particular window. Windows in higher layers cover windows in lower
            layers. So, a given window might be at the top of its particular layer, but
            it might still be obscured by a window in a higher layer. (This happens
            frequently when floating windows, like X-Plane's map, are covered by a
            modal alert.)
            </para>
            <para>
            Your window's layer can only be specified when you create the window (in
            the XPLMCreateWindow_t you pass to XPLMCreateWindowEx()). For this reason,
            layering only applies to windows created with new X-Plane 11 GUI features.
            (Windows created using the older XPLMCreateWindow(), or windows compiled
            against a pre-XPLM300 version of the SDK will simply be placed in the
            flight overlay window layer.)
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.WindowPositioningMode">
            <summary>
            <para>
            XPLMWindowPositionMode describes how X-Plane will position your window on
            the user's screen. X-Plane will maintain this positioning mode even as the
            user resizes their window or adds/removes full-screen monitors.
            </para>
            <para>
            Positioning mode can only be set for "modern" windows (that is, windows
            created using XPLMCreateWindowEx() and compiled against the XPLM300 SDK).
            Windows created using the deprecated XPLMCreateWindow(), or windows
            compiled against a pre-XPLM300 version of the SDK will simply get the
            "free" positioning mode.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.XPlane">
            <summary>
            Provides various utility functions of the X-Plane.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.XPlane.SystemPath">
            <summary>
            Gets the full path to the X-System folder.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.XPlane.PreferencesPath">
            <summary>
            Gets a full path to a file that is within X-Planes preferences directory.
            </summary>
            <remarks>
            You should remove the file name back to the last directory separator to get the preferences directory.
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.XPlane.Language">
            <summary>
            Returns the langauge the sim is running in.
            </summary>
        </member>
        <member name="P:XP.SDK.XPLM.XPlane.Version">
            <summary>
            Gets the version of X-Plane.
            </summary>
            <remarks>
            The version is a three- or four-digit decimal number, e.g. 1142 for version 11.42 of X-Plane.
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.XPlane.XplmVersion">
            <summary>
            Gets the version of the XPLM DLL.
            </summary>
            <remarks>
            The version is a three-digit decimal number, e.g. 300 for version 3.00 of XPLM.
            </remarks>
        </member>
        <member name="P:XP.SDK.XPLM.XPlane.HostApplication">
            <summary>
            Gets the host application ID.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.SetErrorCallback(System.Action{System.String})">
            <summary>
            <para>
            Installs an error-reporting callback for your plugin.
            Normally the plugin system performs minimum diagnostics to maximize
            performance. When you install an error callback, you will receive calls due
            to certain plugin errors, such as passing bad parameters or incorrect data.
            </para>
            <para>
            The intention is for you to install the error callback during debug
            sections and put a break-point inside your callback. This will cause you to
            break into the debugger from within the SDK at the point in your plugin
            where you made an illegal call.
            </para>
            <para>
            Installing an error callback may activate error checking code that would
            not normally run, and this may adversely affect performance, so do not
            leave error callbacks installed in shipping plugins.
            </para>
            <para>
            For this reason, it is recommended to use <seealso cref="M:XP.SDK.XPLM.XPlane.SetErrorCallbackForDebugBuild(System.Action{System.String})"/> instead.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.SetErrorCallbackForDebugBuild(System.Action{System.String})">
            <summary>
            <para>
            Installs an error-reporting callback for your plugin.
            Normally the plugin system performs minimum diagnostics to maximize
            performance. When you install an error callback, you will receive calls due
            to certain plugin errors, such as passing bad parameters or incorrect data.
            </para>
            <para>
            The intention is for you to install the error callback during debug
            sections and put a break-point inside your callback. This will cause you to
            break into the debugger from within the SDK at the point in your plugin
            where you made an illegal call.
            </para>
            <para>
            Installing an error callback may activate error checking code that would
            not normally run, and this may adversely affect performance, so do not
            leave error callbacks installed in shipping plugins.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.Speak(System.ReadOnlySpan{System.Char}@)">
            <summary>
            This function displays the string in a translucent overlay over the current display and also speaks the string if text-to-speech is enabled.
            The string is spoken asynchronously, this function returns immediately. This function may not speak or print depending on user preferences.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.FindSymbol(System.ReadOnlySpan{System.Char}@)">
            <summary>
            This routine will attempt to find the symbol passed in the <paramref name="name"/>
            parameter. If the symbol is found a pointer the function is returned,
            otherwise the function will return <seealso cref="F:System.IntPtr.Zero"/>.
            </summary>
            <remarks>
            <para>
            You can use FindSymbol to utilize newer SDK API features without requiring newer versions of the SDK (and X-Plane)
            as your minimum X-Plane version as follows:
            </para>
            <list type="bullet">
            <item>
            <description>
            Use <seealso cref="P:XP.SDK.XPLM.XPlane.Version"/>, <see cref="P:XP.SDK.XPLM.XPlane.XplmVersion"/> and <see cref="M:XP.SDK.XPLM.XPlane.FindSymbol(System.ReadOnlySpan{System.Char}@)"/> to detect that the host sim is new enough
            to use new functions and resolve function pointers.
            </description>
            </item>
            <item>
            <description>
            Conditionally use the new functions if and only if <see cref="M:XP.SDK.XPLM.XPlane.FindSymbol(System.ReadOnlySpan{System.Char}@)"/> returns a non-NULL pointer.
            </description>
            </item>
            </list>
            <para>
            Warning: you should always check the XPLM API version as well as the results of <see cref="M:XP.SDK.XPLM.XPlane.FindSymbol(System.ReadOnlySpan{System.Char}@)"/> to determine if functionality is safe to use.
            </para>
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.FindFunction``1(System.ReadOnlySpan{System.Char}@)">
            <summary>
            This routine will attempt to find the symbol passed in the <paramref name="name"/>
            parameter. If the symbol is found a delegate is returned,
            otherwise the function will return <seealso langword="null"/>.
            </summary>
            <remarks>
            <para>
            You can use FindSymbol to utilize newer SDK API features without requiring newer versions of the SDK (and X-Plane)
            as your minimum X-Plane version as follows:
            </para>
            <list type="bullet">
            <item>
            <description>
            Use <seealso cref="P:XP.SDK.XPLM.XPlane.Version"/>, <see cref="P:XP.SDK.XPLM.XPlane.XplmVersion"/> and <see cref="M:XP.SDK.XPLM.XPlane.FindFunction``1(System.ReadOnlySpan{System.Char}@)"/> to detect that the host sim is new enough
            to use new functions and resolve function pointers.
            </description>
            </item>
            <item>
            <description>
            Conditionally use the new functions if and only if <see cref="M:XP.SDK.XPLM.XPlane.FindFunction``1(System.ReadOnlySpan{System.Char}@)"/> returns a non-NULL pointer.
            </description>
            </item>
            </list>
            <para>
            Warning: you should always check the XPLM API version as well as the results of <see cref="M:XP.SDK.XPLM.XPlane.FindFunction``1(System.ReadOnlySpan{System.Char}@)"/> to determine if functionality is safe to use.
            </para>
            </remarks>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.LoadDataFile(XP.SDK.XPLM.DataFileType,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Loads a data file of a given type. Paths must be relative to the X-System folder.
            To clear the replay, pass <see langword="null"/> or <see langword="default"/> as the <paramref name="path"/>
            (this is only valid with replay movies, not sit files).
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.LoadDataFile(XP.SDK.XPLM.DataFileType,XP.SDK.Utf8String@)">
            <summary>
            Loads a data file of a given type. Paths must be relative to the X-System folder.
            To clear the replay, pass <see langword="null"/> or <see langword="default"/> as the <paramref name="path"/>
            (this is only valid with replay movies, not sit files).
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.SaveDataFile(XP.SDK.XPLM.DataFileType,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Saves the current situation or replay; paths are relative to the X-System folder.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.SaveDataFile(XP.SDK.XPLM.DataFileType,XP.SDK.Utf8String@)">
            <summary>
            Saves the current situation or replay; paths are relative to the X-System folder.
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.GetVirtualKeyDescription(System.Byte)">
            <summary>
            Given a virtual key code this routine returns a human-readable string describing the character.
            This routine is provided for showing users what keyboard mappings they have set up.
            The string may read 'unknown' or be an empty string if the virtual key is unknown.
            </summary>
            <param name="virtualKey"></param>
            <returns></returns>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.ReloadScenery">
            <summary>
            Reloads the current set of scenery.
            You can use this function in two typical ways: simply call it to reload the scenery,
            picking up any new installed scenery, .env files, etc. from disk.
            Or, change the lat/ref and lon/ref data refs and then call this function to shift the scenery environment.
            This routine is equivalent to picking "reload scenery" from the developer menu.
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.XPlane.Trace">
            <summary>
            Provides the methods to output string to the X-Plane's Log.txt file.
            </summary>
            <remarks>
            <para>
            Please do not leave routine diagnostic logging enabled in your shipping plugin.
            The X-Plane Log file is shared by X-Plane and every plugin in the system,
            and plugins that (when functioning normally) print verbose log output make it difficult for developers
            to find error conditions from other parts of the system.
            </para>
            <para>
            For most cases you should use <seealso cref="T:XP.SDK.XPLM.XPlane.Debug"/> which is no-op in Release builds.
            </para>
            </remarks>
            <seealso cref="T:XP.SDK.XPLM.XPlane.Debug"/>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.Trace.Write(System.ReadOnlySpan{System.Char}@)">
            <summary>
            This routine outputs a string to the Log.txt file.
            The file is immediately flushed so you will not lose data. (This does cause a performance penalty.)
            </summary>
            <remarks>
            <para>
            Please do not leave routine diagnostic logging enabled in your shipping plugin.
            The X-Plane Log file is shared by X-Plane and every plugin in the system,
            and plugins that (when functioning normally) print verbose log output make it difficult for developers
            to find error conditions from other parts of the system.
            </para>
            <para>
            For most cases you should use <seealso cref="M:XP.SDK.XPLM.XPlane.Debug.Write(System.ReadOnlySpan{System.Char}@)"/> which is no-op in Release builds.
            </para>
            </remarks>
            <seealso cref="T:XP.SDK.XPLM.XPlane.Debug"/>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.Trace.Write(XP.SDK.Utf8String@)">
            <summary>
            This routine outputs a string to the Log.txt file.
            The file is immediately flushed so you will not lose data. (This does cause a performance penalty.)
            </summary>
            <remarks>
            <para>
            Please do not leave routine diagnostic logging enabled in your shipping plugin.
            The X-Plane Log file is shared by X-Plane and every plugin in the system,
            and plugins that (when functioning normally) print verbose log output make it difficult for developers
            to find error conditions from other parts of the system.
            </para>
            <para>
            For most cases you should use <seealso cref="M:XP.SDK.XPLM.XPlane.Debug.Write(System.ReadOnlySpan{System.Char}@)"/> which is no-op in Release builds.
            </para>
            </remarks>
            <seealso cref="T:XP.SDK.XPLM.XPlane.Debug"/>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.Trace.WriteLine(System.ReadOnlySpan{System.Char}@)">
            <summary>
            This routine outputs a string to the Log.txt file.
            The file is immediately flushed so you will not lose data. (This does cause a performance penalty.)
            </summary>
            <remarks>
            <para>
            Please do not leave routine diagnostic logging enabled in your shipping plugin.
            The X-Plane Log file is shared by X-Plane and every plugin in the system,
            and plugins that (when functioning normally) print verbose log output make it difficult for developers
            to find error conditions from other parts of the system.
            </para>
            <para>
            For most cases you should use <seealso cref="M:XP.SDK.XPLM.XPlane.Debug.WriteLine(System.ReadOnlySpan{System.Char}@)"/> which is no-op in Release builds.
            </para>
            </remarks>
            <seealso cref="T:XP.SDK.XPLM.XPlane.Debug"/>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.Trace.WriteLine(XP.SDK.Utf8String@)">
            <summary>
            This routine outputs a string to the Log.txt file.
            The file is immediately flushed so you will not lose data. (This does cause a performance penalty.)
            </summary>
            <remarks>
            <para>
            Please do not leave routine diagnostic logging enabled in your shipping plugin.
            The X-Plane Log file is shared by X-Plane and every plugin in the system,
            and plugins that (when functioning normally) print verbose log output make it difficult for developers
            to find error conditions from other parts of the system.
            </para>
            <para>
            For most cases you should use <seealso cref="M:XP.SDK.XPLM.XPlane.Debug.WriteLine(System.ReadOnlySpan{System.Char}@)"/> which is no-op in Release builds.
            </para>
            </remarks>
            <seealso cref="T:XP.SDK.XPLM.XPlane.Debug"/>
        </member>
        <member name="T:XP.SDK.XPLM.XPlane.Debug">
            <summary>
            Provides the methods to output string to the X-Plane's Log.txt file.
            </summary>
            <remarks>
            This method is no-op if DEBUG is not defined.
            </remarks>
            <seealso cref="T:XP.SDK.XPLM.XPlane.Trace" />
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.Debug.Write(System.ReadOnlySpan{System.Char}@)">
            <summary>
            This routine outputs a string to the Log.txt file.
            The file is immediately flushed so you will not lose data. (This does cause a performance penalty.)
            </summary>
            <remarks>
            This method is no-op if DEBUG is not defined.
            </remarks>
            <seealso cref="M:XP.SDK.XPLM.XPlane.Debug.WriteLine(System.ReadOnlySpan{System.Char}@)"/>
            <seealso cref="T:XP.SDK.XPLM.XPlane.Trace"/>
        </member>
        <member name="M:XP.SDK.XPLM.XPlane.Debug.WriteLine(System.ReadOnlySpan{System.Char}@)">
            <summary>
            This routine outputs a string to the Log.txt file.
            The file is immediately flushed so you will not lose data. (This does cause a performance penalty.)
            </summary>
            <remarks>
            This method is no-op if DEBUG is not defined.
            </remarks>
            <seealso cref="M:XP.SDK.XPLM.XPlane.Debug.Write(System.ReadOnlySpan{System.Char}@)"/>
            <seealso cref="T:XP.SDK.XPLM.XPlane.Trace"/>
        </member>
    </members>
</doc>
