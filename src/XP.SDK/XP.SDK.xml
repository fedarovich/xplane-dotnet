<?xml version="1.0"?>
<doc>
    <assembly>
        <name>XP.SDK</name>
    </assembly>
    <members>
        <member name="T:XP.SDK.Widgets.DispatchMode">
            <summary>
            <para>
            The dispatching modes describe how the widgets library sends out messages.
            Currently there are three modes:
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.ElementStyle">
            <summary>
            <para>
            Elements are individually drawable UI things like push buttons, etc. The
            style defines what kind of element you are drawing. Elements can be
            stretched in one or two dimensions (depending on the element). Some
            elements can be lit.
            </para>
            <para>
            In X-Plane 6 some elements must be drawn over metal. Some are scalable and
            some are not. Any element can be drawn anywhere in X-Plane 7.
            </para>
            <para>
            Scalable Axis Required Background
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Internal.KeyState">
            <summary>
            <para>
            When a key is pressed, a pointer to this struct is passed to your widget
            function.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Internal.MouseState">
            <summary>
            <para>
            When the mouse is clicked or dragged, a pointer to this structure is passed
            to your widget function.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.UIGraphics.DrawWindow(System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.Widgets.WindowStyle)">
            <summary>
            <para>
            This routine draws a window of the given dimensions at the given offset on
            the virtual screen in a given style. The window is automatically scaled as
            appropriate using a bitmap scaling technique (scaling or repeating) as
            appropriate to the style.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.UIGraphics.GetWindowDefaultDimensions(XP.SDK.Widgets.WindowStyle,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the default dimensions for a window. Output is either
            a minimum or fixed value depending on whether the window is scalable.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.UIGraphics.DrawElement(System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.Widgets.ElementStyle,System.Int32)">
            <summary>
            <para>
            XPDrawElement draws a given element at an offset on the virtual screen in
            set dimensions. EVEN if the element is not scalable, it will be scaled if
            the width and height do not match the preferred dimensions; it'll just look
            ugly. Pass inLit to see the lit version of the element; if the element
            cannot be lit this is ignored.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.UIGraphics.GetElementDefaultDimensions(XP.SDK.Widgets.ElementStyle,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the recommended or minimum dimensions of a given UI
            element. outCanBeLit tells whether the element has both a lit and unlit
            state. Pass NULL to not receive any of these parameters.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.UIGraphics.DrawTrack(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.Widgets.TrackStyle,System.Int32)">
            <summary>
            <para>
            This routine draws a track. You pass in the track dimensions and size; the
            track picks the optimal orientation for these dimensions. Pass in the
            track's minimum current and maximum values; the indicator will be
            positioned appropriately. You can also specify whether the track is lit or
            not.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.UIGraphics.GetTrackDefaultDimensions(XP.SDK.Widgets.TrackStyle,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns a track's default smaller dimension; all tracks are
            scalable in the larger dimension. It also returns whether a track can be
            lit.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.UIGraphics.GetTrackMetrics(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.Widgets.TrackStyle,System.Int32*,System.Int32*,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the metrics of a track. If you want to write UI code
            to manipulate a track, this routine helps you know where the mouse
            locations are. For most other elements, the rectangle the element is drawn
            in is enough information. However, the scrollbar drawing routine does some
            automatic placement; this routine lets you know where things ended up. You
            pass almost everything you would pass to the draw routine. You get out the
            orientation, and other useful stuff.
            </para>
            <para>
            Besides orientation, you get five dimensions for the five parts of a
            scrollbar, which are the down button, down area (area before the thumb),
            the thumb, and the up area and button. For horizontal scrollers, the left
            button decreases; for vertical scrollers, the top button decreases.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Internal.WidgetClass">
            <summary>
            <para>
            Widget classes define predefined widget types. A widget class basically
            specifies from a library the widget function to be used for the widget.
            Most widgets can be made right from classes.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Internal.WidgetCreate">
            <summary>
            <para>
            This structure contains all of the parameters needed to create a wiget. It
            is used with XPUCreateWidgets to create widgets in bulk from an array. All
            parameters correspond to those of XPCreateWidget except for the container
            index. If the container index is equal to the index of a widget in the
            array, the widget in the array passed to XPUCreateWidgets is used as the
            parent of this widget. Note that if you pass an index greater than your own
            position in the array, the parent you are requesting will not exist yet. If
            the container index is NO_PARENT, the parent widget is specified as NULL.
            If the container index is PARAM_PARENT, the widget passed into
            XPUCreateWidgets is used.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Internal.WidgetFuncCallback">
            <summary>
            <para>
            This function defines your custom widget's behavior. It will be called by
            the widgets library to send messages to your widget. The message and widget
            ID are passed in, as well as two ptr-width signed parameters whose meaning
            varies with the message. Return 1 to indicate that you have processed the
            message, 0 to indicate that you have not. For any message that is not
            understood, return 0.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Internal.WidgetGeometryChange">
            <summary>
            <para>
            This structure contains the deltas for your widget's geometry when it
            changes.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.Internal.WidgetID">
            <summary>
            <para>
            A Widget ID is an opaque unique non-zero handle identifying your widget.
            Use 0 to specify "no widget". This type is defined as wide enough to hold a
            pointer. You receive a widget ID when you create a new widget and then use
            that widget ID to further refer to the widget.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.CreateWidget(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte*,System.Int32,XP.SDK.Widgets.Internal.WidgetID,XP.SDK.Widgets.Internal.WidgetClass)">
            <summary>
            <para>
            This function creates a new widget and returns the new widget's ID to you.
            If the widget creation fails for some reason, it returns NULL. Widget
            creation will fail either if you pass a bad class ID or if there is not
            adequate memory.
            </para>
            <para>
            Input Parameters:
            </para>
            <para>
            - Top, left, bottom, and right in global screen coordinates defining the
            widget's location on the screen.
            </para>
            <para>
            - inVisible is 1 if the widget should be drawn, 0 to start the widget as
            hidden.
            </para>
            <para>
            - inDescriptor is a null terminated string that will become the widget's
            descriptor.
            </para>
            <para>
            - inIsRoot is 1 if this is going to be a root widget, 0 if it will not be.
            </para>
            <para>
            - inContainer is the ID of this widget's container. It must be 0 for a root
            widget. for a non-root widget, pass the widget ID of the widget to place
            this widget within. If this widget is not going to start inside another
            widget, pass 0; this new widget will then just be floating off in space
            (and will not be drawn until it is placed in a widget.
            </para>
            <para>
            - inClass is the class of the widget to draw. Use one of the predefined
            class-IDs to create a standard widget.
            </para>
            <para>
            A note on widget embedding: a widget is only called (and will be drawn,
            etc.) if it is placed within a widget that will be called. Root widgets are
            always called. So it is possible to have whole chains of widgets that are
            simply not called. You can preconstruct widget trees and then place them
            into root widgets later to activate them if you wish.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.CreateWidget(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{System.Char}@,System.Int32,XP.SDK.Widgets.Internal.WidgetID,XP.SDK.Widgets.Internal.WidgetClass)">
            <summary>
            <para>
            This function creates a new widget and returns the new widget's ID to you.
            If the widget creation fails for some reason, it returns NULL. Widget
            creation will fail either if you pass a bad class ID or if there is not
            adequate memory.
            </para>
            <para>
            Input Parameters:
            </para>
            <para>
            - Top, left, bottom, and right in global screen coordinates defining the
            widget's location on the screen.
            </para>
            <para>
            - inVisible is 1 if the widget should be drawn, 0 to start the widget as
            hidden.
            </para>
            <para>
            - inDescriptor is a null terminated string that will become the widget's
            descriptor.
            </para>
            <para>
            - inIsRoot is 1 if this is going to be a root widget, 0 if it will not be.
            </para>
            <para>
            - inContainer is the ID of this widget's container. It must be 0 for a root
            widget. for a non-root widget, pass the widget ID of the widget to place
            this widget within. If this widget is not going to start inside another
            widget, pass 0; this new widget will then just be floating off in space
            (and will not be drawn until it is placed in a widget.
            </para>
            <para>
            - inClass is the class of the widget to draw. Use one of the predefined
            class-IDs to create a standard widget.
            </para>
            <para>
            A note on widget embedding: a widget is only called (and will be drawn,
            etc.) if it is placed within a widget that will be called. Root widgets are
            always called. So it is possible to have whole chains of widgets that are
            simply not called. You can preconstruct widget trees and then place them
            into root widgets later to activate them if you wish.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.CreateCustomWidget(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte*,System.Int32,XP.SDK.Widgets.Internal.WidgetID,XP.SDK.Widgets.Internal.WidgetFuncCallback)">
            <summary>
            <para>
            This function is the same as XPCreateWidget except that instead of passing
            a class ID, you pass your widget callback function pointer defining the
            widget. Use this function to define a custom widget. All parameters are the
            same as XPCreateWidget, except that the widget class has been replaced with
            the widget function.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.CreateCustomWidget(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{System.Char}@,System.Int32,XP.SDK.Widgets.Internal.WidgetID,XP.SDK.Widgets.Internal.WidgetFuncCallback)">
            <summary>
            <para>
            This function is the same as XPCreateWidget except that instead of passing
            a class ID, you pass your widget callback function pointer defining the
            widget. Use this function to define a custom widget. All parameters are the
            same as XPCreateWidget, except that the widget class has been replaced with
            the widget function.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.DestroyWidget(XP.SDK.Widgets.Internal.WidgetID,System.Int32)">
            <summary>
            <para>
            This class destroys a widget. Pass in the ID of the widget to kill. If you
            pass 1 for inDestroyChilren, the widget's children will be destroyed first,
            then this widget will be destroyed. (Furthermore, the widget's children
            will be destroyed with the inDestroyChildren flag set to 1, so the
            destruction will recurse down the widget tree.) If you pass 0 for this
            flag, the child widgets will simply end up with their parent set to 0.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.SendMessageToWidget(XP.SDK.Widgets.Internal.WidgetID,XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.DispatchMode,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            This sends any message to a widget. You should probably not go around
            simulating the predefined messages that the widgets library defines for
            you. You may however define custom messages for your widgets and send them
            with this method.
            </para>
            <para>
            This method supports several dispatching patterns; see XPDispatchMode for
            more info. The function returns 1 if the message was handled, 0 if it was
            not.
            </para>
            <para>
            For each widget that receives the message (see the dispatching modes), each
            widget function from the most recently installed to the oldest one receives
            the message in order until it is handled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.PlaceWidgetWithin(XP.SDK.Widgets.Internal.WidgetID,XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            This function changes which container a widget resides in. You may NOT use
            this function on a root widget! inSubWidget is the widget that will be
            moved. Pass a widget ID in inContainer to make inSubWidget be a child of
            inContainer. It will become the last/closest widget in the container. Pass
            0 to remove the widget from any container. Any call to this other than
            passing the widget ID of the old parent of the affected widget will cause
            the widget to be removed from its old parent. Placing a widget within its
            own parent simply makes it the last widget.
            </para>
            <para>
            NOTE: this routine does not reposition the sub widget in global
            coordinates. If the container has layout management code, it will
            reposition the subwidget for you, otherwise you must do it with
            SetWidgetGeometry.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.CountChildWidgets(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            This routine returns the number of widgets another widget contains.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.GetNthChildWidget(XP.SDK.Widgets.Internal.WidgetID,System.Int32)">
            <summary>
            <para>
            This routine returns the widget ID of a child widget by index. Indexes are
            0 based, from 0 to one minus the number of widgets in the parent,
            inclusive. If the index is invalid, 0 is returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.GetParentWidget(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            This routine returns the parent of a widget, or 0 if the widget has no
            parent. Root widgets never have parents and therefore always return 0.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.ShowWidget(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            This routine makes a widget visible if it is not already. Note that if a
            widget is not in a rooted widget hierarchy or one of its parents is not
            visible, it will still not be visible to the user.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.HideWidget(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            Makes a widget invisible. See XPShowWidget for considerations of when a
            widget might not be visible despite its own visibility state.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.IsWidgetVisible(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            This returns 1 if a widget is visible, 0 if it is not. Note that this
            routine takes into consideration whether a parent is invisible. Use this
            routine to tell if the user can see the widget.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.FindRootWidget(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            XPFindRootWidget returns the Widget ID of the root widget that contains the
            passed in widget or NULL if the passed in widget is not in a rooted
            hierarchy.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.BringRootWidgetToFront(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            This routine makes the specified widget be in the front most widget
            hierarchy. If this widget is a root widget, its widget hierarchy comes to
            front, otherwise the widget's root is brought to the front. If this widget
            is not in an active widget hiearchy (e.g. there is no root widget at the
            top of the tree), this routine does nothing.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.IsWidgetInFront(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            This routine returns true if this widget's hierarchy is the front most
            hierarchy. It returns false if the widget's hierarchy is not in front, or
            if the widget is not in a rooted hierarchy.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.GetWidgetGeometry(XP.SDK.Widgets.Internal.WidgetID,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the bounding box of a widget in global coordinates.
            Pass NULL for any parameter you are not interested in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.SetWidgetGeometry(XP.SDK.Widgets.Internal.WidgetID,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            This function changes the bounding box of a widget.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.GetWidgetForLocation(XP.SDK.Widgets.Internal.WidgetID,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Given a widget and a location, this routine returns the widget ID of the
            child of that widget that owns that location. If inRecursive is true then
            this will return a child of a child of a widget as it tries to find the
            deepest widget at that location. If inVisibleOnly is true, then only
            visible widgets are considered, otherwise all widgets are considered. The
            widget ID passed for inContainer will be returned if the location is in
            that widget but not in a child widget. 0 is returned if the location is not
            in the container.
            </para>
            <para>
            NOTE: if a widget's geometry extends outside its parents geometry, it will
            not be returned by this call for mouse locations outside the parent
            geometry. The parent geometry limits the child's eligibility for mouse
            location.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.GetWidgetExposedGeometry(XP.SDK.Widgets.Internal.WidgetID,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the bounds of the area of a widget that is completely
            within its parent widgets. Since a widget's bounding box can be outside its
            parent, part of its area will not be elligible for mouse clicks and should
            not draw. Use XPGetWidgetGeometry to find out what area defines your
            widget's shape, but use this routine to find out what area to actually draw
            into. Note that the widget library does not use OpenGL clipping to keep
            frame rates up, although you could use it internally.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.SetWidgetDescriptor(XP.SDK.Widgets.Internal.WidgetID,System.Byte*)">
            <summary>
            <para>
            Every widget has a descriptor, which is a text string. What the text string
            is used for varies from widget to widget; for example, a push button's text
            is its descriptor, a caption shows its descriptor, and a text field's
            descriptor is the text being edited. In other words, the usage for the text
            varies from widget to widget, but this API provides a universal and
            convenient way to get at it. While not all UI widgets need their
            descriptor, many do.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.SetWidgetDescriptor(XP.SDK.Widgets.Internal.WidgetID,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Every widget has a descriptor, which is a text string. What the text string
            is used for varies from widget to widget; for example, a push button's text
            is its descriptor, a caption shows its descriptor, and a text field's
            descriptor is the text being edited. In other words, the usage for the text
            varies from widget to widget, but this API provides a universal and
            convenient way to get at it. While not all UI widgets need their
            descriptor, many do.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.GetWidgetDescriptor(XP.SDK.Widgets.Internal.WidgetID,System.Byte*,System.Int32)">
            <summary>
            <para>
            This routine returns the widget's descriptor. Pass in the length of the
            buffer you are going to receive the descriptor in. The descriptor will be
            null terminated for you. This routine returns the length of the actual
            descriptor; if you pass NULL for outDescriptor, you can get the
            descriptor's length without getting its text. If the length of the
            descriptor exceeds your buffer length, the buffer will not be null
            terminated (this routine has 'strncpy' semantics).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.GetWidgetUnderlyingWindow(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            Returns the window (from the XPLMDisplay API) that backs your widget
            window. If you have opted in to modern windows, via a call to
            XPLMEnableFeature("XPLM_USE_NATIVE_WIDGET_WINDOWS", 1), you can use the
            returned window ID for display APIs like XPLMSetWindowPositioningMode(),
            allowing you to pop the widget window out into a real OS window, or move it
            into VR.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.SetWidgetProperty(XP.SDK.Widgets.Internal.WidgetID,XP.SDK.Widgets.WidgetPropertyID,System.IntPtr)">
            <summary>
            <para>
            This function sets a widget's property. Properties are arbitrary values
            associated by a widget by ID.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.GetWidgetProperty(XP.SDK.Widgets.Internal.WidgetID,XP.SDK.Widgets.WidgetPropertyID,System.Int32*)">
            <summary>
            <para>
            This routine returns the value of a widget's property, or 0 if the property
            is not defined. If you need to know whether the property is defined, pass a
            pointer to an int for inExists; the existence of that property will be
            returned in the int. Pass NULL for inExists if you do not need this
            information.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.SetKeyboardFocus(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            XPSetKeyboardFocus controls which widget will receive keystrokes. Pass the
            Widget ID of the widget to get the keys. Note that if the widget does not
            care about keystrokes, they will go to the parent widget, and if no widget
            cares about them, they go to X-Plane.
            </para>
            <para>
            If you set the keyboard focus to Widget ID 0, X-Plane gets keyboard focus.
            </para>
            <para>
            This routine returns the widget ID that ended up with keyboard focus, or 0
            for X-Plane.
            </para>
            <para>
            Keyboard focus is not changed if the new widget will not accept it. For
            setting to X-Plane, keyboard focus is always accepted.
            </para>
            <para>
            *
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.LoseKeyboardFocus(XP.SDK.Widgets.Internal.WidgetID)">
            <summary>
            <para>
            This causes the specified widget to lose focus; focus is passed to its
            parent, or the next parent that will accept it. This routine does nothing
            if this widget does not have focus.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.GetWidgetWithFocus">
            <summary>
            <para>
            This routine returns the widget that has keyboard focus, or 0 if X-Plane
            has keyboard focus or some other plugin window that does not have widgets
            has focus.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.AddWidgetCallback(XP.SDK.Widgets.Internal.WidgetID,XP.SDK.Widgets.Internal.WidgetFuncCallback)">
            <summary>
            <para>
            This function adds a new widget callback to a widget. This widget callback
            supercedes any existing ones and will receive messages first; if it does
            not handle messages they will go on to be handled by pre-existing widgets.
            </para>
            <para>
            The widget function will remain on the widget for the life of the widget.
            The creation message will be sent to the new callback immediately with the
            widget ID, and the destruction message will be sent before the other widget
            function receives a destruction message.
            </para>
            <para>
            This provides a way to 'subclass' an existing widget. By providing a second
            hook that only handles certain widget messages, you can customize or extend
            widget behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.Widgets.GetWidgetClassFunc(XP.SDK.Widgets.Internal.WidgetClass)">
            <summary>
            <para>
            Given a widget class, this function returns the callbacks that power that
            widget class.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.WidgetUtils.CreateWidgets(XP.SDK.Widgets.Internal.WidgetCreate*,System.Int32,XP.SDK.Widgets.Internal.WidgetID,XP.SDK.Widgets.Internal.WidgetID*)">
            <summary>
            <para>
            This function creates a series of widgets from a table...see
            XPCreateWidget_t above. Pass in an array of widget creation structures and
            an array of widget IDs that will receive each widget.
            </para>
            <para>
            Widget parents are specified by index into the created widget table,
            allowing you to create nested widget structures. You can create multiple
            widget trees in one table. Generally you should create widget trees from
            the top down.
            </para>
            <para>
            You can also pass in a widget ID that will be used when the widget's parent
            is listed as PARAM_PARENT; this allows you to embed widgets created with
            XPUCreateWidgets in a widget created previously.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.WidgetUtils.MoveWidgetBy(XP.SDK.Widgets.Internal.WidgetID,System.Int32,System.Int32)">
            <summary>
            <para>
            Simply moves a widget by an amount, +x = right, +y=up, without resizing the
            widget.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.WidgetUtils.FixedLayout(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Internal.WidgetID,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            This function causes the widget to maintain its children in fixed position
            relative to itself as it is resized. Use this on the top level 'window'
            widget for your window.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.WidgetUtils.SelectIfNeeded(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Internal.WidgetID,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            <para>
            This causes the widget to bring its window to the foreground if it is not
            already. inEatClick specifies whether clicks in the background should be
            consumed by bringin the window to the foreground.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.WidgetUtils.DefocusKeyboard(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Internal.WidgetID,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            <para>
            This causes a click in the widget to send keyboard focus back to X-Plane.
            This stops editing of any text fields, etc.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.Widgets.Internal.WidgetUtils.DragWidget(XP.SDK.Widgets.WidgetMessage,XP.SDK.Widgets.Internal.WidgetID,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            XPUDragWidget drags the widget in response to mouse clicks. Pass in not
            only the event, but the global coordinates of the drag region, which might
            be a sub-region of your widget (for example, a title bar).
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.TrackStyle">
            <summary>
            <para>
            A track is a UI element that displays a value vertically or horizontally.
            X-Plane has three kinds of tracks: scroll bars, sliders, and progress bars.
            Tracks can be displayed either horizontally or vertically; tracks will
            choose their own layout based on the larger dimension of their dimensions
            (e.g. they know if they are tall or wide). Sliders may be lit or unlit
            (showing the user manipulating them).
            </para>
            <para>
            ScrollBar - this is a standard scroll bar with arrows and a thumb to drag.
            Slider - this is a simple track with a ball in the middle that can be slid.
            Progress - this is a progress indicator showing how a long task is going.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetMessage">
            <summary>
            <para>
            Widgets receive 32-bit messages indicating what action is to be taken or
            notifications of events. The list of messages may be expanded.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.WidgetPropertyID">
            <summary>
            <para>
            Properties are values attached to instances of your widgets. A property is
            identified by a 32-bit ID and its value is the width of a pointer.
            </para>
            <para>
            Each widget instance may have a property or not have it. When you set a
            property on a widget for the first time, the property is added to the
            widget; it then stays there for the life of the widget.
            </para>
            <para>
            Some property IDs are predefined by the widget package; you can make up
            your own property IDs as well.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.Widgets.WindowStyle">
            <summary>
            <para>
            There are a few built-in window styles in X-Plane that you can use.
            </para>
            <para>
            Note that X-Plane 6 does not offer real shadow-compositing; you must make
            sure to put a window on top of another window of the right style to the
            shadows work, etc. This applies to elements with insets and shadows. The
            rules are:
            </para>
            <para>
            Sub windows must go on top of main windows, and screens and list views on
            top of subwindows. Only help and main windows can be over the main screen.
            </para>
            <para>
            With X-Plane 7 any window or element may be placed over any other element.
            </para>
            <para>
            Some windows are scaled by stretching, some by repeating. The drawing
            routines know which scaling method to use. The list view cannot be rescaled
            in X-Plane 6 because it has both a repeating pattern and a gradient in one
            element. All other elements can be rescaled.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CameraControlDuration">
            <summary>
            <para>
            This enumeration states how long you want to retain control of the camera.
            You can retain it indefinitely or until the user selects a new view.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CommandButtonID">
            <summary>
            <para>
            These are enumerations for all of the things you can do with a joystick
            button in X-Plane. They currently match the buttons menu in the equipment
            setup dialog, but these enums will be stable even if they change in
            X-Plane.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CommandKeyID">
            <summary>
            <para>
            These enums represent all the keystrokes available within X-Plane. They can
            be sent to X-Plane directly. For example, you can reverse thrust using
            these enumerations.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CommandPhase">
            <summary>
            <para>
            The phases of a command.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.CursorStatus">
            <summary>
            <para>
            XPLMCursorStatus describes how you would like X-Plane to manage the cursor.
            See XPLMHandleCursor_f for more info.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.DataFileType">
            <summary>
            <para>
            These enums define types of data files you can load or unload using the
            SDK.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.DataTypeID">
            <summary>
            <para>
            This is an enumeration that defines the type of the data behind a data
            reference. This allows you to sanity check that the data type matches what
            you expect. But for the most part, you will know the type of data you are
            expecting from the online documentation.
            </para>
            <para>
            Data types each take a bit field, so sets of data types may be formed.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.DrawingPhase">
            <summary>
            <para>
            This constant indicates which part of drawing we are in.  Drawing is done
            from the back to the front.  We get a callback before or after each item.
            Metaphases provide access to the beginning and end of the 3d (scene) and 2d
            (cockpit) drawing in a manner that is independent of new phases added  via
            X-Plane implementation.
            </para>
            <para>
            WARNING: As X-Plane's scenery evolves, some drawing phases may cease to
            exist and new ones may be invented.  If you need a particularly specific
            use of these codes, consult Austin and/or be prepared to revise your code
            as X-Plane evolves.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.FlightLoopPhaseType">
            <summary>
            <para>
            You can register a flight loop callback to run either before or after the
            flight model is integrated by X-Plane.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.FontID">
            <summary>
            <para>
            X-Plane features some fixed-character fonts.  Each font may have its own
            metrics.
            </para>
            <para>
            WARNING: Some of these fonts are no longer supported or may have changed
            geometries. For maximum copmatibility, see the comments below.
            </para>
            <para>
            Note: X-Plane 7 supports proportional-spaced fonts.  Since no measuring
            routine is available yet, the SDK will normally draw using a fixed-width
            font.  You can use a dataref to enable proportional font drawing on XP7 if
            you want to.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.HostApplicationID">
            <summary>
            <para>
            The plug-in system is based on Austin's cross-platform OpenGL framework and
            could theoretically be adapted to run in other apps like WorldMaker. The
            plug-in system also runs against a test harness for internal development
            and could be adapted to another flight sim (in theory at least). So an ID
            is providing allowing plug-ins to indentify what app they are running
            under.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Camera.ControlCamera(XP.SDK.XPLM.CameraControlDuration,XP.SDK.XPLM.Internal.CameraControlCallback,System.Void*)">
            <summary>
            <para>
            This function repositions the camera on the next drawing cycle. You must
            pass a non-null control function. Specify in inHowLong how long you'd like
            control (indefinitely or until a key is pressed).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Camera.DontControlCamera">
            <summary>
            <para>
            This function stops you from controlling the camera. If you have a camera
            control function, it will not be called with an inIsLosingControl flag.
            X-Plane will control the camera on the next cycle.
            </para>
            <para>
            For maximum compatibility you should not use this routine unless you are in
            posession of the camera.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Camera.IsCameraBeingControlled(XP.SDK.XPLM.CameraControlDuration*)">
            <summary>
            <para>
            This routine returns 1 if the camera is being controlled, zero if it is
            not. If it is and you pass in a pointer to a camera control duration, the
            current control duration will be returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Camera.ReadCameraPosition(XP.SDK.XPLM.Internal.CameraPosition*)">
            <summary>
            <para>
            This function reads the current camera position.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.CameraControlCallback">
            <summary>
            <para>
            You use an XPLMCameraControl function to provide continuous control over
            the camera. You are passed in a structure in which to put the new camera
            position; modify it and return 1 to reposition the camera. Return 0 to
            surrender control of the camera; camera control will be handled by X-Plane
            on this draw loop. The contents of the structure as you are called are
            undefined.
            </para>
            <para>
            If X-Plane is taking camera control away from you, this function will be
            called with inIsLosingControl set to 1 and ioCameraPosition NULL.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.CameraPosition">
            <summary>
            <para>
            This structure contains a full specification of the camera. X, Y, and Z are
            the camera's position in OpenGL coordiantes; pitch, roll, and yaw are
            rotations from a camera facing flat north in degrees. Positive pitch means
            nose up, positive roll means roll right, and positive yaw means yaw right,
            all in degrees. Zoom is a zoom factor, with 1.0 meaning normal zoom and 2.0
            magnifying by 2x (objects appear larger).
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.CommandCallback">
            <summary>
            <para>
            A command callback is a function in your plugin that is called when a
            command is pressed. Your callback receives the command reference for the
            particular command, the phase of the command that is executing, and a
            reference pointer that you specify when registering the callback.
            </para>
            <para>
            Your command handler should return 1 to let processing of the command
            continue to other plugins and X-Plane, or 0 to halt processing, potentially
            bypassing X-Plane code.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.CommandRef">
            <summary>
            <para>
            A command ref is an opaque identifier for an X-Plane command. Command
            references stay the same for the life of your plugin but not between
            executions of X-Plane. Command refs are used to execute commands, create
            commands, and create callbacks for particular commands.
            </para>
            <para>
            Note that a command is not "owned" by a particular plugin. Since many
            plugins may participate in a command's execution, the command does not go
            away if the plugin that created it is unloaded.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.CreateFlightLoop">
            <summary>
            <para>
            XPLMCreateFlightLoop_t contains the parameters to create a new flight loop
            callback. The strsucture can be expanded in future SDKs - always set
            structSize to the size of your structure in bytes.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.CreateMapLayer">
            <summary>
            <para>
            This structure defines all of the parameters used to create a map layer
            using XPLMCreateMapLayer. The structure will be expanded in future SDK APIs
            to include more features.  Always set the structSize member to the size of
            your struct in bytes!
            </para>
            <para>
            Each layer must be associated with exactly one map instance in X-Plane.
            That map, and that map alone, will call your callbacks. Likewise, when that
            map is deleted, your layer will be as well.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.CreateWindow">
            <summary>
            <para>
            The XPMCreateWindow_t structure defines all of the parameters used to
            create a modern window using XPLMCreateWindowEx().  The structure will be
            expanded in future SDK APIs to include more features.  Always set the
            structSize member to the size of your struct in bytes!
            </para>
            <para>
            All windows created by this function in the XPLM300 version of the API are
            created with the new X-Plane 11 GUI features. This means your plugin will
            get to "know" about the existence of X-Plane windows other than the main
            window. All drawing and mouse callbacks for your window will occur in
            "boxels," giving your windows automatic support for high-DPI scaling in
            X-Plane. In addition, your windows can opt-in to decoration with the
            X-Plane 11 window styling, and you can use the
            XPLMSetWindowPositioningMode() API to make your window "popped out" into a
            first-class operating system window.
            </para>
            <para>
            Note that this requires dealing with your window's bounds in "global
            desktop" positioning units, rather than the traditional panel coordinate
            system. In global desktop coordinates, the main X-Plane window may not have
            its origin at coordinate (0, 0), and your own window may have negative
            coordinates. Assuming you don't implicitly assume (0, 0) as your origin,
            the only API change you should need is to start using
            XPLMGetMouseLocationGlobal() rather than XPLMGetMouseLocation(), and
            XPLMGetScreenBoundsGlobal() instead of XPLMGetScreenSize().
            </para>
            <para>
            If you ask to be decorated as a floating window, you'll get the blue window
            control bar and blue backing that you see in X-Plane 11's normal "floating"
            windows (like the map).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.FindDataRef(System.Byte*)">
            <summary>
            <para>
            Given a c-style string that names the data ref, this routine looks up the
            actual opaque XPLMDataRef that you use to read and write the data. The
            string names for datarefs are published on the X-Plane SDK web site.
            </para>
            <para>
            This function returns NULL if the data ref cannot be found.
            </para>
            <para>
            NOTE: this function is relatively expensive; save the XPLMDataRef this
            function returns for future use. Do not look up your data ref by string
            every time you need to read or write it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.FindDataRef(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Given a c-style string that names the data ref, this routine looks up the
            actual opaque XPLMDataRef that you use to read and write the data. The
            string names for datarefs are published on the X-Plane SDK web site.
            </para>
            <para>
            This function returns NULL if the data ref cannot be found.
            </para>
            <para>
            NOTE: this function is relatively expensive; save the XPLMDataRef this
            function returns for future use. Do not look up your data ref by string
            every time you need to read or write it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.CanWriteDataRef(XP.SDK.XPLM.Internal.DataRef)">
            <summary>
            <para>
            Given a data ref, this routine returns true if you can successfully set the
            data, false otherwise. Some datarefs are read-only.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.IsDataRefGood(XP.SDK.XPLM.Internal.DataRef)">
            <summary>
            <para>
            WARNING: This function is deprecated and should not be used. Datarefs are
            valid until plugins are reloaded or the sim quits. Plugins sharing datarefs
            should support these semantics by not unregistering datarefs during
            operation. (You should however unregister datarefs when your plugin is
            unloaded, as part of general resource cleanup.)
            </para>
            <para>
            This function returns whether a data ref is still valid. If it returns
            false, you should refind the data ref from its original string. Calling an
            accessor function on a bad data ref will return a default value, typically
            0 or 0-length data.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.GetDataRefTypes(XP.SDK.XPLM.Internal.DataRef)">
            <summary>
            <para>
            This routine returns the types of the data ref for accessor use. If a data
            ref is available in multiple data types, they will all be returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.GetDatai(XP.SDK.XPLM.Internal.DataRef)">
            <summary>
            <para>
            Read an integer data ref and return its value. The return value is the
            dataref value or 0 if the dataref is invalid/NULL or the plugin is
            disabled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.SetDatai(XP.SDK.XPLM.Internal.DataRef,System.Int32)">
            <summary>
            <para>
            Write a new value to an integer data ref. This routine is a no-op if the
            plugin publishing the dataref is disabled, the dataref is invalid, or the
            dataref is not writable.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.GetDataf(XP.SDK.XPLM.Internal.DataRef)">
            <summary>
            <para>
            Read a single precision floating point dataref and return its value. The
            return value is the dataref value or 0.0 if the dataref is invalid/NULL or
            the plugin is disabled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.SetDataf(XP.SDK.XPLM.Internal.DataRef,System.Single)">
            <summary>
            <para>
            Write a new value to a single precision floating point data ref. This
            routine is a no-op if the plugin publishing the dataref is disabled, the
            dataref is invalid, or the dataref is not writable.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.GetDatad(XP.SDK.XPLM.Internal.DataRef)">
            <summary>
            <para>
            Read a double precision floating point dataref and return its value. The
            return value is the dataref value or 0.0 if the dataref is invalid/NULL or
            the plugin is disabled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.SetDatad(XP.SDK.XPLM.Internal.DataRef,System.Double)">
            <summary>
            <para>
            Write a new value to a double precision floating point data ref. This
            routine is a no-op if the plugin publishing the dataref is disabled, the
            dataref is invalid, or the dataref is not writable.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.GetDatavi(XP.SDK.XPLM.Internal.DataRef,System.Int32*,System.Int32,System.Int32)">
            <summary>
            <para>
            Read a part of an integer array dataref. If you pass NULL for outVaules,
            the routine will return the size of the array, ignoring inOffset and inMax.
            </para>
            <para>
            If outValues is not NULL, then up to inMax values are copied from the
            dataref into outValues, starting at inOffset in the dataref. If inMax +
            inOffset is larger than the size of the dataref, less than inMax values
            will be copied. The number of values copied is returned.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.SetDatavi(XP.SDK.XPLM.Internal.DataRef,System.Int32*,System.Int32,System.Int32)">
            <summary>
            <para>
            Write part or all of an integer array dataref. The values passed by
            inValues are written into the dataref starting at inOffset. Up to inCount
            values are written; however if the values would write "off the end" of the
            dataref array, then fewer values are written.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.GetDatavf(XP.SDK.XPLM.Internal.DataRef,System.Single*,System.Int32,System.Int32)">
            <summary>
            <para>
            Read a part of a single precision floating point array dataref. If you pass
            NULL for outVaules, the routine will return the size of the array, ignoring
            inOffset and inMax.
            </para>
            <para>
            If outValues is not NULL, then up to inMax values are copied from the
            dataref into outValues, starting at inOffset in the dataref. If inMax +
            inOffset is larger than the size of the dataref, less than inMax values
            will be copied. The number of values copied is returned.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.SetDatavf(XP.SDK.XPLM.Internal.DataRef,System.Single*,System.Int32,System.Int32)">
            <summary>
            <para>
            Write part or all of a single precision floating point array dataref. The
            values passed by inValues are written into the dataref starting at
            inOffset. Up to inCount values are written; however if the values would
            write "off the end" of the dataref array, then fewer values are written.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.GetDatab(XP.SDK.XPLM.Internal.DataRef,System.Void*,System.Int32,System.Int32)">
            <summary>
            <para>
            Read a part of a byte array dataref. If you pass NULL for outVaules, the
            routine will return the size of the array, ignoring inOffset and inMax.
            </para>
            <para>
            If outValues is not NULL, then up to inMax values are copied from the
            dataref into outValues, starting at inOffset in the dataref. If inMax +
            inOffset is larger than the size of the dataref, less than inMax values
            will be copied. The number of values copied is returned.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.SetDatab(XP.SDK.XPLM.Internal.DataRef,System.Void*,System.Int32,System.Int32)">
            <summary>
            <para>
            Write part or all of a byte array dataref. The values passed by inValues
            are written into the dataref starting at inOffset. Up to inCount values are
            written; however if the values would write "off the end" of the dataref
            array, then fewer values are written.
            </para>
            <para>
            Note: the semantics of array datarefs are entirely implemented by the
            plugin (or X-Plane) that provides the dataref, not the SDK itself; the
            above description is how these datarefs are intended to work, but a rogue
            plugin may have different behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.RegisterDataAccessor(System.Byte*,XP.SDK.XPLM.DataTypeID,System.Int32,XP.SDK.XPLM.Internal.GetDataiCallback,XP.SDK.XPLM.Internal.SetDataiCallback,XP.SDK.XPLM.Internal.GetDatafCallback,XP.SDK.XPLM.Internal.SetDatafCallback,XP.SDK.XPLM.Internal.GetDatadCallback,XP.SDK.XPLM.Internal.SetDatadCallback,XP.SDK.XPLM.Internal.GetDataviCallback,XP.SDK.XPLM.Internal.SetDataviCallback,XP.SDK.XPLM.Internal.GetDatavfCallback,XP.SDK.XPLM.Internal.SetDatavfCallback,XP.SDK.XPLM.Internal.GetDatabCallback,XP.SDK.XPLM.Internal.SetDatabCallback,System.Void*,System.Void*)">
            <summary>
            <para>
            This routine creates a new item of data that can be read and written. Pass
            in the data's full name for searching, the type(s) of the data for
            accessing, and whether the data can be written to. For each data type you
            support, pass in a read accessor function and a write accessor function if
            necessary. Pass NULL for data types you do not support or write accessors
            if you are read-only.
            </para>
            <para>
            You are returned a data ref for the new item of data created. You can use
            this data ref to unregister your data later or read or write from it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.RegisterDataAccessor(System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.DataTypeID,System.Int32,XP.SDK.XPLM.Internal.GetDataiCallback,XP.SDK.XPLM.Internal.SetDataiCallback,XP.SDK.XPLM.Internal.GetDatafCallback,XP.SDK.XPLM.Internal.SetDatafCallback,XP.SDK.XPLM.Internal.GetDatadCallback,XP.SDK.XPLM.Internal.SetDatadCallback,XP.SDK.XPLM.Internal.GetDataviCallback,XP.SDK.XPLM.Internal.SetDataviCallback,XP.SDK.XPLM.Internal.GetDatavfCallback,XP.SDK.XPLM.Internal.SetDatavfCallback,XP.SDK.XPLM.Internal.GetDatabCallback,XP.SDK.XPLM.Internal.SetDatabCallback,System.Void*,System.Void*)">
            <summary>
            <para>
            This routine creates a new item of data that can be read and written. Pass
            in the data's full name for searching, the type(s) of the data for
            accessing, and whether the data can be written to. For each data type you
            support, pass in a read accessor function and a write accessor function if
            necessary. Pass NULL for data types you do not support or write accessors
            if you are read-only.
            </para>
            <para>
            You are returned a data ref for the new item of data created. You can use
            this data ref to unregister your data later or read or write from it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.UnregisterDataAccessor(XP.SDK.XPLM.Internal.DataRef)">
            <summary>
            <para>
            Use this routine to unregister any data accessors you may have registered.
            You unregister a data ref by the XPLMDataRef you get back from
            registration. Once you unregister a data ref, your function pointer will
            not be called anymore.
            </para>
            <para>
            For maximum compatibility, do not unregister your data accessors until
            final shutdown (when your XPluginStop routine is called). This allows other
            plugins to find your data reference once and use it for their entire time
            of operation.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.ShareData(System.Byte*,XP.SDK.XPLM.DataTypeID,XP.SDK.XPLM.Internal.DataChangedCallback,System.Void*)">
            <summary>
            <para>
            This routine connects a plug-in to shared data, creating the shared data if
            necessary. inDataName is a standard path for the data ref, and inDataType
            specifies the type. This function will create the data if it does not
            exist. If the data already exists but the type does not match, an error is
            returned, so it is important that plug-in authors collaborate to establish
            public standards for shared data.
            </para>
            <para>
            If a notificationFunc is passed in and is not NULL, that notification
            function will be called whenever the data is modified. The notification
            refcon will be passed to it. This allows your plug-in to know which shared
            data was changed if multiple shared data are handled by one callback, or if
            the plug-in does not use global variables.
            </para>
            <para>
            A one is returned for successfully creating or finding the shared data; a
            zero if the data already exists but is of the wrong type.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.ShareData(System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.DataTypeID,XP.SDK.XPLM.Internal.DataChangedCallback,System.Void*)">
            <summary>
            <para>
            This routine connects a plug-in to shared data, creating the shared data if
            necessary. inDataName is a standard path for the data ref, and inDataType
            specifies the type. This function will create the data if it does not
            exist. If the data already exists but the type does not match, an error is
            returned, so it is important that plug-in authors collaborate to establish
            public standards for shared data.
            </para>
            <para>
            If a notificationFunc is passed in and is not NULL, that notification
            function will be called whenever the data is modified. The notification
            refcon will be passed to it. This allows your plug-in to know which shared
            data was changed if multiple shared data are handled by one callback, or if
            the plug-in does not use global variables.
            </para>
            <para>
            A one is returned for successfully creating or finding the shared data; a
            zero if the data already exists but is of the wrong type.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.UnshareData(System.Byte*,XP.SDK.XPLM.DataTypeID,XP.SDK.XPLM.Internal.DataChangedCallback,System.Void*)">
            <summary>
            <para>
            This routine removes your notification function for shared data. Call it
            when done with the data to stop receiving change notifications. Arguments
            must match XPLMShareData. The actual memory will not necessarily be freed,
            since other plug-ins could be using it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.DataAccess.UnshareData(System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.DataTypeID,XP.SDK.XPLM.Internal.DataChangedCallback,System.Void*)">
            <summary>
            <para>
            This routine removes your notification function for shared data. Call it
            when done with the data to stop receiving change notifications. Arguments
            must match XPLMShareData. The actual memory will not necessarily be freed,
            since other plug-ins could be using it.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.DataChangedCallback">
            <summary>
            <para>
            An XPLMDataChanged_f is a callback that the XPLM calls whenever any other
            plug-in modifies shared data. A refcon you provide is passed back to help
            identify which data is being changed. In response, you may want to call one
            of the XPLMGetDataxxx routines to find the new value of the data.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.DataRef">
            <summary>
            <para>
            A data ref is an opaque handle to data provided by the simulator or another
            plugin. It uniquely identifies one variable (or array of variables) over
            the lifetime of your plugin. You never hard code these values; you always
            get them from XPLMFindDataRef.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.RegisterDrawCallback(XP.SDK.XPLM.Internal.DrawCallback,XP.SDK.XPLM.DrawingPhase,System.Int32,System.Void*)">
            <summary>
            <para>
            This routine registers a low level drawing callback.  Pass in the phase you
            want to be called for and whether you want to be called before or after.
            This routine returns 1 if the registration was successful, or 0 if the
            phase does not exist in this version of X-Plane.  You may register a
            callback multiple times for the same or different phases as long as the
            refcon is unique each time.
            </para>
            <para>
            Note that this function will likely be removed during the X-Plane 11 run as
            part of the transition to Vulkan/Metal/etc. See the XPLMInstance API for
            future-proof drawing of 3-D objects.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.UnregisterDrawCallback(XP.SDK.XPLM.Internal.DrawCallback,XP.SDK.XPLM.DrawingPhase,System.Int32,System.Void*)">
            <summary>
            <para>
            This routine unregisters a draw callback.  You must unregister a callback
            for each  time you register a callback if you have registered it multiple
            times with different refcons.  The routine returns 1 if it can find the
            callback to unregister, 0 otherwise.
            </para>
            <para>
            Note that this function will likely be removed during the X-Plane 11 run as
            part of the transition to Vulkan/Metal/etc. See the XPLMInstance API for
            future-proof drawing of 3-D objects.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.CreateWindowEx(XP.SDK.XPLM.Internal.CreateWindow*)">
            <summary>
            <para>
            This routine creates a new "modern" window. You pass in an
            XPLMCreateWindow_t structure with all of the fields set in.  You must set
            the structSize of the structure to the size of the actual structure you
            used.  Also, you must provide functions for every callback---you may not
            leave them null!  (If you do not support the cursor or mouse wheel, use
            functions that return the default values.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.CreateWindow(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,XP.SDK.XPLM.Internal.DrawWindowCallback,XP.SDK.XPLM.Internal.HandleKeyCallback,XP.SDK.XPLM.Internal.HandleMouseClickCallback,System.Void*)">
            <summary>
            <para>
            Deprecated as of XPLM300.
            </para>
            <para>
            This routine creates a new legacy window. Unlike modern windows (created
            via XPLMCreateWindowEx()), legacy windows do not have access to X-Plane 11
            features like automatic scaling for high-DPI screens, native window styles,
            or support for being "popped out" into first-class operating system
            windows.
            </para>
            <para>
            Pass in the dimensions and offsets to the window's bottom left corner from
            the bottom left of the screen.  You can specify whether the window is
            initially visible or not.  Also, you pass in three callbacks to run the
            window and a refcon.  This function returns a window ID you can use to
            refer to the new window.
            </para>
            <para>
            NOTE: Legacy windows do not have "frames"; you are responsible for drawing
            the background and frame of the window.  Higher level libraries have
            routines which make this easy.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.DestroyWindow(XP.SDK.XPLM.Internal.WindowID)">
            <summary>
            <para>
            This routine destroys a window.  The window's callbacks are not called
            after this call. Keyboard focus is removed from the window before
            destroying it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetScreenSize(System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the size of the main X-Plane OpenGL window in pixels.
            This number can be used to get a rough idea of the amount of detail the
            user will be able to see when drawing in 3-d.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetScreenBoundsGlobal(System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the bounds of the "global" X-Plane desktop, in boxels.
            Unlike the non-global version XPLMGetScreenSize(), this is multi-monitor
            aware. There are three primary consequences of multimonitor awareness.
            </para>
            <para>
            First, if the user is running X-Plane in full-screen on two or more
            monitors (typically configured using one full-screen window per monitor),
            the global desktop will be sized to include all X-Plane windows.
            </para>
            <para>
            Second, the origin of the screen coordinates is not guaranteed to be (0,
            0). Suppose the user has two displays side-by-side, both running at 1080p.
            Suppose further that they've configured their OS to make the left display
            their "primary" monitor, and that X-Plane is running in full-screen on
            their right monitor only. In this case, the global desktop bounds would be
            the rectangle from (1920, 0) to (3840, 1080). If the user later asked
            X-Plane to draw on their primary monitor as well, the bounds would change
            to (0, 0) to (3840, 1080).
            </para>
            <para>
            Finally, if the usable area of the virtual desktop is not a perfect
            rectangle (for instance, because the monitors have different resolutions or
            because one monitor is configured in the operating system to be above and
            to the right of the other), the global desktop will include any wasted
            space. Thus, if you have two 1080p monitors, and monitor 2 is configured to
            have its bottom left touch monitor 1's upper right, your global desktop
            area would be the rectangle from (0, 0) to (3840, 2160).
            </para>
            <para>
            Note that popped-out windows (windows drawn in their own operating system
            windows, rather than "floating" within X-Plane) are not included in these
            bounds.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetAllMonitorBoundsGlobal(XP.SDK.XPLM.Internal.ReceiveMonitorBoundsGlobalCallback,System.Void*)">
            <summary>
            <para>
            This routine immediately calls you back with the bounds (in boxels) of each
            full-screen X-Plane window within the X-Plane global desktop space. Note
            that if a monitor is *not* covered by an X-Plane window, you cannot get its
            bounds this way. Likewise, monitors with only an X-Plane window (not in
            full-screen mode) will not be included.
            </para>
            <para>
            If X-Plane is running in full-screen and your monitors are of the same size
            and configured contiguously in the OS, then the combined global bounds of
            all full-screen monitors will match the total global desktop bounds, as
            returned by XPLMGetScreenBoundsGlobal(). (Of course, if X-Plane is running
            in windowed mode, this will not be the case. Likewise, if you have
            differently sized monitors, the global desktop space will include wasted
            space.)
            </para>
            <para>
            Note that this function's monitor indices match those provided by
            XPLMGetAllMonitorBoundsOS(), but the coordinates are different (since the
            X-Plane global desktop may not match the operating system's global desktop,
            and one X-Plane boxel may be larger than one pixel due to 150% or 200%
            scaling).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetAllMonitorBoundsOS(XP.SDK.XPLM.Internal.ReceiveMonitorBoundsOSCallback,System.Void*)">
            <summary>
            <para>
            This routine immediately calls you back with the bounds (in pixels) of each
            monitor within the operating system's global desktop space. Note that
            unlike XPLMGetAllMonitorBoundsGlobal(), this may include monitors that have
            no X-Plane window on them.
            </para>
            <para>
            Note that this function's monitor indices match those provided by
            XPLMGetAllMonitorBoundsGlobal(), but the coordinates are different (since
            the X-Plane global desktop may not match the operating system's global
            desktop, and one X-Plane boxel may be larger than one pixel).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetMouseLocation(System.Int32*,System.Int32*)">
            <summary>
            <para>
            Deprecated in XPLM300. Modern windows should use
            XPLMGetMouseLocationGlobal() instead.
            </para>
            <para>
            This routine returns the current mouse location in pixels relative to the
            main X-Plane window. The bottom left corner of the main window is (0, 0).
            Pass NULL to not receive info about either parameter.
            </para>
            <para>
            Because this function gives the mouse position relative to the main X-Plane
            window (rather than in global bounds), this function should only be used by
            legacy windows. Modern windows should instead get the mouse position in
            global desktop coordinates using XPLMGetMouseLocationGlobal().
            </para>
            <para>
            Note that unlike XPLMGetMouseLocationGlobal(), if the mouse goes outside
            the user's main monitor (for instance, to a pop out window or a secondary
            monitor), this function will not reflect it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetMouseLocationGlobal(System.Int32*,System.Int32*)">
            <summary>
            <para>
            Returns the current mouse location in global desktop boxels. Unlike
            XPLMGetMouseLocation(), the bottom left of the main X-Plane window is not
            guaranteed to be (0, 0)---instead, the origin is the lower left of the
            entire global desktop space. In addition, this routine gives the real mouse
            location when the mouse goes to X-Plane windows other than the primary
            display. Thus, it can be used with both pop-out windows and secondary
            monitors.
            </para>
            <para>
            This is the mouse location function to use with modern windows (i.e., those
            created by XPLMCreateWindowEx()).
            </para>
            <para>
            Pass NULL to not receive info about either parameter.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetWindowGeometry(XP.SDK.XPLM.Internal.WindowID,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the position and size of a window. The units and
            coordinate system vary depending on the type of window you have.
            </para>
            <para>
            If this is a legacy window (one compiled against a pre-XPLM300 version of
            the SDK, or an XPLM300 window that was not created using
            XPLMCreateWindowEx()), the units are pixels relative to the main X-Plane
            display.
            </para>
            <para>
            If, on the other hand, this is a new X-Plane 11-style window (compiled
            against the XPLM300 SDK and created using XPLMCreateWindowEx()), the units
            are global desktop boxels.
            </para>
            <para>
            Pass NULL to not receive any paramter.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetWindowGeometry(XP.SDK.XPLM.Internal.WindowID,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            This routine allows you to set the position and size of a window.
            </para>
            <para>
            The units and coordinate system match those of XPLMGetWindowGeometry().
            That is, modern windows use global desktop boxel coordinates, while legacy
            windows use pixels relative to the main X-Plane display.
            </para>
            <para>
            Note that this only applies to "floating" windows (that is, windows that
            are drawn within the X-Plane simulation windows, rather than being "popped
            out" into their own first-class operating system windows). To set the
            position of windows whose positioning mode is xplm_WindowPopOut, you'll
            need to instead use XPLMSetWindowGeometryOS().
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetWindowGeometryOS(XP.SDK.XPLM.Internal.WindowID,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the position and size of a "popped out" window (i.e.,
            a window whose positioning mode is xplm_WindowPopOut), in operating system
            pixels.  Pass NULL to not receive any parameter.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetWindowGeometryOS(XP.SDK.XPLM.Internal.WindowID,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            This routine allows you to set the position and size, in operating system
            pixel coordinates, of a popped out window (that is, a window whose
            positioning mode is xplm_WindowPopOut, which exists outside the X-Plane
            simulation window, in its own first-class operating system window).
            </para>
            <para>
            Note that you are responsible for ensuring both that your window is popped
            out (using XPLMWindowIsPoppedOut()) and that a monitor really exists at the
            OS coordinates you provide (using XPLMGetAllMonitorBoundsOS()).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetWindowGeometryVR(XP.SDK.XPLM.Internal.WindowID,System.Int32*,System.Int32*)">
            <summary>
            <para>
            Returns the width and height, in boxels, of a window in VR. Note that you
            are responsible for ensuring your window is in VR (using
            XPLMWindowIsInVR()).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetWindowGeometryVR(XP.SDK.XPLM.Internal.WindowID,System.Int32,System.Int32)">
            <summary>
            <para>
            This routine allows you to set the size, in boxels, of a window in VR (that
            is, a window whose positioning mode is xplm_WindowVR).
            </para>
            <para>
            Note that you are responsible for ensuring your window is in VR (using
            XPLMWindowIsInVR()).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetWindowIsVisible(XP.SDK.XPLM.Internal.WindowID)">
            <summary>
            <para>
            This routine returns whether a window is visible.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetWindowIsVisible(XP.SDK.XPLM.Internal.WindowID,System.Int32)">
            <summary>
            <para>
            This routine shows or hides a window.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.WindowIsPoppedOut(XP.SDK.XPLM.Internal.WindowID)">
            <summary>
            <para>
            True if this window has been popped out (making it a first-class window in
            the operating system), which in turn is true if and only if you have set
            the window's positioning mode to xplm_WindowPopOut.
            </para>
            <para>
            Only applies to modern windows. (Windows created using the deprecated
            XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of
            the SDK cannot be popped out.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.WindowIsInVR(XP.SDK.XPLM.Internal.WindowID)">
            <summary>
            <para>
            True if this window has been moved to the virtual reality (VR) headset,
            which in turn is true if and only if you have set the window's positioning
            mode to xplm_WindowVR.
            </para>
            <para>
            Only applies to modern windows. (Windows created using the deprecated
            XPLMCreateWindow(), or windows compiled against a pre-XPLM301 version of
            the SDK cannot be moved to VR.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetWindowGravity(XP.SDK.XPLM.Internal.WindowID,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>
            A window's "gravity" controls how the window shifts as the whole X-Plane
            window resizes. A gravity of 1 means the window maintains its positioning
            relative to the right or top edges, 0 the left/bottom, and 0.5 keeps it
            centered.
            </para>
            <para>
            Default gravity is (0, 1, 0, 1), meaning your window will maintain its
            position relative to the top left and will not change size as its
            containing window grows.
            </para>
            <para>
            If you wanted, say, a window that sticks to the top of the screen (with a
            constant height), but which grows to take the full width of the window, you
            would pass (0, 1, 1, 1). Because your left and right edges would maintain
            their positioning relative to their respective edges of the screen, the
            whole width of your window would change with the X-Plane window.
            </para>
            <para>
            Only applies to modern windows. (Windows created using the deprecated
            XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of
            the SDK will simply get the default gravity.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetWindowResizingLimits(XP.SDK.XPLM.Internal.WindowID,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Sets the minimum and maximum size of the client rectangle of the given
            window. (That is, it does not include any window styling that you might
            have asked X-Plane to apply on your behalf.) All resizing operations are
            constrained to these sizes.
            </para>
            <para>
            Only applies to modern windows. (Windows created using the deprecated
            XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of
            the SDK will have no minimum or maximum size.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetWindowPositioningMode(XP.SDK.XPLM.Internal.WindowID,XP.SDK.XPLM.WindowPositioningMode,System.Int32)">
            <summary>
            <para>
            Sets the policy for how X-Plane will position your window.
            </para>
            <para>
            Some positioning modes apply to a particular monitor. For those modes, you
            can pass a negative monitor index to position the window on the main
            X-Plane monitor (the screen with the X-Plane menu bar at the top). Or, if
            you have a specific monitor you want to position your window on, you can
            pass a real monitor index as received from, e.g.,
            XPLMGetAllMonitorBoundsOS().
            </para>
            <para>
            Only applies to modern windows. (Windows created using the deprecated
            XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of
            the SDK will always use xplm_WindowPositionFree.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetWindowTitle(XP.SDK.XPLM.Internal.WindowID,System.Byte*)">
            <summary>
            <para>
            Sets the name for a window. This only applies to windows that opted-in to
            styling as an X-Plane 11 floating window (i.e., with styling mode
            xplm_WindowDecorationRoundRectangle) when they were created using
            XPLMCreateWindowEx().
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetWindowTitle(XP.SDK.XPLM.Internal.WindowID,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Sets the name for a window. This only applies to windows that opted-in to
            styling as an X-Plane 11 floating window (i.e., with styling mode
            xplm_WindowDecorationRoundRectangle) when they were created using
            XPLMCreateWindowEx().
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetWindowRefCon(XP.SDK.XPLM.Internal.WindowID)">
            <summary>
            <para>
            This routine returns a window's reference constant, the unique value you
            can use for your own purposes.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetWindowRefCon(XP.SDK.XPLM.Internal.WindowID,System.Void*)">
            <summary>
            <para>
            This routine sets a window's reference constant.  Use this to pass data to
            yourself in the callbacks.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.TakeKeyboardFocus(XP.SDK.XPLM.Internal.WindowID)">
            <summary>
            <para>
            This routine gives a specific window keyboard focus.  Keystrokes will be
            sent to  that window.  Pass a window ID of 0 to remove keyboard focus from
            any plugin-created windows and instead pass keyboard strokes directly to
            X-Plane.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.HasKeyboardFocus(XP.SDK.XPLM.Internal.WindowID)">
            <summary>
            <para>
            Returns true (1) if the indicated window has keyboard focus. Pass a window
            ID of 0 to see if no plugin window has focus, and all keystrokes will go
            directly to X-Plane.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.BringWindowToFront(XP.SDK.XPLM.Internal.WindowID)">
            <summary>
            <para>
            This routine brings the window to the front of the Z-order for its layer.
            Windows are brought to the front automatically when they are created.
            Beyond that, you should make sure you are front before handling mouse
            clicks.
            </para>
            <para>
            Note that this only brings your window to the front of its layer
            (XPLMWindowLayer). Thus, if you have a window in the floating window layer
            (xplm_WindowLayerFloatingWindows), but there is a modal window (in layer
            xplm_WindowLayerModal) above you, you would still not be the true frontmost
            window after calling this. (After all, the window layers are strictly
            ordered, and no window in a lower layer can ever be above any window in a
            higher one.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.IsWindowInFront(XP.SDK.XPLM.Internal.WindowID)">
            <summary>
            <para>
            This routine returns true if the window you passed in is the frontmost
            visible window in its layer (XPLMWindowLayer).
            </para>
            <para>
            Thus, if you have a window at the front of the floating window layer
            (xplm_WindowLayerFloatingWindows), this will return true even if there is a
            modal window (in layer xplm_WindowLayerModal) above you. (Not to worry,
            though: in such a case, X-Plane will not pass clicks or keyboard input down
            to your layer until the window above stops "eating" the input.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.RegisterKeySniffer(XP.SDK.XPLM.Internal.KeySnifferCallback,System.Int32,System.Void*)">
            <summary>
            <para>
            This routine registers a key sniffing callback.  You specify whether you
            want to sniff before the window system, or only sniff keys the window
            system does not consume.  You should ALMOST ALWAYS sniff non-control keys
            after the window system.  When the window system consumes a key, it is
            because the user has "focused" a window.  Consuming the key or taking
            action based on the key will produce very weird results.  Returns 1 if
            successful.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.UnregisterKeySniffer(XP.SDK.XPLM.Internal.KeySnifferCallback,System.Int32,System.Void*)">
            <summary>
            <para>
            This routine unregisters a key sniffer.  You must unregister a key sniffer
            for every time you register one with the exact same signature.  Returns 1
            if successful.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.RegisterHotKey(System.Byte,XP.SDK.XPLM.KeyFlags,System.Byte*,XP.SDK.XPLM.Internal.HotKeyCallback,System.Void*)">
            <summary>
            <para>
            This routine registers a hot key.  You specify your preferred key stroke
            virtual key/flag combination, a description of what your callback does (so
            other plug-ins can describe the plug-in to the user for remapping) and a
            callback function and opaque pointer to pass in).  A new hot key ID is
            returned.  During execution, the actual key associated with your hot key
            may change, but you are insulated from this.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.RegisterHotKey(System.Byte,XP.SDK.XPLM.KeyFlags,System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.Internal.HotKeyCallback,System.Void*)">
            <summary>
            <para>
            This routine registers a hot key.  You specify your preferred key stroke
            virtual key/flag combination, a description of what your callback does (so
            other plug-ins can describe the plug-in to the user for remapping) and a
            callback function and opaque pointer to pass in).  A new hot key ID is
            returned.  During execution, the actual key associated with your hot key
            may change, but you are insulated from this.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.UnregisterHotKey(XP.SDK.XPLM.Internal.HotKeyID)">
            <summary>
            <para>
            This API unregisters a hot key.  You can only unregister your own hot keys.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.CountHotKeys">
            <summary>
            <para>
            Returns the number of current hot keys.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetNthHotKey(System.Int32)">
            <summary>
            <para>
            Returns a hot key by index, for iteration on all hot keys.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.GetHotKeyInfo(XP.SDK.XPLM.Internal.HotKeyID,System.Byte*,XP.SDK.XPLM.KeyFlags*,System.Byte*,XP.SDK.XPLM.Internal.PluginID*)">
            <summary>
            <para>
            Returns information about the hot key.  Return NULL for any  parameter you
            don't want info about.  The description should be at least 512 chars long.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Display.SetHotKeyCombination(XP.SDK.XPLM.Internal.HotKeyID,System.Byte,XP.SDK.XPLM.KeyFlags)">
            <summary>
            <para>
            XPLMSetHotKeyCombination remaps a hot keys keystrokes.  You may remap
            another plugin's keystrokes.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.DrawCallback">
            <summary>
            <para>
            This is the prototype for a low level drawing callback.  You are passed in
            the phase and whether it is before or after.  If you are before the phase,
            return 1 to let X-Plane draw or 0 to suppress X-Plane drawing.  If you are
            after the phase the return value is ignored.
            </para>
            <para>
            Refcon is a unique value that you specify when registering the callback,
            allowing you to slip a pointer to your own data to the callback.
            </para>
            <para>
            Upon entry the OpenGL context will be correctly set up for you and OpenGL
            will be in 'local' coordinates for 3d drawing and panel coordinates for 2d
            drawing.  The OpenGL state (texturing, etc.) will be unknown.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.DrawInfo">
            <summary>
            <para>
            The XPLMDrawInfo_t structure contains positioning info for one object that
            is to be drawn. Be sure to set structSize to the size of the structure for
            future expansion.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.DrawWindowCallback">
            <summary>
            <para>
            A callback to handle 2-D drawing of your window.  You are passed in your
            window and its refcon. Draw the window.  You can use other XPLM functions
            from this header to find the current dimensions of your window, etc.  When
            this callback is called, the OpenGL context will be set properly for 2-D
            window drawing.
            </para>
            <para>
            NOTE: Because you are drawing your window over a background, you can make a
            translucent window easily by simply not filling in your entire window's
            bounds.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.ErrorCallback">
            <summary>
            <para>
            An XPLM error callback is a function that you provide to receive debugging
            information from the plugin SDK. See XPLMSetErrorCallback for more
            information. NOTE: for the sake of debugging, your error callback will be
            called even if your plugin is not enabled, allowing you to receive debug
            info in your XPluginStart and XPluginStop callbacks. To avoid causing logic
            errors in the management code, do not call any other plugin routines from
            your error callback - it is only meant for logging!
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.FeatureEnumeratorCallback">
            <summary>
            <para>
            You pass an XPLMFeatureEnumerator_f to get a list of all features supported
            by a given version running version of X-Plane.  This routine is called once
            for each feature.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.FlightLoopCallback">
            <summary>
            <para>
            This is your flight loop callback. Each time the flight loop is iterated
            through, you receive this call at the end. You receive a time since you
            were last called and a time since the last loop, as well as a loop counter.
            The 'phase' parameter is deprecated and should be ignored.
            </para>
            <para>
            Your return value controls when you will next be called. Return 0 to stop
            receiving callbacks. Pass a positive number to specify how many seconds
            until the next callback. (You will be called at or after this time, not
            before.) Pass a negative number to specify how many loops must go by until
            you are called. For example, -1.0 means call me the very next loop. Try to
            run your flight loop as infrequently as is practical, and suspend it (using
            return value 0) when you do not need it; lots of flight loop callbacks that
            do nothing lowers X-Plane's frame rate.
            </para>
            <para>
            Your callback will NOT be unregistered if you return 0; it will merely be
            inactive.
            </para>
            <para>
            The reference constant you passed to your loop is passed back to you.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.FlightLoopID">
            <summary>
            <para>
            This is an opaque identifier for a flight loop callback. You can use this
            identifier to easily track and remove your callbacks, or to use the new
            flight loop APIs.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.GetDatabCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.GetDatadCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.GetDatafCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.GetDataiCallback">
            <summary>
            <para>
            Data provider function pointers.
            </para>
            <para>
            These define the function pointers you provide to get or set data. Note
            that you are passed a generic pointer for each one. This is the same
            pointer you pass in your register routine; you can use it to find global
            variables, etc.
            </para>
            <para>
            The semantics of your callbacks are the same as the dataref accessor above
            - basically routines like XPLMGetDatai are just pass-throughs from a caller
            to your plugin. Be particularly mindful in implementing array dataref
            read-write accessors; you are responsible for avoiding overruns, supporting
            offset read/writes, and handling a read with a NULL buffer.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.GetDatavfCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.GetDataviCallback">
            <summary>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.SetGraphicsState(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            XPLMSetGraphicsState changes OpenGL's graphics state in a number of ways:
            </para>
            <para>
            inEnableFog - enables or disables fog, equivalent to: glEnable(GL_FOG);
            </para>
            <para>
            inNumberTexUnits - enables or disables a number of multitexturing units. If
            the number is 0, 2d texturing is disabled entirely, as in
            glDisable(GL_TEXTURE_2D);  Otherwise, 2d texturing is enabled, and  a
            number of multitexturing units are enabled sequentially, starting  with
            unit 0, e.g. glActiveTextureARB(GL_TEXTURE0_ARB);  glEnable
            (GL_TEXTURE_2D);
            </para>
            <para>
            inEnableLighting - enables or disables OpenGL lighting, e.g.
            glEnable(GL_LIGHTING); glEnable(GL_LIGHT0);
            </para>
            <para>
            inEnableAlphaTesting - enables or disables the alpha test per pixel, e.g.
            glEnable(GL_ALPHA_TEST);
            </para>
            <para>
            inEnableAlphaBlending - enables or disables alpha blending per pixel, e.g.
            glEnable(GL_BLEND);
            </para>
            <para>
            inEnableDepthTesting - enables per pixel depth testing, as in
            glEnable(GL_DEPTH_TEST);
            </para>
            <para>
            inEnableDepthWriting - enables writing back of depth information to the
            depth bufffer, as in glDepthMask(GL_TRUE);
            </para>
            <para>
            The purpose of this function is to change OpenGL state while keeping
            X-Plane aware of the state changes; this keeps X-Plane from getting
            surprised by OGL state changes, and prevents X-Plane and plug-ins from
            having to set all state before all draws; XPLMSetGraphicsState internally
            skips calls to change state that is already properly enabled.
            </para>
            <para>
            X-Plane does not have a 'default' OGL state to plug-ins; plug-ins should
            totally set OGL state before drawing.  Use XPLMSetGraphicsState instead of
            any of the above OpenGL calls.
            </para>
            <para>
            WARNING: Any routine that performs drawing (e.g. XPLMDrawString or widget
            code) may change X-Plane's state.  Always set state before drawing after
            unknown code has executed.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.BindTexture2d(System.Int32,System.Int32)">
            <summary>
            <para>
            XPLMBindTexture2d changes what texture is bound to the 2d texturing target.
            This routine caches the current 2d texture across all texturing units in
            the sim and plug-ins, preventing extraneous binding.  For example, consider
            several plug-ins running in series; if they all use the 'general interface'
            bitmap to do UI, calling this function will skip the rebinding of the
            general interface texture on all but the first plug-in, which can provide
            better frame rate son some graphics cards.
            </para>
            <para>
            inTextureID is the ID of the texture object to bind; inTextureUnit is a
            zero-based  texture unit (e.g. 0 for the first one), up to a maximum of 4
            units.  (This number may increase in future versions of X-Plane.)
            </para>
            <para>
            Use this routine instead of glBindTexture(GL_TEXTURE_2D, ....);
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.GenerateTextureNumbers(System.Int32*,System.Int32)">
            <summary>
            <para>
            This routine generates unused texture numbers that a plug-in can use to
            safely bind textures. Use this routine instead of glGenTextures;
            glGenTextures will allocate texture numbers in ranges that X-Plane reserves
            for its own use but does not always use; for example, it might provide an
            ID within the range of textures reserved for terrain...loading a new .env
            file as the plane flies might then cause X-Plane to use this texture ID.
            X-Plane will then  overwrite the plug-ins texture.  This routine returns
            texture IDs that are out of X-Plane's usage range.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.GetTexture(XP.SDK.XPLM.TextureID)">
            <summary>
            <para>
            XPLMGetTexture returns the OpenGL texture enumeration of an X-Plane texture
            based on a  generic identifying code.  For example, you can get the texture
            for X-Plane's UI bitmaps.  This allows you to build new gauges that take
            advantage of X-Plane's textures, for smooth artwork integration and also
            saving texture memory.  Note that the texture might not be loaded yet,
            depending on what the  plane's panel contains.
            </para>
            <para>
            OPEN ISSUE: We really need a way to make sure X-Plane loads this texture if
            it isn't around, or at least a way to find out whether it is loaded or not.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.WorldToLocal(System.Double,System.Double,System.Double,System.Double*,System.Double*,System.Double*)">
            <summary>
            <para>
            This routine translates coordinates from latitude, longitude, and altitude
            to local scene coordinates. Latitude and longitude are in decimal degrees,
            and altitude is in meters MSL (mean sea level).  The XYZ coordinates are in
            meters in the local OpenGL coordinate system.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.LocalToWorld(System.Double,System.Double,System.Double,System.Double*,System.Double*,System.Double*)">
            <summary>
            <para>
            This routine translates a local coordinate triplet back into latitude,
            longitude, and altitude.  Latitude and longitude are in decimal degrees,
            and altitude is in meters MSL (mean sea level).  The XYZ coordinates are in
            meters in the local OpenGL coordinate system.
            </para>
            <para>
            NOTE: world coordinates are less precise than local coordinates; you should
            try to avoid round tripping from local to world and back.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.DrawTranslucentDarkBox(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            This routine draws a translucent dark box, partially obscuring parts of the
            screen but making text easy to read.  This is the same graphics primitive
            used by X-Plane to show text files and ATC info.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.DrawString(System.Single*,System.Int32,System.Int32,System.Byte*,System.Int32*,XP.SDK.XPLM.FontID)">
            <summary>
            <para>
            This routine draws a NULL termianted string in a given font.  Pass in the
            lower left pixel that the character is to be drawn onto.  Also pass the
            character and font ID. This function returns the x offset plus the width of
            all drawn characters. The color to draw in is specified as a pointer to an
            array of three floating point colors, representing RGB intensities from 0.0
            to 1.0.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.DrawNumber(System.Single*,System.Int32,System.Int32,System.Double,System.Int32,System.Int32,System.Int32,XP.SDK.XPLM.FontID)">
            <summary>
            <para>
            This routine draws a number similar to the digit editing fields in
            PlaneMaker and data output display in X-Plane.  Pass in a color, a
            position, a floating point value, and formatting info.  Specify how many
            integer and how many decimal digits to show and  whether to show a sign, as
            well as a character set. This routine returns the xOffset plus width of the
            string drawn.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.GetFontDimensions(XP.SDK.XPLM.FontID,System.Int32*,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns the width and height of a character in a given font.
            It also tells you if the font only supports numeric digits.  Pass NULL if
            you don't need a given field.  Note that for a proportional font the width
            will be an arbitrary, hopefully average width.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.MeasureString(XP.SDK.XPLM.FontID,System.Byte*,System.Int32)">
            <summary>
            <para>
            This routine returns the width in pixels of a string using a given font.
            The string is passed as a pointer plus length (and does not need to be null
            terminated); this is used to allow for measuring substrings. The return
            value is floating point; it is possible that future font drawing may allow
            for fractional pixels.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Graphics.MeasureString(XP.SDK.XPLM.FontID,System.ReadOnlySpan{System.Char}@,System.Int32)">
            <summary>
            <para>
            This routine returns the width in pixels of a string using a given font.
            The string is passed as a pointer plus length (and does not need to be null
            terminated); this is used to allow for measuring substrings. The return
            value is floating point; it is possible that future font drawing may allow
            for fractional pixels.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.HandleCursorCallback">
            <summary>
            <para>
            The SDK calls your cursor status callback when the mouse is over your
            plugin window.  Return a cursor status code to indicate how you would like
            X-Plane to manage the cursor.  If you return xplm_CursorDefault, the SDK
            will try lower-Z-order plugin windows, then let the sim manage the cursor.
            </para>
            <para>
            Note: you should never show or hide the cursor yourself---these APIs are
            typically reference-counted and thus cannot safely and predictably be used
            by the SDK.  Instead return one of xplm_CursorHidden to hide the cursor or
            xplm_CursorArrow/xplm_CursorCustom to show the cursor.
            </para>
            <para>
            If you want to implement a custom cursor by drawing a cursor in OpenGL, use
            xplm_CursorHidden to hide the OS cursor and draw the cursor using a 2-d
            drawing callback (after xplm_Phase_Window is probably a good choice, but
            see deprecation warnings on the drawing APIs!).  If you want to use a
            custom OS-based cursor, use xplm_CursorCustom to ask X-Plane to show the
            cursor but not affect its image.  You can then use an OS specific call like
            SetThemeCursor (Mac) or SetCursor/LoadCursor (Windows).
            </para>
            <para>
            The units for x and y values match the units used in your window. Thus, for
            "modern" windows (those created via XPLMCreateWindowEx() and compiled
            against the XPLM300 library), the units are boxels, while legacy windows
            will get pixels. Legacy windows have their origin in the lower left of the
            main X-Plane window, while modern windows have their origin in the lower
            left of the global desktop space. In both cases, x increases as you move
            left, and y increases as you move up.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.HandleKeyCallback">
            <summary>
            <para>
            This function is called when a key is pressed or keyboard focus is taken
            away from your window.  If losingFocus is 1, you are losing the keyboard
            focus, otherwise a key was pressed and inKey contains its character.  You
            are also passed your window and a refcon.
            </para>
            <para>
            Warning: this API declares virtual keys as a signed character; however the
            VKEY #define macros in XPLMDefs.h define the vkeys using unsigned values
            (that is 0x80 instead of -0x80).  So you may need to cast the incoming vkey
            to an unsigned char to get correct comparisons in C.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.HandleMouseClickCallback">
            <summary>
            <para>
            You receive this call for one of three events:
            </para>
            <para>
            - when the user clicks the mouse button down - (optionally) when the user
            drags the mouse after a down-click, but before the up-click - when the user
            releases the down-clicked mouse button.
            </para>
            <para>
            You receive the x and y of the click, your window, and a refcon.  Return 1
            to consume the click, or 0 to pass it through.
            </para>
            <para>
            WARNING: passing clicks through windows (as of this writing) causes mouse
            tracking problems in X-Plane; do not use this feature!
            </para>
            <para>
            The units for x and y values match the units used in your window. Thus, for
            "modern" windows (those created via XPLMCreateWindowEx() and compiled
            against the XPLM300 library), the units are boxels, while legacy windows
            will get pixels. Legacy windows have their origin in the lower left of the
            main X-Plane window, while modern windows have their origin in the lower
            left of the global desktop space. In both cases, x increases as you move
            left, and y increases as you move up.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.HandleMouseWheelCallback">
            <summary>
            <para>
            The SDK calls your mouse wheel callback when one of the mouse wheels is
            scrolled within your window.  Return 1 to consume the mouse wheel movement
            or 0 to pass them on to a lower window.  (If your window appears opaque to
            the user, you should consume mouse wheel scrolling even if it does
            nothing.)  The number of "clicks" indicates how far the wheel was turned
            since the last callback. The wheel is 0 for the vertical axis or 1 for the
            horizontal axis (for OS/mouse combinations that support this).
            </para>
            <para>
            The units for x and y values match the units used in your window. Thus, for
            "modern" windows (those created via XPLMCreateWindowEx() and compiled
            against the XPLM300 library), the units are boxels, while legacy windows
            will get pixels. Legacy windows have their origin in the lower left of the
            main X-Plane window, while modern windows have their origin in the lower
            left of the global desktop space. In both cases, x increases as you move
            left, and y increases as you move up.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.HotKeyCallback">
            <summary>
            <para>
            Your hot key callback simply takes a pointer of your choosing.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.HotKeyID">
            <summary>
            <para>
            An opaque IDs used to identify a hot key.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Instance.CreateInstance(XP.SDK.XPLM.Internal.ObjectRef,System.Byte**)">
            <summary>
            <para>
            Registers an instance of an X-Plane object.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Instance.DestroyInstance(XP.SDK.XPLM.Internal.InstanceRef)">
            <summary>
            <para>
            Unregisters an instance.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Instance.InstanceSetPosition(XP.SDK.XPLM.Internal.InstanceRef,XP.SDK.XPLM.Internal.DrawInfo*,System.Single*)">
            <summary>
            <para>
            Updates both the position of the instance and all datarefs you registered
            for it.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.InstanceRef">
            <summary>
            <para>
            An opaque handle to an instance.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.KeySnifferCallback">
            <summary>
            <para>
            This is the prototype for a low level key-sniffing function.  Window-based
            UI _should not use this_!  The windowing system provides high-level
            mediated keyboard access, via the callbacks you attach to your
            XPLMCreateWindow_t. By comparison, the key sniffer provides low level
            keyboard access.
            </para>
            <para>
            Key sniffers are provided to allow libraries to provide non-windowed user
            interaction.  For example, the MUI library uses a key sniffer to do pop-up
            text entry.
            </para>
            <para>
            Return 1 to pass the key on to the next sniffer, the window manager,
            X-Plane, or whomever is down stream.  Return 0 to consume the key.
            </para>
            <para>
            Warning: this API declares virtual keys as a signed character; however the
            VKEY #define macros in XPLMDefs.h define the vkeys using unsigned values
            (that is 0x80 instead of -0x80).  So you may need to cast the incoming vkey
            to an unsigned char to get correct comparisons in C.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.LibraryEnumeratorCallback">
            <summary>
            <para>
            An XPLMLibraryEnumerator_f is a callback you provide that is called once
            for each library element that is located. The returned paths will be
            relative to the X-System folder.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.CreateMapLayer(XP.SDK.XPLM.Internal.CreateMapLayer*)">
            <summary>
            <para>
            This routine creates a new map layer. You pass in an XPLMCreateMapLayer_t
            structure with all of the fields set in.  You must set the structSize of
            the structure to the size of the actual structure you used.
            </para>
            <para>
            Returns NULL if the layer creation failed. This happens most frequently
            because the map you specified in your
            XPLMCreateMapLayer_t::mapToCreateLayerIn field doesn't exist (that is, if
            XPLMMapExists() returns 0 for the specified map). You can use
            XPLMRegisterMapCreationHook() to get a notification each time a new map is
            opened in X-Plane, at which time you can create layers in it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.DestroyMapLayer(XP.SDK.XPLM.Internal.MapLayerID)">
            <summary>
            <para>
            Destroys a map layer you created (calling your
            XPLMMapWillBeDeletedCallback_f if applicable). Returns true if a deletion
            took place.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.RegisterMapCreationHook(XP.SDK.XPLM.Internal.MapCreatedCallback,System.Void*)">
            <summary>
            <para>
            Registers your callback to receive a notification each time a new map is
            constructed in X-Plane. This callback is the best time to add your custom
            map layer using XPLMCreateMapLayer().
            </para>
            <para>
            Note that you will not be notified about any maps that already exist---you
            can use XPLMMapExists() to check for maps that were created previously.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.MapExists(System.Byte*)">
            <summary>
            <para>
            Returns 1 if the map with the specified identifier already exists in
            X-Plane. In that case, you can safely call XPLMCreateMapLayer() specifying
            that your layer should be added to that map.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.MapExists(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Returns 1 if the map with the specified identifier already exists in
            X-Plane. In that case, you can safely call XPLMCreateMapLayer() specifying
            that your layer should be added to that map.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.DrawMapIconFromSheet(XP.SDK.XPLM.Internal.MapLayerID,System.Byte*,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,XP.SDK.XPLM.MapOrientation,System.Single,System.Single)">
            <summary>
            <para>
            Enables plugin-created map layers to draw PNG icons using X-Plane's
            built-in icon drawing functionality. Only valid from within an
            XPLMIconDrawingCallback_t (but you can request an arbitrary number of icons
            to be drawn from within your callback).
            </para>
            <para>
            X-Plane will automatically manage the memory for your texture so that it
            only has to be loaded from disk once as long as you continue drawing it
            per-frame. (When you stop drawing it, the memory may purged in a "garbage
            collection" pass, require a load from disk in the future.)
            </para>
            <para>
            Instead of having X-Plane draw a full PNG, this method allows you to use UV
            coordinates to request a portion of the image to be drawn. This allows you
            to use a single texture load (of an icon sheet, for example) to draw many
            icons. Doing so is much more efficient than drawing a dozen different small
            PNGs.
            </para>
            <para>
            The UV coordinates used here treat the texture you load as being comprised
            of a number of identically sized "cells." You specify the width and height
            in cells (ds and dt, respectively), as well as the coordinates within the
            cell grid for the sub-image you'd like to draw.
            </para>
            <para>
            Note that you can use different ds and dt values in subsequent calls with
            the same texture sheet. This enables you to use icons of different sizes in
            the same sheet if you arrange them properly in the PNG.
            </para>
            <para>
            This function is only valid from within an XPLMIconDrawingCallback_t (but
            you can request an arbitrary number of icons to be drawn from within your
            callback).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.DrawMapIconFromSheet(XP.SDK.XPLM.Internal.MapLayerID,System.ReadOnlySpan{System.Char}@,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,XP.SDK.XPLM.MapOrientation,System.Single,System.Single)">
            <summary>
            <para>
            Enables plugin-created map layers to draw PNG icons using X-Plane's
            built-in icon drawing functionality. Only valid from within an
            XPLMIconDrawingCallback_t (but you can request an arbitrary number of icons
            to be drawn from within your callback).
            </para>
            <para>
            X-Plane will automatically manage the memory for your texture so that it
            only has to be loaded from disk once as long as you continue drawing it
            per-frame. (When you stop drawing it, the memory may purged in a "garbage
            collection" pass, require a load from disk in the future.)
            </para>
            <para>
            Instead of having X-Plane draw a full PNG, this method allows you to use UV
            coordinates to request a portion of the image to be drawn. This allows you
            to use a single texture load (of an icon sheet, for example) to draw many
            icons. Doing so is much more efficient than drawing a dozen different small
            PNGs.
            </para>
            <para>
            The UV coordinates used here treat the texture you load as being comprised
            of a number of identically sized "cells." You specify the width and height
            in cells (ds and dt, respectively), as well as the coordinates within the
            cell grid for the sub-image you'd like to draw.
            </para>
            <para>
            Note that you can use different ds and dt values in subsequent calls with
            the same texture sheet. This enables you to use icons of different sizes in
            the same sheet if you arrange them properly in the PNG.
            </para>
            <para>
            This function is only valid from within an XPLMIconDrawingCallback_t (but
            you can request an arbitrary number of icons to be drawn from within your
            callback).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.DrawMapLabel(XP.SDK.XPLM.Internal.MapLayerID,System.Byte*,System.Single,System.Single,XP.SDK.XPLM.MapOrientation,System.Single)">
            <summary>
            <para>
            Enables plugin-created map layers to draw text labels using X-Plane's
            built-in labeling functionality. Only valid from within an
            XPLMMapLabelDrawingCallback_f (but you can request an arbitrary number of
            text labels to be drawn from within your callback).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.DrawMapLabel(XP.SDK.XPLM.Internal.MapLayerID,System.ReadOnlySpan{System.Char}@,System.Single,System.Single,XP.SDK.XPLM.MapOrientation,System.Single)">
            <summary>
            <para>
            Enables plugin-created map layers to draw text labels using X-Plane's
            built-in labeling functionality. Only valid from within an
            XPLMMapLabelDrawingCallback_f (but you can request an arbitrary number of
            text labels to be drawn from within your callback).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.MapProject(XP.SDK.XPLM.Internal.MapProjectionID,System.Double,System.Double,System.Single*,System.Single*)">
            <summary>
            <para>
            Projects a latitude/longitude into map coordinates. This is the inverse of
            XPLMMapUnproject().
            </para>
            <para>
            Only valid from within a map layer callback (one of
            XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,
            XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.MapUnproject(XP.SDK.XPLM.Internal.MapProjectionID,System.Single,System.Single,System.Double*,System.Double*)">
            <summary>
            <para>
            Transforms map coordinates back into a latitude and longitude. This is the
            inverse of XPLMMapProject().
            </para>
            <para>
            Only valid from within a map layer callback (one of
            XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,
            XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.MapScaleMeter(XP.SDK.XPLM.Internal.MapProjectionID,System.Single,System.Single)">
            <summary>
            <para>
            Returns the number of map units that correspond to a distance of one meter
            at a given set of map coordinates.
            </para>
            <para>
            Only valid from within a map layer callback (one of
            XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,
            XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Map.MapGetNorthHeading(XP.SDK.XPLM.Internal.MapProjectionID,System.Single,System.Single)">
            <summary>
            <para>
            Returns the heading (in degrees clockwise from "up") that corresponds to
            north at a given point on the map. In other words, if your runway has a
            true heading of 360, you would use "north" as the Cartesian angle at which
            to draw the runway on the map. (You would add the result of
            XPLMMapGetNorthHeading() to your true heading to get the map angle.)
            </para>
            <para>
            This is necessary becuase X-Plane's map can be rotated to match your
            aircraft's orientation; north is not always "up."
            </para>
            <para>
            Only valid from within a map layer callback (one of
            XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,
            XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.MapCreatedCallback">
            <summary>
            <para>
            A callback to notify your plugin that a new map has been created in
            X-Plane. This is the best time to add a custom map layer using
            XPLMCreateMapLayer().
            </para>
            <para>
            No OpenGL drawing is permitted within this callback.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.MapDrawingCallback">
            <summary>
            <para>
            This is the OpenGL map drawing callback for plugin-created map layers. You
            can perform arbitrary OpenGL drawing from this callback, with one
            exception: changes to the Z-buffer are not permitted, and will result in
            map drawing errors.
            </para>
            <para>
            All drawing done from within this callback appears beneath all built-in
            X-Plane icons and labels, but above the built-in "fill" layers (layers
            providing major details, like terrain and water). Note, however, that the
            relative ordering between the drawing callbacks of different plugins is not
            guaranteed.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.MapIconDrawingCallback">
            <summary>
            <para>
            This is the icon drawing callback that enables plugin-created map layers to
            draw icons using X-Plane's built-in icon drawing functionality. You can
            request an arbitrary number of PNG icons to be drawn via
            XPLMDrawMapIconFromSheet() from within this callback, but you may not
            perform any OpenGL drawing here.
            </para>
            <para>
            Icons enqueued by this function will appear above all OpenGL drawing
            (performed by your optional XPLMMapDrawingCallback_f), and above all
            built-in X-Plane map icons of the same layer type ("fill" or "markings," as
            determined by the XPLMMapLayerType in your XPLMCreateMapLayer_t). Note,
            however, that the relative ordering between the drawing callbacks of
            different plugins is not guaranteed.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.MapLabelDrawingCallback">
            <summary>
            <para>
            This is the label drawing callback that enables plugin-created map layers
            to draw text labels using X-Plane's built-in labeling functionality. You
            can request an arbitrary number of text labels to be drawn via
            XPLMDrawMapLabel() from within this callback, but you may not perform any
            OpenGL drawing here.
            </para>
            <para>
            Labels enqueued by this function will appear above all OpenGL drawing
            (performed by your optional XPLMMapDrawingCallback_f), and above all
            built-in map icons and labels of the same layer type ("fill" or "markings,"
            as determined by the XPLMMapLayerType in your XPLMCreateMapLayer_t). Note,
            however, that the relative ordering between the drawing callbacks of
            different plugins is not guaranteed.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.MapLayerID">
            <summary>
            <para>
            This is an opaque handle for a plugin-created map layer. Pass it to the map
            drawing APIs from an appropriate callback to draw in the layer you created.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.MapPrepareCacheCallback">
            <summary>
            <para>
            A callback used to allow you to cache whatever information your layer needs
            to draw in the current map area.
            </para>
            <para>
            This is called each time the map's total bounds change. This is typically
            triggered by new DSFs being loaded, such that X-Plane discards old,
            now-distant DSFs and pulls in new ones. At that point, the available bounds
            of the map also change to match the new DSF area.
            </para>
            <para>
            By caching just the information you need to draw in this area, your future
            draw calls can be made faster, since you'll be able to simply "splat" your
            precomputed information each frame.
            </para>
            <para>
            We guarantee that the map projection will not change between successive
            prepare cache calls, nor will any draw call give you bounds outside these
            total map bounds. So, if you cache the projected map coordinates of all the
            items you might want to draw in the total map area, you can be guaranteed
            that no draw call will be asked to do any new work.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.MapProjectionID">
            <summary>
            <para>
            This is an opaque handle for a map projection. Pass it to the projection
            APIs to translate between map coordinates and latitude/longitudes.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.MapWillBeDeletedCallback">
            <summary>
            <para>
            Called just before your map layer gets deleted. Because SDK-created map
            layers have the same lifetime as the X-Plane map that contains them, if the
            map gets unloaded from memory, your layer will too.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.MenuHandlerCallback">
            <summary>
            <para>
            A menu handler function takes two reference pointers, one for the menu
            (specified when the menu was created) and one for the item (specified when
            the item was created).
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.MenuID">
            <summary>
            <para>
            This is a unique ID for each menu you create.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.FindPluginsMenu">
            <summary>
            <para>
            This function returns the ID of the plug-ins menu, which is created for you
            at startup.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.FindAircraftMenu">
            <summary>
            <para>
            This function returns the ID of the menu for the currently-loaded aircraft,
            used for showing aircraft-specific commands.
            </para>
            <para>
            The aircraft menu is created by X-Plane at startup, but it remains hidden
            until it is populated via XPLMAppendMenuItem() or
            XPLMAppendMenuItemWithCommand().
            </para>
            <para>
            Only plugins loaded with the user's current aircraft are allowed to access
            the aircraft menu. For all other plugins, this will return NULL, and any
            attempts to add menu items to it will fail.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.CreateMenu(System.Byte*,XP.SDK.XPLM.Internal.MenuID,System.Int32,XP.SDK.XPLM.Internal.MenuHandlerCallback,System.Void*)">
            <summary>
            <para>
            This function creates a new menu and returns its ID.  It returns NULL if
            the menu cannot be created.  Pass in a parent menu ID and an item index to
            create a submenu, or NULL for the parent menu to put the menu in the menu
            bar.  The menu's name is only used if the menu is in the menubar.  You also
            pass a handler function and a menu reference value. Pass NULL for the
            handler if you do not need callbacks from the menu (for example, if it only
            contains submenus).
            </para>
            <para>
            Important: you must pass a valid, non-empty menu title even if the menu is
            a submenu where the title is not visible.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.CreateMenu(System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.Internal.MenuID,System.Int32,XP.SDK.XPLM.Internal.MenuHandlerCallback,System.Void*)">
            <summary>
            <para>
            This function creates a new menu and returns its ID.  It returns NULL if
            the menu cannot be created.  Pass in a parent menu ID and an item index to
            create a submenu, or NULL for the parent menu to put the menu in the menu
            bar.  The menu's name is only used if the menu is in the menubar.  You also
            pass a handler function and a menu reference value. Pass NULL for the
            handler if you do not need callbacks from the menu (for example, if it only
            contains submenus).
            </para>
            <para>
            Important: you must pass a valid, non-empty menu title even if the menu is
            a submenu where the title is not visible.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.DestroyMenu(XP.SDK.XPLM.Internal.MenuID)">
            <summary>
            <para>
            This function destroys a menu that you have created.  Use this to remove a
            submenu if necessary.  (Normally this function will not be necessary.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.ClearAllMenuItems(XP.SDK.XPLM.Internal.MenuID)">
            <summary>
            <para>
            This function removes all menu items from a menu, allowing you to rebuild
            it.  Use this function if you need to change the number of items on a menu.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.AppendMenuItem(XP.SDK.XPLM.Internal.MenuID,System.Byte*,System.Void*,System.Int32)">
            <summary>
            <para>
            This routine appends a new menu item to the bottom of a menu and returns
            its index. Pass in the menu to add the item to, the items name, and a void
            * ref for this item.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            <para>
            Note that all menu indices returned are relative to your plugin's menus
            only; if your plugin creates two sub-menus in the Plugins menu at different
            times, it doesn't matter how many other plugins also create sub-menus of
            Plugins in the intervening time: your sub-menus will be given menu indices
            0 and 1. (The SDK does some work in the back-end to filter out menus that
            are irrelevant to your plugin in order to deliver this consistency for each
            plugin.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.AppendMenuItem(XP.SDK.XPLM.Internal.MenuID,System.ReadOnlySpan{System.Char}@,System.Void*,System.Int32)">
            <summary>
            <para>
            This routine appends a new menu item to the bottom of a menu and returns
            its index. Pass in the menu to add the item to, the items name, and a void
            * ref for this item.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            <para>
            Note that all menu indices returned are relative to your plugin's menus
            only; if your plugin creates two sub-menus in the Plugins menu at different
            times, it doesn't matter how many other plugins also create sub-menus of
            Plugins in the intervening time: your sub-menus will be given menu indices
            0 and 1. (The SDK does some work in the back-end to filter out menus that
            are irrelevant to your plugin in order to deliver this consistency for each
            plugin.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.AppendMenuItemWithCommand(XP.SDK.XPLM.Internal.MenuID,System.Byte*,XP.SDK.XPLM.Internal.CommandRef)">
            <summary>
            <para>
            Like XPLMAppendMenuItem(), but instead of the new menu item triggering the
            XPLMMenuHandler_f of the containiner menu, it will simply execute the
            command you pass in. Using a command for your menu item allows the user to
            bind a keyboard shortcut to the command and see that shortcut represented
            in the menu.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            <para>
            Like XPLMAppendMenuItem(), all menu indices are relative to your plugin's
            menus only.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.AppendMenuItemWithCommand(XP.SDK.XPLM.Internal.MenuID,System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.Internal.CommandRef)">
            <summary>
            <para>
            Like XPLMAppendMenuItem(), but instead of the new menu item triggering the
            XPLMMenuHandler_f of the containiner menu, it will simply execute the
            command you pass in. Using a command for your menu item allows the user to
            bind a keyboard shortcut to the command and see that shortcut represented
            in the menu.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            <para>
            Like XPLMAppendMenuItem(), all menu indices are relative to your plugin's
            menus only.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.AppendMenuSeparator(XP.SDK.XPLM.Internal.MenuID)">
            <summary>
            <para>
            This routine adds a separator to the end of a menu.
            </para>
            <para>
            Returns a negative index if the append failed (due to an invalid parent
            menu argument).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.SetMenuItemName(XP.SDK.XPLM.Internal.MenuID,System.Int32,System.Byte*,System.Int32)">
            <summary>
            <para>
            This routine changes the name of an existing menu item.  Pass in the menu
            ID and the index of the menu item.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.SetMenuItemName(XP.SDK.XPLM.Internal.MenuID,System.Int32,System.ReadOnlySpan{System.Char}@,System.Int32)">
            <summary>
            <para>
            This routine changes the name of an existing menu item.  Pass in the menu
            ID and the index of the menu item.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.CheckMenuItem(XP.SDK.XPLM.Internal.MenuID,System.Int32,XP.SDK.XPLM.MenuCheck)">
            <summary>
            <para>
            Set whether a menu item is checked.  Pass in the menu ID and item index.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.CheckMenuItemState(XP.SDK.XPLM.Internal.MenuID,System.Int32,XP.SDK.XPLM.MenuCheck*)">
            <summary>
            <para>
            This routine returns whether a menu item is checked or not. A menu item's
            check mark may be on or off, or a menu may not have an icon at all.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.EnableMenuItem(XP.SDK.XPLM.Internal.MenuID,System.Int32,System.Int32)">
            <summary>
            <para>
            Sets whether this menu item is enabled.  Items start out enabled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Menus.RemoveMenuItem(XP.SDK.XPLM.Internal.MenuID,System.Int32)">
            <summary>
            <para>
            Removes one item from a menu.  Note that all menu items below are moved up
            one; your plugin must track the change in index numbers.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.GetFirstNavAid">
            <summary>
            <para>
            This returns the very first navaid in the database.  Use this to traverse
            the entire database.  Returns XPLM_NAV_NOT_FOUND if the nav database is
            empty.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.GetNextNavAid(XP.SDK.XPLM.Internal.NavRef)">
            <summary>
            <para>
            Given a nav aid ref, this routine returns the next navaid.  It returns
            XPLM_NAV_NOT_FOUND if the nav aid passed in was invalid or if the navaid
            passed in was the last one in the database.  Use this routine to iterate
            across all like-typed navaids or the entire database.
            </para>
            <para>
            WARNING: due to a bug in the SDK, when fix loading is disabled in the
            rendering settings screen, calling this routine with the last airport
            returns a bogus nav aid.  Using this nav aid can crash X-Plane.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.FindFirstNavAidOfType(XP.SDK.XPLM.NavType)">
            <summary>
            <para>
            This routine returns the ref of the first navaid of the given type in the
            database or XPLM_NAV_NOT_FOUND if there are no navaids of that type in the
            database.  You must pass exactly one nav aid type to this routine.
            </para>
            <para>
            WARNING: due to a bug in the SDK, when fix loading is disabled in the
            rendering settings screen, calling this routine with fixes returns a bogus
            nav aid.  Using this nav aid can crash X-Plane.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.FindLastNavAidOfType(XP.SDK.XPLM.NavType)">
            <summary>
            <para>
            This routine returns the ref of the last navaid of the given type in the
            database or XPLM_NAV_NOT_FOUND if there are no navaids of that type in the
            database.  You must pass exactly one nav aid type to this routine.
            </para>
            <para>
            WARNING: due to a bug in the SDK, when fix loading is disabled in the
            rendering settings screen, calling this routine with fixes returns a bogus
            nav aid.  Using this nav aid can crash X-Plane.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.FindNavAid(System.Byte*,System.Byte*,System.Single*,System.Single*,System.Int32*,XP.SDK.XPLM.NavType)">
            <summary>
            <para>
            This routine provides a number of searching capabilities for the nav
            database. XPLMFindNavAid will search through every nav aid whose type is
            within inType (multiple types may be added together) and return any
            nav-aids found based  on the following rules:
            </para>
            <para>
            If inLat and inLon are not NULL, the navaid nearest to that lat/lon will be
            returned, otherwise the last navaid found will be returned.
            </para>
            <para>
            If inFrequency is not NULL, then any navaids considered must match this
            frequency.  Note that this will screen out radio beacons that do not have
            frequency data published (like inner markers) but not fixes and airports.
            </para>
            <para>
            If inNameFragment is not NULL, only navaids that contain the fragment in
            their name will be returned.
            </para>
            <para>
            If inIDFragment is not NULL, only navaids that contain the fragment in
            their IDs will be returned.
            </para>
            <para>
            This routine provides a simple way to do a number of useful searches:
            </para>
            <para>
            Find the nearest navaid on this frequency. Find the nearest airport. Find
            the VOR whose ID is "KBOS". Find the nearest airport whose name contains
            "Chicago".
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.FindNavAid(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char}@,System.Single*,System.Single*,System.Int32*,XP.SDK.XPLM.NavType)">
            <summary>
            <para>
            This routine provides a number of searching capabilities for the nav
            database. XPLMFindNavAid will search through every nav aid whose type is
            within inType (multiple types may be added together) and return any
            nav-aids found based  on the following rules:
            </para>
            <para>
            If inLat and inLon are not NULL, the navaid nearest to that lat/lon will be
            returned, otherwise the last navaid found will be returned.
            </para>
            <para>
            If inFrequency is not NULL, then any navaids considered must match this
            frequency.  Note that this will screen out radio beacons that do not have
            frequency data published (like inner markers) but not fixes and airports.
            </para>
            <para>
            If inNameFragment is not NULL, only navaids that contain the fragment in
            their name will be returned.
            </para>
            <para>
            If inIDFragment is not NULL, only navaids that contain the fragment in
            their IDs will be returned.
            </para>
            <para>
            This routine provides a simple way to do a number of useful searches:
            </para>
            <para>
            Find the nearest navaid on this frequency. Find the nearest airport. Find
            the VOR whose ID is "KBOS". Find the nearest airport whose name contains
            "Chicago".
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.GetNavAidInfo(XP.SDK.XPLM.Internal.NavRef,XP.SDK.XPLM.NavType*,System.Single*,System.Single*,System.Single*,System.Int32*,System.Single*,System.Byte*,System.Byte*,System.Byte*)">
            <summary>
            <para>
            This routine returns information about a navaid.  Any non-null field is
            filled out with information if it is available.
            </para>
            <para>
            Frequencies are in the nav.dat convention as described in the X-Plane nav
            database FAQ: NDB frequencies are exact, all others are multiplied by 100.
            </para>
            <para>
            The buffer for IDs should be at least 6 chars and the buffer for names
            should be at least 41 chars, but since these values are likely to go up, I
            recommend passing at least 32 chars for IDs and 256 chars for names when
            possible.
            </para>
            <para>
            The outReg parameter tells if the navaid is within the local "region" of
            loaded DSFs.  (This information may not be particularly useful to plugins.)
            The parameter is a single byte value 1 for true or 0 for false, not a C
            string.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.CountFMSEntries">
            <summary>
            <para>
            This routine returns the number of entries in the FMS.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.GetDisplayedFMSEntry">
            <summary>
            <para>
            This routine returns the index of the entry the pilot is viewing.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.GetDestinationFMSEntry">
            <summary>
            <para>
            This routine returns the index of the entry the FMS is flying to.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.SetDisplayedFMSEntry(System.Int32)">
            <summary>
            <para>
            This routine changes which entry the FMS is showing to the index specified.
            *
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.SetDestinationFMSEntry(System.Int32)">
            <summary>
            <para>
            This routine changes which entry the FMS is flying the aircraft toward.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.GetFMSEntryInfo(System.Int32,XP.SDK.XPLM.NavType*,System.Byte*,XP.SDK.XPLM.Internal.NavRef*,System.Int32*,System.Single*,System.Single*)">
            <summary>
            <para>
            This routine returns information about a given FMS entry.  A reference to a
            navaid can be returned allowing you to find additional information (such as
            a frequency, ILS heading, name, etc.).  Some information is available
            immediately.  For a lat/lon entry, the lat/lon is returned by this routine
            but the navaid cannot be looked up (and the reference will be
            XPLM_NAV_NOT_FOUND. FMS name entry buffers should be at least 256 chars in
            length.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.SetFMSEntryInfo(System.Int32,XP.SDK.XPLM.Internal.NavRef,System.Int32)">
            <summary>
            <para>
            This routine changes an entry in the FMS to have the destination navaid
            passed in and the altitude specified.  Use this only for airports, fixes,
            and radio-beacon navaids.  Currently of radio beacons, the FMS can only
            support VORs and NDBs. Use the routines below to clear or fly to a lat/lon.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.SetFMSEntryLatLon(System.Int32,System.Single,System.Single,System.Int32)">
            <summary>
            <para>
            This routine changes the entry in the FMS to a lat/lon entry with the given
            coordinates.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.ClearFMSEntry(System.Int32)">
            <summary>
            <para>
            This routine clears the given entry, potentially shortening the flight
            plan.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.GetGPSDestinationType">
            <summary>
            <para>
            This routine returns the type of the currently selected GPS destination,
            one of fix, airport, VOR or NDB.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Navigation.GetGPSDestination">
            <summary>
            <para>
            This routine returns the current GPS destination.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.NavRef">
            <summary>
            <para>
            XPLMNavRef is an iterator into the navigation database.  The navigation
            database is essentially an array, but it is not necessarily densely
            populated. The only assumption you can safely make is that like-typed
            nav-aids are  grouped together.
            </para>
            <para>
            Use XPLMNavRef to refer to a nav-aid.
            </para>
            <para>
            XPLM_NAV_NOT_FOUND is returned by functions that return an XPLMNavRef when
            the iterator must be invalid.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.ObjectLoadedCallback">
            <summary>
            <para>
            You provide this callback when loading an object asynchronously; it will be
            called once the object is loaded. Your refcon is passed back. The object
            ref passed in is the newly loaded object (ready for use) or NULL if an
            error occured.
            </para>
            <para>
            If your plugin is disabled, this callback will be delivered as soon as the
            plugin is re-enabled. If your plugin is unloaded before this callback is
            ever called, the SDK will release the object handle for you.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.ObjectRef">
            <summary>
            <para>
            An XPLMObjectRef is a opaque handle to an .obj file that has been loaded
            into memory.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.PlaneDrawState">
            <summary>
            <para>
            This structure contains additional plane parameter info to be passed to
            draw plane.  Make sure to fill in the size of the structure field with
            sizeof(XPLMDrawPlaneState_t) so that the XPLM can tell how many fields you
            knew about when compiling your plugin (since more fields may be added
            later).
            </para>
            <para>
            Most of these fields are ratios from 0 to 1 for control input.  X-Plane
            calculates what the actual controls look like based on the .acf file for
            that airplane.  Note for the yoke inputs, this is what the pilot of the
            plane has commanded (post artificial stability system if there were one)
            and affects aelerons, rudder, etc.  It is not  necessarily related to the
            actual position of the plane!
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.SetUsersAircraft(System.Byte*)">
            <summary>
            <para>
            This routine changes the user's aircraft.  Note that this will reinitialize
            the user to be on the nearest airport's first runway.  Pass in a full path
            (hard drive and everything including the .acf extension) to the .acf file.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.SetUsersAircraft(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine changes the user's aircraft.  Note that this will reinitialize
            the user to be on the nearest airport's first runway.  Pass in a full path
            (hard drive and everything including the .acf extension) to the .acf file.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.PlaceUserAtAirport(System.Byte*)">
            <summary>
            <para>
            This routine places the user at a given airport.  Specify the airport by
            its ICAO code (e.g. 'KBOS').
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.PlaceUserAtAirport(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine places the user at a given airport.  Specify the airport by
            its ICAO code (e.g. 'KBOS').
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.PlaceUserAtLocation(System.Double,System.Double,System.Single,System.Single,System.Single)">
            <summary>
            <para>
            Places the user at a specific location after performing any necessary
            scenery loads.
            </para>
            <para>
            As with in-air starts initiated from the X-Plane user interface, the
            aircraft will always start with its engines running, regardless of the
            user's preferences (i.e., regardless of what the dataref
            sim/operation/prefs/startup_running says).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.CountAircraft(System.Int32*,System.Int32*,XP.SDK.XPLM.Internal.PluginID*)">
            <summary>
            <para>
            This function returns the number of aircraft X-Plane is capable of having,
            as well as the number of aircraft that are currently active.  These numbers
            count the user's aircraft.  It can also return the plugin that is currently
            controlling aircraft.  In X-Plane 7, this routine reflects the number of
            aircraft the user has enabled in the rendering options window.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.GetNthAircraftModel(System.Int32,System.Byte*,System.Byte*)">
            <summary>
            <para>
            This function returns the aircraft model for the Nth aircraft.  Indices are
            zero based, with zero being the user's aircraft.  The file name should be
            at least 256 chars in length; the path should be at least 512 chars in
            length.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.AcquirePlanes(System.Byte**,XP.SDK.XPLM.Internal.PlanesAvailableCallback,System.Void*)">
            <summary>
            <para>
            XPLMAcquirePlanes grants your plugin exclusive access to the aircraft.  It
            returns 1 if you gain access, 0 if you do not. inAircraft - pass in an
            array of pointers to strings specifying the planes you want loaded.  For
            any plane index you do not want loaded, pass a 0-length string.  Other
            strings should be full paths with the .acf extension.  NULL terminates this
            array, or pass NULL if there are no planes you want loaded. If you pass in
            a callback and do not receive access to the planes your callback will be
            called when the airplanes are available. If you do receive airplane access,
            your callback will not be called.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.ReleasePlanes">
            <summary>
            <para>
            Call this function to release access to the planes.  Note that if you are
            disabled, access to planes is released for you and you must reacquire it.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.SetActiveAircraftCount(System.Int32)">
            <summary>
            <para>
            This routine sets the number of active planes.  If you pass in a number
            higher than the total number of planes availables, only the total number of
            planes available is actually used.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.SetAircraftModel(System.Int32,System.Byte*)">
            <summary>
            <para>
            This routine loads an aircraft model.  It may only be called if you  have
            exclusive access to the airplane APIs.  Pass in the path of the  model with
            the .acf extension.  The index is zero based, but you  may not pass in 0
            (use XPLMSetUsersAircraft to load the user's aircracft).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.SetAircraftModel(System.Int32,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine loads an aircraft model.  It may only be called if you  have
            exclusive access to the airplane APIs.  Pass in the path of the  model with
            the .acf extension.  The index is zero based, but you  may not pass in 0
            (use XPLMSetUsersAircraft to load the user's aircracft).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.DisableAIForPlane(System.Int32)">
            <summary>
            <para>
            This routine turns off X-Plane's AI for a given plane.  The plane will
            continue to draw and be a real plane in X-Plane, but will not  move itself.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.DrawAircraft(System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32,XP.SDK.XPLM.Internal.PlaneDrawState*)">
            <summary>
            <para>
            This routine draws an aircraft.  It can only be called from a 3-d drawing
            callback.  Pass in the position of the plane in OpenGL local coordinates
            and the orientation of the plane.  A 1 for full drawing indicates that the
            whole plane must be drawn; a 0 indicates you only need the nav lights
            drawn. (This saves rendering time when planes are far away.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Planes.ReinitUsersPlane">
            <summary>
            <para>
            This function recomputes the derived flight model data from the aircraft
            structure in memory.  If you have used the data access layer to modify the
            aircraft structure, use this routine to resynchronize X-Plane; since
            X-Plane works at least partly from derived values, the sim will not behave
            properly until this is called.
            </para>
            <para>
            WARNING: this routine does not necessarily place the airplane at the
            airport; use XPLMSetUsersAircraft to be compatible.  This routine is
            provided to do special experimentation with flight models without resetting
            flight.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.PlanesAvailableCallback">
            <summary>
            <para>
            Your airplanes available callback is called when another plugin gives up
            access to the multiplayer planes.  Use this to wait for access to
            multiplayer.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.GetMyID">
            <summary>
            <para>
            This routine returns the plugin ID of the calling plug-in.  Call this to
            get your own ID.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.CountPlugins">
            <summary>
            <para>
            This routine returns the total number of plug-ins that are loaded, both
            disabled and enabled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.GetNthPlugin(System.Int32)">
            <summary>
            <para>
            This routine returns the ID of a plug-in by index.  Index is 0 based from 0
            to XPLMCountPlugins-1, inclusive. Plugins may be returned in any arbitrary
            order.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.FindPluginByPath(System.Byte*)">
            <summary>
            <para>
            This routine returns the plug-in ID of the plug-in whose file exists at the
            passed in absolute file system path.  XPLM_NO_PLUGIN_ID is returned if the
            path does not point to a currently loaded plug-in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.FindPluginByPath(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine returns the plug-in ID of the plug-in whose file exists at the
            passed in absolute file system path.  XPLM_NO_PLUGIN_ID is returned if the
            path does not point to a currently loaded plug-in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.FindPluginBySignature(System.Byte*)">
            <summary>
            <para>
            This routine returns the plug-in ID of the plug-in whose signature matches
            what is passed in or XPLM_NO_PLUGIN_ID if no running plug-in has this
            signature.  Signatures are the best way to identify another plug-in as they
            are independent of the file system path of a plug-in or the human-readable
            plug-in name, and should be unique for all plug-ins.  Use this routine to
            locate another plugin that your plugin interoperates with
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.FindPluginBySignature(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine returns the plug-in ID of the plug-in whose signature matches
            what is passed in or XPLM_NO_PLUGIN_ID if no running plug-in has this
            signature.  Signatures are the best way to identify another plug-in as they
            are independent of the file system path of a plug-in or the human-readable
            plug-in name, and should be unique for all plug-ins.  Use this routine to
            locate another plugin that your plugin interoperates with
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.GetPluginInfo(XP.SDK.XPLM.Internal.PluginID,System.Byte*,System.Byte*,System.Byte*,System.Byte*)">
            <summary>
            <para>
            This routine returns information about a plug-in.  Each parameter should be
            a pointer to a buffer of at least 256 characters, or NULL to not receive
            the information.
            </para>
            <para>
            outName - the human-readable name of the plug-in.   outFilePath - the
            absolute file path to the file that contains this plug-in. outSignature - a
            unique string that identifies this plug-in. outDescription - a
            human-readable description of this plug-in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.IsPluginEnabled(XP.SDK.XPLM.Internal.PluginID)">
            <summary>
            <para>
            Returns whether the specified plug-in is enabled for running.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.EnablePlugin(XP.SDK.XPLM.Internal.PluginID)">
            <summary>
            <para>
            This routine enables a plug-in if it is not already enabled.  It returns 1
            if the plugin was enabled or successfully enables itself, 0 if it does not.
            Plugins may fail to enable (for example, if resources cannot be acquired)
            by returning 0 from their XPluginEnable callback.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.DisablePlugin(XP.SDK.XPLM.Internal.PluginID)">
            <summary>
            <para>
            This routine disableds an enabled plug-in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.ReloadPlugins">
            <summary>
            <para>
            This routine reloads all plug-ins.  Once this routine is called and you
            return from the callback you were within (e.g. a menu select callback) you
            will receive your XPluginDisable and XPluginStop callbacks and your  DLL
            will be unloaded, then the start process happens as if the sim was starting
            up.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.SendMessageToPlugin(XP.SDK.XPLM.Internal.PluginID,System.Int32,System.Void*)">
            <summary>
            <para>
            This function sends a message to another plug-in or X-Plane.  Pass
            XPLM_NO_PLUGIN_ID to broadcast to all plug-ins.  Only enabled plug-ins with
            a message receive function receive the message.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.HasFeature(System.Byte*)">
            <summary>
            <para>
            This returns 1 if the given installation of X-Plane supports a feature, or
            0 if it does not.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.HasFeature(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This returns 1 if the given installation of X-Plane supports a feature, or
            0 if it does not.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.IsFeatureEnabled(System.Byte*)">
            <summary>
            <para>
            This returns 1 if a feature is currently enabled for your plugin, or 0 if
            it is not enabled.  It is an error to call this routine with an unsupported
            feature.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.IsFeatureEnabled(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This returns 1 if a feature is currently enabled for your plugin, or 0 if
            it is not enabled.  It is an error to call this routine with an unsupported
            feature.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.EnableFeature(System.Byte*,System.Int32)">
            <summary>
            <para>
            This routine enables or disables a feature for your plugin.  This will
            change the running behavior of X-Plane and your plugin in some way,
            depending on the feature.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.EnableFeature(System.ReadOnlySpan{System.Char}@,System.Int32)">
            <summary>
            <para>
            This routine enables or disables a feature for your plugin.  This will
            change the running behavior of X-Plane and your plugin in some way,
            depending on the feature.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Plugin.EnumerateFeatures(XP.SDK.XPLM.Internal.FeatureEnumeratorCallback,System.Void*)">
            <summary>
            <para>
            This routine calls your enumerator callback once for each feature that this
            running version of X-Plane supports. Use this routine to determine all of
            the features that X-Plane can support.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.PluginID">
            <summary>
            <para>
            Each plug-in is identified by a unique integer ID.  This ID can be used to
            disable or enable a plug-in, or discover what plug-in is 'running' at the
            time.  A plug-in ID is unique within the currently running instance of
            X-Plane unless plug-ins are reloaded.  Plug-ins may receive a different
            unique ID each time they are loaded.
            </para>
            <para>
            For persistent identification of plug-ins, use XPLMFindPluginBySignature in
            XPLMUtiltiies.h
            </para>
            <para>
            -1 indicates no plug-in.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.ProbeInfo">
            <summary>
            <para>
            XPLMProbeInfo_t contains the results of a probe call. Make sure to set
            structSize to the size of the struct before using it.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.ProbeRef">
            <summary>
            <para>
            An XPLMProbeRef is an opaque handle to a probe, used for querying the
            terrain.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Processing.GetElapsedTime">
            <summary>
            <para>
            This routine returns the elapsed time since the sim started up in decimal
            seconds.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Processing.GetCycleNumber">
            <summary>
            <para>
            This routine returns a counter starting at zero for each sim cycle
            computed/video frame rendered.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Processing.RegisterFlightLoopCallback(XP.SDK.XPLM.Internal.FlightLoopCallback,System.Single,System.Void*)">
            <summary>
            <para>
            This routine registers your flight loop callback. Pass in a pointer to a
            flight loop function and a refcon. inInterval defines when you will be
            called. Pass in a positive number to specify seconds from registration time
            to the next callback. Pass in a negative number to indicate when you will
            be called (e.g. pass -1 to be called at the next cylcle). Pass 0 to not be
            called; your callback will be inactive.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Processing.UnregisterFlightLoopCallback(XP.SDK.XPLM.Internal.FlightLoopCallback,System.Void*)">
            <summary>
            <para>
            This routine unregisters your flight loop callback. Do NOT call it from
            your flight loop callback. Once your flight loop callback is unregistered,
            it will not be called again.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Processing.SetFlightLoopCallbackInterval(XP.SDK.XPLM.Internal.FlightLoopCallback,System.Single,System.Int32,System.Void*)">
            <summary>
            <para>
            This routine sets when a callback will be called. Do NOT call it from your
            callback; use the return value of the callback to change your callback
            interval from inside your callback.
            </para>
            <para>
            inInterval is formatted the same way as in XPLMRegisterFlightLoopCallback;
            positive for seconds, negative for cycles, and 0 for deactivating the
            callback. If inRelativeToNow is 1, times are from the time of this call;
            otherwise they are from the time the callback was last called (or the time
            it was registered if it has never been called.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Processing.CreateFlightLoop(XP.SDK.XPLM.Internal.CreateFlightLoop*)">
            <summary>
            <para>
            This routine creates a flight loop callback and returns its ID. The flight
            loop callback is created using the input param struct, and is inited to be
            unscheduled.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Processing.DestroyFlightLoop(XP.SDK.XPLM.Internal.FlightLoopID)">
            <summary>
            <para>
            This routine destroys a flight loop callback by ID.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Processing.ScheduleFlightLoop(XP.SDK.XPLM.Internal.FlightLoopID,System.Single,System.Int32)">
            <summary>
            <para>
            This routine schedules a flight loop callback for future execution. If
            inInterval is negative, it is run in a certain number of frames based on
            the absolute value of the input. If the interval is positive, it is a
            duration in seconds.
            </para>
            <para>
            If inRelativeToNow is true, ties are interpretted relative to the time this
            routine is called; otherwise they are relative to the last call time or the
            time the flight loop was registered (if never called).
            </para>
            <para>
            THREAD SAFETY: it is legal to call this routine from any thread under the
            following conditions:
            </para>
            <para>
            1. The call must be between the beginning of an XPLMEnable and the end of
            an XPLMDisable sequence. (That is, you must not call this routine from
            thread activity when your plugin was supposed to be disabled. Since plugins
            are only enabled while loaded, this also implies you cannot run this
            routine outside an XPLMStart/XPLMStop sequence.)
            </para>
            <para>
            2. You may not call this routine re-entrantly for a single flight loop ID.
            (That is, you can't enable from multiple threads at the same time.)
            </para>
            <para>
            3. You must call this routine between the time after XPLMCreateFlightLoop
            returns a value and the time you call XPLMDestroyFlightLoop. (That is, you
            must ensure that your threaded activity is within the life of the object.
            The SDK does not check this for you, nor does it synchronize destruction of
            the object.)
            </para>
            <para>
            4. The object must be unscheduled if this routine is to be called from a
            thread other than the main thread.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.ReceiveMonitorBoundsGlobalCallback">
            <summary>
            <para>
            This function is informed of the global bounds (in boxels) of a particular
            monitor within the X-Plane global desktop space. Note that X-Plane must be
            running in full screen on a monitor in order for that monitor to be passed
            to you in this callback.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.ReceiveMonitorBoundsOSCallback">
            <summary>
            <para>
            This function is informed of the global bounds (in pixels) of a particular
            monitor within the operating system's global desktop space. Note that a
            monitor index being passed to you here does not indicate that X-Plane is
            running in full screen on this monitor, or even that any X-Plane windows
            exist on this monitor.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.CreateProbe(XP.SDK.XPLM.ProbeType)">
            <summary>
            <para>
            Creates a new probe object of a given type and returns.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.DestroyProbe(XP.SDK.XPLM.Internal.ProbeRef)">
            <summary>
            <para>
            Deallocates an existing probe object.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.ProbeTerrainXYZ(XP.SDK.XPLM.Internal.ProbeRef,System.Single,System.Single,System.Single,XP.SDK.XPLM.Internal.ProbeInfo*)">
            <summary>
            <para>
            Probes the terrain. Pass in the XYZ coordinate of the probe point, a probe
            object, and an XPLMProbeInfo_t struct that has its structSize member set
            properly. Other fields are filled in if we hit terrain, and a probe result
            is returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.GetMagneticVariation(System.Double,System.Double)">
            <summary>
            <para>
            Returns X-Plane's simulated magnetic variation (declination) at the
            indication latitude and longitude.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.DegTrueToDegMagnetic(System.Single)">
            <summary>
            <para>
            Converts a heading in degrees relative to true north into a value relative
            to magnetic north at the user's current location.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.DegMagneticToDegTrue(System.Single)">
            <summary>
            <para>
            Converts a heading in degrees relative to magnetic north at the user's
            current location into a value relative to true north.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.LoadObject(System.Byte*)">
            <summary>
            <para>
            This routine loads an OBJ file and returns a handle to it. If X-Plane has
            already loaded the object, the handle to the existing object is returned.
            Do not assume you will get the same handle back twice, but do make sure to
            call unload once for every load to avoid "leaking" objects. The object will
            be purged from memory when no plugins and no scenery are using it.
            </para>
            <para>
            The path for the object must be relative to the X-System base folder. If
            the path is in the root of the X-System folder you may need to prepend ./
            to it; loading objects in the root of the X-System folder is STRONGLY
            discouraged - your plugin should not dump art resources in the root folder!
            </para>
            <para>
            XPLMLoadObject will return NULL if the object cannot be loaded (either
            because it is not found or the file is misformatted). This routine will
            load any object that can be used in the X-Plane scenery system.
            </para>
            <para>
            It is important that the datarefs an object uses for animation already be
            loaded before you load the object. For this reason it may be necessary to
            defer object loading until the sim has fully started.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.LoadObject(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine loads an OBJ file and returns a handle to it. If X-Plane has
            already loaded the object, the handle to the existing object is returned.
            Do not assume you will get the same handle back twice, but do make sure to
            call unload once for every load to avoid "leaking" objects. The object will
            be purged from memory when no plugins and no scenery are using it.
            </para>
            <para>
            The path for the object must be relative to the X-System base folder. If
            the path is in the root of the X-System folder you may need to prepend ./
            to it; loading objects in the root of the X-System folder is STRONGLY
            discouraged - your plugin should not dump art resources in the root folder!
            </para>
            <para>
            XPLMLoadObject will return NULL if the object cannot be loaded (either
            because it is not found or the file is misformatted). This routine will
            load any object that can be used in the X-Plane scenery system.
            </para>
            <para>
            It is important that the datarefs an object uses for animation already be
            loaded before you load the object. For this reason it may be necessary to
            defer object loading until the sim has fully started.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.LoadObjectAsync(System.Byte*,XP.SDK.XPLM.Internal.ObjectLoadedCallback,System.Void*)">
            <summary>
            <para>
            This routine loads an object asynchronously; control is returned to you
            immediately while X-Plane loads the object. The sim will not stop flying
            while the object loads. For large objects, it may be several seconds before
            the load finishes.
            </para>
            <para>
            You provide a callback function that is called once the load has completed.
            Note that if the object cannot be loaded, you will not find out until the
            callback function is called with a NULL object handle.
            </para>
            <para>
            There is no way to cancel an asynchronous object load; you must wait for
            the load to complete and then release the object if it is no longer
            desired.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.LoadObjectAsync(System.ReadOnlySpan{System.Char}@,XP.SDK.XPLM.Internal.ObjectLoadedCallback,System.Void*)">
            <summary>
            <para>
            This routine loads an object asynchronously; control is returned to you
            immediately while X-Plane loads the object. The sim will not stop flying
            while the object loads. For large objects, it may be several seconds before
            the load finishes.
            </para>
            <para>
            You provide a callback function that is called once the load has completed.
            Note that if the object cannot be loaded, you will not find out until the
            callback function is called with a NULL object handle.
            </para>
            <para>
            There is no way to cancel an asynchronous object load; you must wait for
            the load to complete and then release the object if it is no longer
            desired.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.DrawObjects(XP.SDK.XPLM.Internal.ObjectRef,System.Int32,XP.SDK.XPLM.Internal.DrawInfo*,System.Int32,System.Int32)">
            <summary>
            <para>
            XPLMDrawObjects draws an object from an OBJ file one or more times. You
            pass in the object and an array of XPLMDrawInfo_t structs, one for each
            place you would like the object to be drawn.
            </para>
            <para>
            X-Plane will attempt to cull the objects based on LOD and visibility, and
            will pick the appropriate LOD.
            </para>
            <para>
            Lighting is a boolean; pass 1 to show the night version of object with
            night-only lights lit up. Pass 0 to show the daytime version of the object.
            </para>
            <para>
            earth_relative controls the coordinate system. If this is 1, the rotations
            you specify are applied to the object after its coordinate system is
            transformed from local to earth-relative coordinates -- that is, an object
            with no rotations will point toward true north and the Y axis will be up
            against gravity. If this is 0, the object is drawn with your rotations from
            local coordanates -- that is, an object with no rotations is drawn pointing
            down the -Z axis and the Y axis of the object matches the local coordinate
            Y axis.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.UnloadObject(XP.SDK.XPLM.Internal.ObjectRef)">
            <summary>
            <para>
            This routine marks an object as no longer being used by your plugin.
            Objects are reference counted: once no plugins are using an object, it is
            purged from memory. Make sure to call XPLMUnloadObject once for each
            successful call to XPLMLoadObject.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.LookupObjects(System.Byte*,System.Single,System.Single,XP.SDK.XPLM.Internal.LibraryEnumeratorCallback,System.Void*)">
            <summary>
            <para>
            This routine looks up a virtual path in the library system and returns all
            matching elements. You provide a callback - one virtual path may match many
            objects in the library. XPLMLookupObjects returns the number of objects
            found.
            </para>
            <para>
            The latitude and longitude parameters specify the location the object will
            be used. The library system allows for scenery packages to only provide
            objects to certain local locations. Only objects that are allowed at the
            latitude/longitude you provide will be returned.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Scenery.LookupObjects(System.ReadOnlySpan{System.Char}@,System.Single,System.Single,XP.SDK.XPLM.Internal.LibraryEnumeratorCallback,System.Void*)">
            <summary>
            <para>
            This routine looks up a virtual path in the library system and returns all
            matching elements. You provide a callback - one virtual path may match many
            objects in the library. XPLMLookupObjects returns the number of objects
            found.
            </para>
            <para>
            The latitude and longitude parameters specify the location the object will
            be used. The library system allows for scenery packages to only provide
            objects to certain local locations. Only objects that are allowed at the
            latitude/longitude you provide will be returned.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.SetDatabCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.SetDatadCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.SetDatafCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.SetDataiCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.SetDatavfCallback">
            <summary>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.SetDataviCallback">
            <summary>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.SimulateKeyPress(System.Int32,System.Int32)">
            <summary>
            <para>
            This function simulates a key being pressed for X-Plane. The keystroke goes
            directly to X-Plane; it is never sent to any plug-ins. However, since this
            is a raw key stroke it may be mapped by the keys file or enter text into a
            field.
            </para>
            <para>
            WARNING: This function will be deprecated; do not use it. Instead use
            XPLMCommandKeyStroke.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.SpeakString(System.Byte*)">
            <summary>
            <para>
            This function displays the string in a translucent overlay over the current
            display and also speaks the string if text-to-speech is enabled. The string
            is spoken asynchronously, this function returns immediately.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.SpeakString(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This function displays the string in a translucent overlay over the current
            display and also speaks the string if text-to-speech is enabled. The string
            is spoken asynchronously, this function returns immediately.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.CommandKeyStroke(XP.SDK.XPLM.CommandKeyID)">
            <summary>
            <para>
            This routine simulates a command-key stroke. However, the keys are done by
            function, not by actual letter, so this function works even if the user has
            remapped their keyboard. Examples of things you might do with this include
            pausing the simulator.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.CommandButtonPress(XP.SDK.XPLM.CommandButtonID)">
            <summary>
            <para>
            This function simulates any of the actions that might be taken by pressing
            a joystick button. However, this lets you call the command directly rather
            than have to know which button is mapped where. Important: you must release
            each button you press. The APIs are separate so that you can 'hold down' a
            button for a fixed amount of time.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.CommandButtonRelease(XP.SDK.XPLM.CommandButtonID)">
            <summary>
            <para>
            This function simulates any of the actions that might be taken by pressing
            a joystick button. See XPLMCommandButtonPress
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.GetVirtualKeyDescription(System.Byte)">
            <summary>
            <para>
            Given a virtual key code (as defined in XPLMDefs.h) this routine returns a
            human-readable string describing the character. This routine is provided
            for showing users what keyboard mappings they have set up. The string may
            read 'unknown' or be a blank or NULL string if the virtual key is unknown.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.ReloadScenery">
            <summary>
            <para>
            XPLMReloadScenery reloads the current set of scenery. You can use this
            function in two typical ways: simply call it to reload the scenery, picking
            up any new installed scenery, .env files, etc. from disk. Or, change the
            lat/ref and lon/ref data refs and then call this function to shift the
            scenery environment.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.GetSystemPath(System.Byte*)">
            <summary>
            <para>
            This function returns the full path to the X-System folder. Note that this
            is a directory path, so it ends in a trailing : or /. The buffer you pass
            should be at least 512 characters long.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.GetPrefsPath(System.Byte*)">
            <summary>
            <para>
            This routine returns a full path to a file that is within X-Plane's
            preferences directory. (You should remove the file name back to the last
            directory separator to get the preferences directory. The buffer you pass
            should be at least 512 characters long.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.GetDirectorySeparator">
            <summary>
            <para>
            This routine returns a string with one char and a null terminator that is
            the directory separator for the current platform. This allows you to write
            code that concatinates directory paths without having to #ifdef for
            platform.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.ExtractFileAndPath(System.Byte*)">
            <summary>
            <para>
            Given a full path to a file, this routine separates the path from the file.
            If the path is a partial directory (e.g. ends in : or
            \
            ) the trailing
            directory separator is removed. This routine works in-place; a pointer to
            the file part of the buffer is returned; the original buffer still starts
            with the path.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.GetDirectoryContents(System.Byte*,System.Int32,System.Byte*,System.Int32,System.Byte**,System.Int32,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns a list of files in a directory (specified by a full
            path, no trailing : or
            \
            ). The output is returned as a list of NULL
            terminated strings. An index array (if specified) is filled with pointers
            into the strings. This routine The last file is indicated by a zero-length
            string (and NULL in the indices). This routine will return 1 if you had
            capacity for all files or 0 if you did not. You can also skip a given
            number of files.
            </para>
            <para>
            inDirectoryPath - a null terminated C string containing the full path to
            the directory with no trailing directory char.
            </para>
            <para>
            inFirstReturn - the zero-based index of the first file in the directory to
            return. (Usually zero to fetch all in one pass.)
            </para>
            <para>
            outFileNames - a buffer to receive a series of sequential null terminated
            C-string file names. A zero-length C string will be appended to the very
            end.
            </para>
            <para>
            inFileNameBufSize - the size of the file name buffer in bytes.
            </para>
            <para>
            outIndices - a pointer to an array of character pointers that will become
            an index into the directory. The last file will be followed by a NULL
            value. Pass NULL if you do not want indexing information.
            </para>
            <para>
            inIndexCount - the max size of the index in entries.
            </para>
            <para>
            outTotalFiles - if not NULL, this is filled in with the number of files in
            the directory.
            </para>
            <para>
            outReturnedFiles - if not NULL, the number of files returned by this
            iteration.
            </para>
            <para>
            Return value - 1 if all info could be returned, 0 if there was a buffer
            overrun.
            </para>
            <para>
            WARNING: Before X-Plane 7 this routine did not properly iterate through
            directories. If X-Plane 6 compatibility is needed, use your own code to
            iterate directories.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.GetDirectoryContents(System.ReadOnlySpan{System.Char}@,System.Int32,System.Byte*,System.Int32,System.Byte**,System.Int32,System.Int32*,System.Int32*)">
            <summary>
            <para>
            This routine returns a list of files in a directory (specified by a full
            path, no trailing : or
            \
            ). The output is returned as a list of NULL
            terminated strings. An index array (if specified) is filled with pointers
            into the strings. This routine The last file is indicated by a zero-length
            string (and NULL in the indices). This routine will return 1 if you had
            capacity for all files or 0 if you did not. You can also skip a given
            number of files.
            </para>
            <para>
            inDirectoryPath - a null terminated C string containing the full path to
            the directory with no trailing directory char.
            </para>
            <para>
            inFirstReturn - the zero-based index of the first file in the directory to
            return. (Usually zero to fetch all in one pass.)
            </para>
            <para>
            outFileNames - a buffer to receive a series of sequential null terminated
            C-string file names. A zero-length C string will be appended to the very
            end.
            </para>
            <para>
            inFileNameBufSize - the size of the file name buffer in bytes.
            </para>
            <para>
            outIndices - a pointer to an array of character pointers that will become
            an index into the directory. The last file will be followed by a NULL
            value. Pass NULL if you do not want indexing information.
            </para>
            <para>
            inIndexCount - the max size of the index in entries.
            </para>
            <para>
            outTotalFiles - if not NULL, this is filled in with the number of files in
            the directory.
            </para>
            <para>
            outReturnedFiles - if not NULL, the number of files returned by this
            iteration.
            </para>
            <para>
            Return value - 1 if all info could be returned, 0 if there was a buffer
            overrun.
            </para>
            <para>
            WARNING: Before X-Plane 7 this routine did not properly iterate through
            directories. If X-Plane 6 compatibility is needed, use your own code to
            iterate directories.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.Initialized">
            <summary>
            <para>
            This function returns 1 if X-Plane has properly initialized the plug-in
            system. If this routine returns 0, many XPLM functions will not work.
            </para>
            <para>
            NOTE: Under normal circumstances a plug-in should never be running while
            the plug-in manager is not initialized.
            </para>
            <para>
            WARNING: This function is generally not needed and may be deprecated in the
            future.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.GetVersions(System.Int32*,System.Int32*,XP.SDK.XPLM.HostApplicationID*)">
            <summary>
            <para>
            This routine returns the revision of both X-Plane and the XPLM DLL. All
            versions are three-digit decimal numbers (e.g. 606 for version 6.06 of
            X-Plane); the current revision of the XPLM is 200 (2.00). This routine also
            returns the host ID of the app running us.
            </para>
            <para>
            The most common use of this routine is to special-case around X-Plane
            version-specific behavior.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.GetLanguage">
            <summary>
            <para>
            This routine returns the langauge the sim is running in.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.DebugString(System.Byte*)">
            <summary>
            <para>
            This routine outputs a C-style string to the Log.txt file. The file is
            immediately flushed so you will not lose data. (This does cause a
            performance penalty.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.DebugString(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine outputs a C-style string to the Log.txt file. The file is
            immediately flushed so you will not lose data. (This does cause a
            performance penalty.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.SetErrorCallback(XP.SDK.XPLM.Internal.ErrorCallback)">
            <summary>
            <para>
            XPLMSetErrorCallback installs an error-reporting callback for your plugin.
            Normally the plugin system performs minimum diagnostics to maximize
            performance. When you install an error callback, you will receive calls due
            to certain plugin errors, such as passing bad parameters or incorrect data.
            </para>
            <para>
            The intention is for you to install the error callback during debug
            sections and put a break-point inside your callback. This will cause you to
            break into the debugger from within the SDK at the point in your plugin
            where you made an illegal call.
            </para>
            <para>
            Installing an error callback may activate error checking code that would
            not normally run, and this may adversely affect performance, so do not
            leave error callbacks installed in shipping plugins.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.FindSymbol(System.Byte*)">
            <summary>
            <para>
            This routine will attempt to find the symbol passed in the inString
            parameter. If the symbol is found a pointer the function is returned,
            othewise the function will return NULL.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.FindSymbol(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            This routine will attempt to find the symbol passed in the inString
            parameter. If the symbol is found a pointer the function is returned,
            othewise the function will return NULL.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.LoadDataFile(XP.SDK.XPLM.DataFileType,System.Byte*)">
            <summary>
            <para>
            Loads a data file of a given type. Paths must be relative to the X-System
            folder. To clear the replay, pass a NULL file name (this is only valid with
            replay movies, not sit files).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.LoadDataFile(XP.SDK.XPLM.DataFileType,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Loads a data file of a given type. Paths must be relative to the X-System
            folder. To clear the replay, pass a NULL file name (this is only valid with
            replay movies, not sit files).
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.SaveDataFile(XP.SDK.XPLM.DataFileType,System.Byte*)">
            <summary>
            <para>
            Saves the current situation or replay; paths are relative to the X-System
            folder.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.SaveDataFile(XP.SDK.XPLM.DataFileType,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            Saves the current situation or replay; paths are relative to the X-System
            folder.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.FindCommand(System.Byte*)">
            <summary>
            <para>
            XPLMFindCommand looks up a command by name, and returns its command
            reference or NULL if the command does not exist.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.FindCommand(System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            XPLMFindCommand looks up a command by name, and returns its command
            reference or NULL if the command does not exist.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.CommandBegin(XP.SDK.XPLM.Internal.CommandRef)">
            <summary>
            <para>
            XPLMCommandBegin starts the execution of a command, specified by its
            command reference. The command is "held down" until XPLMCommandEnd is
            called.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.CommandEnd(XP.SDK.XPLM.Internal.CommandRef)">
            <summary>
            <para>
            XPLMCommandEnd ends the execution of a given command that was started with
            XPLMCommandBegin.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.CommandOnce(XP.SDK.XPLM.Internal.CommandRef)">
            <summary>
            <para>
            This executes a given command momentarily, that is, the command begins and
            ends immediately.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.CreateCommand(System.Byte*,System.Byte*)">
            <summary>
            <para>
            XPLMCreateCommand creates a new command for a given string. If the command
            already exists, the existing command reference is returned. The description
            may appear in user interface contexts, such as the joystick configuration
            screen.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.CreateCommand(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char}@)">
            <summary>
            <para>
            XPLMCreateCommand creates a new command for a given string. If the command
            already exists, the existing command reference is returned. The description
            may appear in user interface contexts, such as the joystick configuration
            screen.
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.RegisterCommandHandler(XP.SDK.XPLM.Internal.CommandRef,XP.SDK.XPLM.Internal.CommandCallback,System.Int32,System.Void*)">
            <summary>
            <para>
            XPLMRegisterCommandHandler registers a callback to be called when a command
            is executed. You provide a callback with a reference pointer.
            </para>
            <para>
            If inBefore is true, your command handler callback will be executed before
            X-Plane executes the command, and returning 0 from your callback will
            disable X-Plane's processing of the command. If inBefore is false, your
            callback will run after X-Plane. (You can register a single callback both
            before and after a command.)
            </para>
            </summary>
        </member>
        <member name="M:XP.SDK.XPLM.Internal.Utilities.UnregisterCommandHandler(XP.SDK.XPLM.Internal.CommandRef,XP.SDK.XPLM.Internal.CommandCallback,System.Int32,System.Void*)">
            <summary>
            <para>
            XPLMUnregisterCommandHandler removes a command callback registered with
            XPLMRegisterCommandHandler.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.Internal.WindowID">
            <summary>
            <para>
            This is an opaque identifier for a window.  You use it to control your
            window. When you create a window (via either XPLMCreateWindow() or
            XPLMCreateWindowEx()), you will specify callbacks to handle drawing, mouse
            interaction, etc.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.KeyFlags">
            <summary>
            <para>
            These bitfields define modifier keys in a platform independent way. When a
            key is pressed, a series of messages are sent to your plugin.  The down
            flag is set in the first of these messages, and the up flag in the last.
            While the key is held down, messages are sent with neither to indicate that
            the key is being held down as a repeated character.
            </para>
            <para>
            The control flag is mapped to the control flag on Macintosh and PC.
            Generally X-Plane uses the control key and not the command key on
            Macintosh, providing a consistent interface across platforms that does not
            necessarily match the Macintosh user interface guidelines.  There is not
            yet a way for plugins to access the Macintosh control keys without using
            #ifdefed code.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.LanguageCode">
            <summary>
            <para>
            These enums define what language the sim is running in. These enumerations
            do not imply that the sim can or does run in all of these languages; they
            simply provide a known encoding in the event that a given sim version is
            localized to a certain language.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MapLayerType">
            <summary>
            <para>
            Indicates the type of map layer you are creating. Fill layers will always
            be drawn beneath markings layers.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MapOrientation">
            <summary>
            <para>
            Indicates whether a map element should be match its rotation to the map
            itself, or to the user interface. For instance, the map itself may be
            rotated such that "up" matches the user's aircraft, but you may want to
            draw a text label such that it is always rotated zero degrees relative to
            the user's perspective. In that case, you would have it draw with UI
            orientation.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MapStyle">
            <summary>
            <para>
            Indicates the visual style being drawn by the map. In X-Plane, the user can
            choose between a number of map types, and different map types may have use
            a different visual representation for the same elements (for instance, the
            visual style of the terrain layer changes drastically between the VFR and
            IFR layers), or certain layers may be disabled entirely in some map types
            (e.g., localizers are only visible in the IFR low-enroute style).
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MenuCheck">
            <summary>
            <para>
            These enumerations define the various 'check' states for an X-Plane menu.
            'checking' in X-Plane actually appears as a light which may or may not be
            lit.  So there are three possible states.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.MouseStatus">
            <summary>
            <para>
            When the mouse is clicked, your mouse click routine is called repeatedly.
            It is first called with the mouse down message.  It is then called zero or
            more times with the mouse-drag message, and finally it is called once with
            the mouse up message.  All of these messages will be directed to the same
            window; you are guaranteed to not receive a drag or mouse-up event without
            first receiving the corresponding mouse-down.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.NavType">
            <summary>
            <para>
            These enumerations define the different types of navaids.  They are each
            defined with a separate bit so that they may be bit-wise added together to
            form sets of nav-aid types.
            </para>
            <para>
            NOTE: xplm_Nav_LatLon is a specific lat-lon coordinate entered into the
            FMS. It will not exist in the database, and cannot be programmed into the
            FMS. Querying the FMS for navaids will return it.  Use
            XPLMSetFMSEntryLatLon to set a lat/lon waypoint.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.ProbeResult">
            <summary>
            <para>
            Probe results - possible results from a probe query.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.ProbeType">
            <summary>
            <para>
            XPLMProbeType defines the type of terrain probe - each probe has a
            different algorithm. (Only one type of probe is provided right now, but
            future APIs will expose more flexible or poewrful or useful probes.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.TextureID">
            <summary>
            <para>
            XPLM Texture IDs name well-known textures in the sim for you to use. This
            allows you to recycle textures from X-Plane, saving VRAM.
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.WindowDecoration">
            <summary>
            <para>
            XPLMWindowDecoration describes how "modern" windows will be displayed. This
            impacts both how X-Plane draws your window as well as certain mouse
            handlers.
            </para>
            <para>
            Your window's decoration can only be specified when you create the window
            (in the XPLMCreateWindow_t you pass to XPLMCreateWindowEx()).
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.WindowLayer">
            <summary>
            <para>
            XPLMWindowLayer describes where in the ordering of windows X-Plane should
            place a particular window. Windows in higher layers cover windows in lower
            layers. So, a given window might be at the top of its particular layer, but
            it might still be obscured by a window in a higher layer. (This happens
            frequently when floating windows, like X-Plane's map, are covered by a
            modal alert.)
            </para>
            <para>
            Your window's layer can only be specified when you create the window (in
            the XPLMCreateWindow_t you pass to XPLMCreateWindowEx()). For this reason,
            layering only applies to windows created with new X-Plane 11 GUI features.
            (Windows created using the older XPLMCreateWindow(), or windows compiled
            against a pre-XPLM300 version of the SDK will simply be placed in the
            flight overlay window layer.)
            </para>
            </summary>
        </member>
        <member name="T:XP.SDK.XPLM.WindowPositioningMode">
            <summary>
            <para>
            XPLMWindowPositionMode describes how X-Plane will position your window on
            the user's screen. X-Plane will maintain this positioning mode even as the
            user resizes their window or adds/removes full-screen monitors.
            </para>
            <para>
            Positioning mode can only be set for "modern" windows (that is, windows
            created using XPLMCreateWindowEx() and compiled against the XPLM300 SDK).
            Windows created using the deprecated XPLMCreateWindow(), or windows
            compiled against a pre-XPLM300 version of the SDK will simply get the
            "free" positioning mode.
            </para>
            </summary>
        </member>
    </members>
</doc>
